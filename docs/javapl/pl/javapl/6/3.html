<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>INTUIT.ru::Интернет-Университет Информационных Технологий</title>
<link rel="shortcut icon" href="http://www.intuit.ru/favicon.ico">


<META http-equiv="Pragma" CONTENT="no-cache">
<META http-equiv="Cache-Control" CONTENT="no-cache, must-revalidate">
<META NAME="Pragma" CONTENT="no-cache">
<META NAME="Cache-Control" CONTENT="no-cache">
<link href="../../../ssi/style.css" type="text/css" rel="stylesheet">
</head>
<body leftmargin="0" topmargin="6" marginheight="6" marginwidth="0" bgcolor="white">

<!-- header -->
<!---->
<table border="0" cellpadding="8" cellspacing="0" width="100%">
<tr valign="top">
<td><a href="http://www.intuit.ru/"><img src="../../../img/logo.gif" border="0" width="285" height="52" alt="Интернет Университет информационных технологий"></a></td>
<!---->
</tr>
</table>

<!-- /header -->

<!-- /menu -->
<table border="0" cellpadding="" cellspacing="6" width="100%">
<tr>
<td align="center" class="menu">
	<table border="0" cellpadding="0" cellspacing="0" background="" height="31">
	<tr>
	<td><a href="http://www.intuit.ru/speciality/" class="menu">Учебные программы</a></td>
	<td><img src="../../../img/separator.gif" width="2" height="18" border="0" hspace="7"></td>
	<td><a href="http://www.intuit.ru/all_departments.html" class="menu">Кафедры</a></td>	
	<td><img src="../../../img/separator.gif" width="2" height="18" border="0" hspace="7"></td>
	<td><a href="http://www.intuit.ru/all_courses.html" class="menu">Все курсы</a></td>	
	<td><img src="../../../img/separator.gif" width="2" height="18" border="0" hspace="7"></td>
	<td><a href="http://www.intuit.ru/syllabus.html" class="menu">Расписание</a></td>		
	<td><img src="../../../img/separator.gif" width="2" height="18" border="0" hspace="7"></td>
	<td><a href="http://www.intuit.ru/shop/" class="menu">Учебники</a></td>		
	<td><img src="../../../img/separator.gif" width="2" height="18" border="0" hspace="7"></td>
	<td><a href="http://www.intuit.ru/news.html" class="menu">Новости</a></td>		
	<td><img src="../../../img/separator.gif" width="2" height="18" border="0" hspace="7"></td>
	<td><a href="http://www.intuit.ru/department/forum/" class="menu">Форум</a></td>
<!--
	<td><img src="../../../img/separator.gif" width="2" height="18" border="0" hspace="7"></td>
	<td><a href="http://www.intuit.ru/help/" class="menu">Помощь</a></td>		
-->
	</tr>
	</table>	

</td>
</tr>
</table>
<!-- /menu -->


<table border="0" cellpadding="0" cellspacing="0" width="100%" height="73">
<tr valign="top">
<td width="6"><img src="../../../img/empty.gif" width="6"></td>
<td width="180">
	<!-- leftcolumn -->
	<table border="0" cellpadding="2" cellspacing="0" background="" width="100%">

		<tr valign="middle">
	<td class="orang" height="24">&nbsp;&nbsp;Лекции</td>
	</tr>
	<tr>
	<td>
		<table border="0" cellpadding="0" cellspacing="0">

		<tr valign=top>

		<td colspan=3>
<a href="../index.html" class="spec">Программирование на Java</a>


</td>
		</tr>
<tr valign=top><td colspan="3" height="6"><img src="../../../img/empty.gif" width="1" height="6"></td></tr>

		<tr valign=top>

		<td class="llecture">1.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../1/1.html" class="llecture">Что такое Java? История создания</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">2.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../2/1.html" class="llecture">Основы объектно-ориентированного...</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">3.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../3/1.html" class="llecture">Лексика языка</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">4.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../4/1.html" class="llecture">Типы данных</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">5.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../5/1.html" class="llecture">Имена. Пакеты</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">6.</td>
		<td>&nbsp;</td>
<td class="llecture">


<a href="../6/1.html" class="llecture_selected">Объявление классов</a>


</td>
		</tr>




		<tr valign=top>

		<td class="llecture">7.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../7/1.html" class="llecture">Преобразование типов</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">8.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../8/1.html" class="llecture">Объектная модель в Java</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">9.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../9/1.html" class="llecture">Массивы</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">10.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../10/1.html" class="llecture">Операторы и структура кода. Искл...</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">11.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../11/1.html" class="llecture">Пакет java.awt</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">12.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../12/1.html" class="llecture">Потоки выполнения. Синхронизация</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">13.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../13/1.html" class="llecture">Пакет java.lang</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">14.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../14/1.html" class="llecture">Пакет java.util</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">15.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../15/1.html" class="llecture">Пакет java.io</a>
</td>
		</tr>




		<tr valign=top>

		<td class="llecture">16.</td>
		<td>&nbsp;</td>
<td class="llecture">

<a href="../16/1.html" class="llecture">Введение в сетевые протоколы</a>
</td>
		</tr>






<tr valign=top><td colspan="3" height="6"><img src="../../../img/empty.gif" width="1" height="6"></td></tr>
		<tr valign=top>

		<td class="llecture">&nbsp;</td>
<td>&nbsp;</td>

		<td class="llecture"><a href="http://www.intuit.ru/department/pl/javapl/class/examination/" class="llecture">Экзамен</a></td>
		</tr>
		<tr valign=top>

		<td class="llecture">&nbsp;</td>
<td>&nbsp;</td>

		<td class="llecture"><a class="llecture_red" href="http://www.intuit.ru/department/pl/javapl/class/examination_extern/">Сдать экзамен экстерном</a></td>
		</tr>

<tr valign=top><td colspan="3" height="6"><img src="../../../img/empty.gif" width="1" height="6"></td></tr>

		<tr valign=top>

		<td class="llecture">&nbsp;</td>
<td>&nbsp;</td>

		<td class="llecture"><a href="../lit.html" class="llecture">Литература</a></td>
		</tr>





		<tr valign=top>

		<td class="llecture">&nbsp;</td>
<td>&nbsp;</td>

		<td class="llecture"><a href="../keywords.html" class="llecture">Предметный указатель</a></td>
		</tr>



		<tr valign=top>

		<td class="llecture">&nbsp;</td>
<td>&nbsp;</td>

		<td class="llecture"><a href="../examples.html" class="llecture">Примеры</a></td>
		</tr>


		</table><br>
	</td>
	</tr>


	

	<tr valign="middle">
	<td class="orang" height="24">&nbsp;&nbsp;Общение</td>
	</tr>
	<tr>
	<td>
		<table border="0" cellpadding="0" cellspacing="0">

		<tr valign=top>
		<td><img src="../../../img/arrow.gif" border="0" width="6" height="7" hspace="5" vspace="5"></td>
		<td><a href="http://www.intuit.ru/department/pl/javapl/class/classmates/" class="spec">однокурсники</a></td>
		</tr>
		

		<tr valign=top>
		<td><img src="../../../img/arrow.gif" border="0" width="6" height="7" hspace="5" vspace="5"></td>
		<td><a href="http://www.intuit.ru/department/pl/javapl/forum/" class="spec">форум по курсу</a></td>
		</tr>

		<tr valign=top>
		<td><img src="../../../img/arrow.gif" border="0" width="6" height="7" hspace="5" vspace="5"></td>
		<td><a href="http://www.intuit.ru/department/pl/javapl/class/question_for_lector/" class="spec">вопрос преподавателю</a></td>
		</tr>

		<tr valign=top>
		<td><img src="../../../img/arrow.gif" border="0" width="6" height="7" hspace="5" vspace="5"></td>
		<td><a href="http://www.intuit.ru/department/pl/javapl/class/opinions/" class="spec">мнения о курсе</a></td>
		</tr>

		<tr valign=top>
		<td><img src="../../../img/arrow.gif" border="0" width="6" height="7" hspace="5" vspace="5"></td>
		<td><a href="http://www.intuit.ru/department/pl/javapl/class/rating/" class="spec">рейтинг выпускников</a></td>
		</tr>


		</table><br>
	</td>
	</tr>



<tr><td height="1"><a href="../robot.html"><img src="../../../img/empty.gif" width="1" height="1" border="0"></a></td></tr>

	</table>

	<!-- #include virtual="~/inc/leftcolumn.html" -->
	<!-- /leftcolumn -->	
</td>
<td width="6"><img src="../../../img/empty.gif" width="6"></td>
<td width="1" class="gray"><img src="../../../img/empty.gif"></td>
<td width="6"><img src="../../../img/empty.gif" width="6"></td>
<td>
	<!-- content -->
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr><td class="head" colspan=2>Программирование на Java</td></tr>
<tr><td colspan=2 height="4"><img src="../../../img/empty.gif" width="1" height="4"></td></tr>
	<tr><td class="orang" height="1" colspan=2><img src="../../../img/empty.gif" width="1" height="1"></td></tr>
	<tr><td height="8" colspan=2><img src="../../../img/empty.gif" width="1" height="8"></td></tr>




<tr>
<td colspan="2" align=left class="headsub">Лекция #6: <a href="../6/1.html">Объявление классов</a></td>
</tr>

<tr><td height="6" colspan=2><img src="../../../img/empty.gif" width="1" height="8"></td></tr>
<tr><td class="orang" height="1" colspan=2><img src="../../../img/empty.gif" width="1" height="1"></td></tr>
<tr><td height="2" colspan=2><img src="../../../img/empty.gif" width="1" height="2"></td></tr>


<tr>

<td align=left><font class="rtitle">Страницы:</font>
<a class="rtitle" href="2.html">&laquo;</a> <font class="stitle">|</font>


<a class="rtitle" href="1.html">1</a>
<font class="stitle">|</font>


<a class="rtitle" href="2.html">2</a>
<font class="stitle">|</font>

<font class="rtitle">3</font>

<font class="stitle">|</font>


<a class="rtitle" href="4.html">4</a>
<font class="stitle">|</font>


<a class="rtitle" href="http://www.intuit.ru/department/pl/javapl/6/test/">вопросы</a> <font class="stitle">|</font> 
<a class="rtitle" href="4.html"><b>&raquo;</b></a>
</td>
<td align=right><font class="stitle">|</font>
<a href="http://www.intuit.ru/department/pl/javapl/6/javapl_6.html" class="rtitle" target="_blank">HTML для печати</a>




</td>

</tr>


	<tr><td height="2" colspan=2><img src="../../../img/empty.gif" width="1" height="2"></td></tr>
<tr><td align="center" class="orang_light" colspan="2">
&nbsp;
<font class="rtxt">Если Вы заметили ошибку на этой странице - <a class="llecture_red" target="_blank" href="http://www.intuit.ru/help/askform.xhtml?course=57&url=http://www.intuit.ru/department/pl/javapl/6/3.html">сообщите нам.</a></font>
&nbsp;
</td></tr>

	<tr><td height="8" colspan=2><img src="../../../img/empty.gif" width="1" height="8"></td></tr>
	<tr><td colspan=2>


    
        
        <h4 >Объявление методов</h4>
            
            <p >
Объявление <span class="keyword">метода</span> состоит из заголовка и <span class="keyword">тела метода</span>. Заголовок состоит из: 
</p>
            <ul >
                <li>модификаторов (доступа в том числе);</li>
                <li>типа возвращаемого значения или ключевого слова <span class="texample">void</span>; </li>
                <li>имени <span class="keyword">метода</span>;</li>
                <li>списка аргументов в круглых скобках (аргументов может не быть);</li>
                <li>специального <span class="texample">throws</span>-выражения.</li>
            </ul>
            <p >
Заголовок начинается с перечисления модификаторов. Для <span class="keyword">методов</span> доступен
любой из трех возможных модификаторов доступа. Также допускается
использование доступа по умолчанию. </p>
            <p >
Кроме того, существует модификатор <span class="texample">final</span>, который говорит о том, что такой <span class="keyword">метод</span> нельзя переопределять в наследниках. Можно считать, что все <span class="keyword">методы</span>
                <span class="texample">final</span>-класса, а также все <span class="texample">private</span>-<span class="keyword">методы</span> любого класса, являются <span class="texample">final</span>. 
</p>
            <p >
Также поддерживается модификатор <span class="texample">native</span>.
<span class="keyword">Метод</span>, объявленный с таким модификатором, не имеет реализации на Java.
Он должен быть написан на другом языке (C/C++, Fortran и т.д.) и
добавлен в систему в виде загружаемой динамической библиотеки
(например, DLL для Windows). Существует специальная спецификация JNI
(Java Native Interface), описывающая правила создания и использования <span class="texample">native</span>-<span class="keyword">методов</span>. 
</p>
            <p >
Такая возможность для Java необходима, поскольку многие компании имеют
обширные программные библиотеки, написанные на более старых языках. Их
было бы очень трудоемко и неэффективно переписывать на Java, поэтому
необходима возможность подключать их в таком виде, в каком они есть.
Безусловно, при этом Java-приложения теряют целый ряд своих
преимуществ, таких, как переносимость, безопасность и другие. Поэтому
применять JNI следует только в случае крайней необходимости. </p>
            <p >
Эта спецификация накладывает требования на имена процедур во внешних
библиотеках (она составляет их из имени пакета, класса и самого <span class="texample">native</span>-<span class="keyword">метода</span>),
а поскольку библиотеки менять, как правило, очень неудобно, часто пишут
специальные библиотеки-"обертки", к которым обращаются Java-классы
через JNI, а они сами обращаются к целевым модулям. </p>
            <p >
Наконец, существует еще один специальный модификатор <span class="texample">synchronized</span>, который будет рассмотрен в лекции, описывающей потоки выполнения. 
</p>
            <p >
После перечисления модификаторов указывается имя (простое или
составное) типа возвращаемого значения; это может быть как примитивный,
так и объектный тип. Если <span class="keyword">метод</span> не возвращает никакого значения,
указывается ключевое слово <span class="texample">void</span>. 
</p>
            <p >
Затем определяется имя <span class="keyword">метода</span>. Указанный идентификатор при объявлении
становится простым именем <span class="keyword">метода</span>. Составное имя формируется из имени
класса или имени переменной объектного типа и простого имени <span class="keyword">метода</span>.
Областью видимости <span class="keyword">метода</span> является все объявление тела класса. </p>
            <p >
Аргументы <span class="keyword">метода</span> перечисляются через запятую. Для каждого указывается
сначала тип, затем имя параметра. В отличие от объявления переменной
здесь запрещается указывать два имени для одного типа: </p>
            <div  class="example"><pre>
// void calc (double x, y); - ошибка!
void calc (double x, double y); 
</pre></div>
            <p >
Если аргументы отсутствуют, указываются пустые круглые скобки.
Одноименные параметры запрещены. Создание локальных переменных в
<span class="keyword">методе</span>, с именами, совпадающими с именами параметров, запрещено. Для
каждого аргумента можно ввести ключевое слово <span class="texample">final</span>
перед указанием его типа. В этом случае такой параметр не может менять
своего значения в <span class="keyword">теле метода</span> (то есть участвовать в операции
присвоения в качестве левого операнда). </p>
            <div  class="example"><pre>
public void process(int x, final double y) {
   x=x*x+Math.sqrt(x);
   
   // y=Math.sin(x); - так писать нельзя, 
   // т.к. y - final!
} 
</pre></div>
            <p >
О том, как происходит изменение значений аргументов <span class="keyword">метода</span>, рассказано в конце этой лекции. 
</p>
            <p >
Важным понятием является <span class="keyword">сигнатура</span> (signature) <span class="keyword">метода</span>.
<span class="keyword">Сигнатура</span> определяется именем <span class="keyword">метода</span> и его аргументами (количеством,
типом, порядком следования). Если для полей запрещается совпадение
имен, то для <span class="keyword">методов</span> в классе запрещено создание двух <span class="keyword">методов</span> с
одинаковыми <span class="keyword">сигнатурами</span>. </p>
            <p >
Например, 
</p>
            <div  class="example"><pre>
class Point {
   void get() {}
   void get(int x) {}
   void get(int x, double y) {}
   void get(double x, int y) {}
} 
</pre></div>
            <p >
Такой класс объявлен корректно. Следующие пары <span class="keyword">методов</span> в одном классе друг с другом несовместимы: 
</p>
            <div  class="example"><pre>
void get() {}
int get() {}

void get(int x) {}
void get(int y) {}

public int get() {}
private int get() {} 
</pre></div>
            <p >
В первом случае <span class="keyword">методы</span> отличаются типом возвращаемого значения,
которое, однако, не входит в определение <span class="keyword">сигнатуры</span>. Стало быть, это два
<span class="keyword">метода</span> с одинаковыми <span class="keyword">сигнатурами</span> и они не могут одновременно появиться
в объявлении тела класса. Можно составить пример, который создал бы
неразрешимую проблему для компилятора, если бы был допустим: </p>
            <div  class="example"><pre>
// пример вызовет ошибку компиляции
class Test {
   int get() {
      return 5;
   }
   Point get() {
      return new Point(3,5);
   }

   void print(int x) {
      System.out.println("it's int! "+x);
   }
   void print(Point p) {
      System.out.println("it's Point! "+p.x+
                         ", "+p.y);
   }

   public static void main (String s[]) {
      Test t = new Test();
      t.print(t.get());   // Двусмысленность!
   }
} 
</pre></div>
            <p >
В классе определена запрещенная пара <span class="keyword">методов</span>
                <span class="texample">get()</span>
с одинаковыми <span class="keyword">сигнатурами</span> и различными возвращаемыми значениями.
Обратимся к выделенной строке в <span class="keyword">методе</span> <span class="texample">main</span>, где возникает конфликтная
ситуация, с которой компилятор не может справиться. Определены два
<span class="keyword">метода</span>
                <span class="texample">print()</span> (у них разные аргументы,
а значит, и <span class="keyword">сигнатуры</span>, то есть это допустимые <span class="keyword">методы</span>), и чтобы
разобраться, какой из них будет вызван, нужно знать точный тип
возвращаемого значения <span class="keyword">метода</span>
                <span class="texample">get()</span>, что невозможно. 
</p>
            <p >
На основе этого примера можно понять, как составлено понятие <span class="keyword">сигнатуры</span>.
Действительно, при вызове указывается имя <span class="keyword">метода</span> и перечисляются его
аргументы, причем компилятор всегда может определить их тип. Как раз
эти понятия и составляют <span class="keyword">сигнатуру</span>, и требование ее уникальности
позволяет компилятору всегда однозначно определить, какой <span class="keyword">метод</span> будет
вызван. </p>
            <p >
Точно так же в предыдущем примере вторая пара <span class="keyword">методов</span> различается
именем аргументов, которые также не входят в определение <span class="keyword">сигнатуры</span> и не
позволяют определить, какой из двух <span class="keyword">методов</span> должен быть вызван. </p>
            <p >
Аналогично, третья пара различается лишь модификаторами доступа, что также недопустимо. 
</p>
            <p >
Наконец, завершает <span class="keyword">заголовок метода</span>
                <span class="texample">throws</span>-выражение. Оно применяется для корректной работы с ошибками в Java и будет подробно рассмотрено в соответствующей лекции. 
</p>
            <p >
Пример объявления <span class="keyword">метода</span>: 
</p>
            <div  class="example"><pre>
public final java.awt.Point 
   createPositivePoint(int x, int y)
   throws IllegalArgumentException
{
   return (x&gt;0 &amp;&amp; y&gt;0) ? 
           new Point(x, y) : null;
} 
</pre></div>
            <p >
Далее, после <span class="keyword">заголовка метода</span> следует <span class="keyword">тело метода</span>. Оно может быть пустым и тогда записывается одним символом "точка с запятой". <span class="texample">Native</span>-<span class="keyword">методы</span> всегда имеют только пустое тело, поскольку настоящая реализация написана на другом языке. 
</p>
            <p >
Обычные же <span class="keyword">методы</span> имеют непустое тело, которое описывается в фигурных
скобках, что показано в многочисленных примерах в этой и других
лекциях. Если текущая реализация <span class="keyword">метода</span> не выполняет никаких действий,
тело все равно должно описываться парой пустых фигурных скобок: </p>
            <div  class="example"><pre>
public void empty() {} 
</pre></div>
            <p >
Если в заголовке метода указан тип возвращаемого значения, а не <span class="texample">void</span>, то в <span class="keyword">теле метода</span> обязательно должно встречаться <span class="texample">return</span>-выражение.
При этом компилятор проводит анализ структуры <span class="keyword">метода</span>, чтобы
гарантировать, что при любых операторах ветвления возвращаемое значение
будет сгенерировано. Например, следующий пример является некорректным: </p>
            <div  class="example"><pre>
// пример вызовет ошибку компиляции
public int get() {
   if (condition) {
      return 5;
   }
} 
</pre></div>
            <p >
Видно, что хотя <span class="keyword">тело метода</span> содержит <span class="texample">return</span>-выражение, однако не при любом развитии событий возвращаемое значение будет сгенерировано. А вот такой пример является верным: 
</p>
            <div  class="example"><pre>
public int get() {
   if (condition) {
      return 5;
   } else {
      return 3;
   }
} 
</pre></div>
            <p >
Конечно, значение, указанное после слова <span class="texample">return</span>, должно быть совместимо
по типу с объявленным возвращаемым значением (это понятие подробно
рассматривается в лекции 7). </p>
            <p >
В <span class="keyword">методе</span> без возвращаемого значения (указано <span class="texample">void</span>) также можно использовать выражение <span class="texample">return</span> без каких-либо аргументов. Его можно указать в любом месте <span class="keyword">метода</span> и в этой точке выполнение <span class="keyword">метода</span> будет завершено: 
</p>
            <div  class="example"><pre>
public void calculate(int x, int y) {
   if (x&lt;=0 || y&lt;=0) {
      return;   // некорректные входные 
                // значения, выход из метода
   }
   ...   // основные вычисления
} 
</pre></div>
            <p >
Выражений <span class="texample">return</span> (с параметром или
без для <span class="keyword">методов</span> с/без возвращаемого значения) в теле одного <span class="keyword">метода</span>
может быть сколько угодно. Однако следует помнить, что множество точек
выхода в одном <span class="keyword">методе</span> может заметно усложнить понимание логики его
работы.
</p>
        
        <h4 >Объявление конструкторов</h4>
            
            <p >Формат объявления конструкторов похож на упрощенное объявление
<span class="keyword">методов</span>. Также выделяют заголовок и тело конструктора. Заголовок
состоит, во-первых, из модификаторов доступа (никакие другие
модификаторы недопустимы). Во-вторых, указывается имя класса, которое
можно расценивать двояко. Можно считать, что имя конструктора совпадает
с именем класса. А можно рассматривать конструктор как безымянный, а
имя класса – как тип возвращаемого значения, ведь конструктор может
породить только объект класса, в котором он объявлен. Это исключительно
дело вкуса, так как на формате объявления никак не сказывается: </p>
            <div  class="example"><pre>
public class Human {
   private int age;

   protected Human(int a) {
      age=a;
   }

   public Human(String name, Human mother, 
                Human father) {
      age=0;
   }
}
</pre></div>
            <p >
Как видно из примеров, далее следует перечисление входных аргументов по
тем же правилам, что и для <span class="keyword">методов</span>. Завершает заголовок конструктора <span class="texample">throws</span>-выражение.
Оно имеет особую важность для конструкторов, поскольку сгенерировать
ошибку – это для конструктора единственный способ не создавать объект.
Если конструктор выполнился без ошибок, то объект гарантированно
создается. </p>
            <p >
Тело конструктора пустым быть не может и поэтому всегда описывается в
фигурных скобках (для простейших реализаций скобки могут быть пустыми).
</p>
            <p >
В отсутствие имени (или из-за того, что у всех конструкторов одинаковое
имя, совпадающее с именем класса) <span class="keyword">сигнатура</span> конструктора определяется
только набором входных параметров по тем же правилам, что и для
<span class="keyword">методов</span>. Аналогично, в одном классе допускается любое количество
конструкторов, если у них различные <span class="keyword">сигнатуры</span>. </p>
            <p >
Тело конструктора может содержать любое количество <span class="texample">return</span>-выражений
без аргументов. Если процесс исполнения дойдет до такого выражения, то
на этом месте выполнение конструктора будет завершено. </p>
            <p >
Однако логика работы конструкторов имеет и некоторые важные
особенности. Поскольку при их вызове осуществляется создание и
инициализация объекта, становится понятно, что такой процесс не может
происходить без обращения к конструкторам всех родительских классов.
Поэтому вводится обязательное правило – первой строкой в конструкторе
должно быть обращение к родительскому классу, которое записывается с
помощью ключевого слова <span class="texample">super</span>. 
</p>
            <div  class="example"><pre> 
public class Parent {
   private int x, y;

   public Parent() {
      x=y=0;
   }

   public Parent(int newx, int newy) {
      x=newx;
      y=newy;
   }
}

public class Child extends Parent {
   public Child() {
      super();
   }

   public Child(int newx, int newy) {
      super(newx, newy);
   }
} 
</pre></div>
            <p >
Как видно, обращение к родительскому конструктору записывается с помощью <span class="texample">super</span>,
за которым идет перечисление аргументов. Этот набор определяет, какой
из родительских конструкторов будет использован. В приведенном примере
в каждом классе имеется по два конструктора и каждый конструктор в
наследнике обращается к аналогичному в родителе (это довольно
распространенный, но, конечно, не обязательный способ). </p>
            <p >
Проследим мысленно весь алгоритм создания объекта. Он начинается при исполнении выражения с ключевым словом <span class="texample">new</span>,
за которым следует имя класса, от которого будет порождаться объект, и
набор аргументов для его конструктора. По этому набору определяется,
какой именно конструктор будет использован, и происходит его вызов.
Первая строка его тела содержит вызов родительского конструктора. В
свою очередь, первая строка тела конструктора родителя будет содержать
вызов к его родителю, и так далее. Восхождение по дереву наследования
заканчивается, очевидно, на классе <span class="texample">Object</span>,
у которого есть единственный конструктор без параметров. Его тело
пустое (записывается парой пустых фигурных скобок), однако можно
считать, что именно в этот момент JVM порождает объект и далее
начинается процесс его инициализации. Выполнение начинает обратный путь
вниз по дереву наследования. У самого верхнего родителя, прямого
наследника от <span class="texample">Object</span>, происходит
продолжение исполнения конструктора со второй строки. Когда он будет
полностью выполнен, необходимо перейти к следующему родителю, на один
уровень наследования вниз, и завершить выполнение его конструктора, и
так далее. Наконец, можно будет вернуться к конструктору исходного
класса, который был вызван с помощью <span class="texample">new</span>,
и также продолжить его выполнение со второй строки. По его завершении
объект считается полностью созданным, исполнение выражения new будет
закончено, а в качестве результата будет возвращена ссылка на
порожденный объект. </p>
            <p >
Проиллюстрируем этот алгоритм следующим примером: 
</p>
            <div  class="example"><pre>
public class GraphicElement {
   private int x, y;   // положение на экране

   public GraphicElement(int nx, int ny) {
      super();   // обращение к конструктору 
                 // родителя Object
      System.out.println("GraphicElement");
      x=nx;
      y=nx;
      }
}

public class Square extends GraphicElement {
   private int side;

   public Square(int x, int y, int nside) {
      super(x, y);
      System.out.println("Square");
         side=nside;
   }
}

public class SmallColorSquare extends Square {
   private Color color;

   public SmallColorSquare(int x, int y, 
                           Color c) {
      super(x, y, 5);
      System.out.println("SmallColorSquare");
      color=c;
   }
}
</pre></div>
            <p >
После выполнения выражения создания объекта на экране появится следующее: 
</p>
            <div  class="example"><pre>
GraphicElement
Square
SmallColorSquare 
</pre></div>
            <p >
Выражение <span class="texample">super</span> может стоять только
на первой строке конструктора. Часто можно увидеть конструкторы вообще
без такого выражения. В этом случае компилятор первой строкой по
умолчанию добавляет вызов родительского конструктора без параметров (<span class="texample">super()</span>). Если у родительского класса такого конструктора нет, выражение <span class="texample">super</span> обязательно должно быть записано явно (и именно на первой строке), поскольку необходима передача входных параметров. 
</p>
            <p >
Напомним, что, во-первых, конструкторы не имеют имени и их нельзя
вызвать явно, только через выражение создания объекта. Кроме того,
конструкторы не передаются по наследству. То есть, если в родительском
классе объявлено пять разных полезных конструкторов и требуется, чтобы
класс-наследник имел аналогичный набор, необходимо все их описать
заново. </p>
            <p >
Класс обязательно должен иметь конструктор, иначе невозможно порождать
объекты ни от него, ни от его наследников. Поэтому если в классе не
объявлен ни один конструктор, компилятор добавляет один по умолчанию.
Это <span class="texample">public</span>-конструктор
без параметров и с телом, описанным парой пустых фигурных скобок. Из
этого следует, что такое возможно только для классов, у родителей
которых объявлен конструктор без параметров, иначе возникнет ошибка
компиляции. Обратите внимание, что если затем в такой класс добавляется
конструктор (не важно, с параметрами или без), то конструктор по
умолчанию больше не вставляется: </p>
            <div  class="example"><pre>
/*
   * Этот класс имеет один конструктор.
   */
public class One {
   // Будет создан конструктор по умолчанию
   // Родительский класс Object имеет
   // конструктор без параметров.
}

/*
   * Этот класс имеет один конструктор.
   */
public class Two {
   // Единственный конструктор класса Two.
   // Выражение new Two() ошибочно!
   public Two(int x) {
   }
}

/*
   * Этот класс имеет два конструктора.
   */
public class Three extends Two {
   public Three() {
      super(1);   // выражение super требуется
   }

   public Three(int x) {
      super(x);   // выражение super требуется
   }
} 
</pre></div>
            <p >
Если класс имеет более одного конструктора, допускается в первой строке некоторых из них указывать не <span class="texample">super</span>, а <span class="texample">this</span> – выражение, вызывающее другой конструктор этого же класса. 
</p>
            <p >
Рассмотрим следующий пример: 
</p>
            <div  class="example"><pre>
public class Vector {
   private int vx, vy;
   protected double length;

   public Vector(int x, int y) {
      super();
      vx=x;
      vy=y;
      length=Math.sqrt(vx*vx+vy*vy);
   }

   public Vector(int x1, int y1, 
                 int x2, int y2) {
      super();
      vx=x2-x1;
      vy=y2-y1;
      length=Math.sqrt(vx*vx+vy*vy);
   }
} 
</pre></div>
            <p >
Видно, что оба конструктора совершают практически идентичные действия, поэтому можно применить более компактный вид записи: 
</p>
            <div  class="example"><pre>
public class Vector {
   private int vx, vy;
   protected double length;

   public Vector(int x, int y) {
      super();
      vx=x;
      vy=y;
      length=Math.sqrt(vx*vx+vy*vy);
   }

   public Vector(int x1, int y1, 
                 int x2, int y2) {
      this(x2-x1, y2-y1);
   }
} 
</pre></div>
            <p >
Большим достоинством такого <span class="keyword">метода</span> записи является то, что удалось
избежать дублирования идентичного кода. Например, если процесс
инициализации объектов этого класса удлинится на один шаг (скажем,
добавится проверка длины на ноль), то такое изменение надо будет внести
только в первый конструктор. Такой подход помогает избежать случайных
ошибок, так как исчезает необходимость тиражировать изменения в
нескольких местах. </p>
            <p >
Разумеется, такое обращение к конструкторам своего класса не должно
приводить к зацикливаниям, иначе будет выдана ошибка компиляции.
Цепочка <span class="texample">this</span> должна в итоге приводить к <span class="texample">super</span>,
который должен присутствовать (явно или неявно) хотя бы в одном из
конструкторов. После того, как отработают конструкторы всех
родительских классов, будет продолжено выполнение каждого конструктора,
вовлеченного в процесс создания объекта. </p>
            <div  class="example"><pre>
public class Test { 
   public Test() { 
      System.out.println("Test()");
   }

   public Test(int x) { 
      this(); 
      System.out.println("Test(int x)"); 
   }
} 
</pre></div>
            <p >
После выполнения выражения <span class="texample">new Test(0)</span> на консоли появится: 
</p>
            <div  class="example"><pre>
Test()
Test(int x) 
</pre></div>
            <p >
В заключение рассмотрим применение модификаторов доступа для
конструкторов. Может вызвать удивление возможность объявлять
конструкторы как <span class="texample">private</span>. Ведь они нужны для генерации объектов, а к таким конструкторам ни у кого не будет доступа. Однако в ряде случаев модификатор <span class="texample">private</span> может быть полезен. Например: 
</p>
            <ul >
                <li>
                    <span class="texample">private</span>-конструктор может содержать инициализирующие действия, 
а остальные конструкторы будут использовать его с помощью <span class="texample">this</span>, 
причем прямое обращение к этому конструктору по каким-то причинам 
нежелательно;</li>
                <li>запрет на создание объектов этого класса, например, невозможно создать 
экземпляр класса <span class="texample">Math</span>;</li>
                <li>реализация специального шаблона проектирования из ООП
Singleton, для работы которого требуется контролировать создание
объектов, что невозможно в случае наличия не-<span class="texample">private</span> конструкторов.</li>
            </ul>
        
        <h4 >Инициализаторы</h4>
            
            <p >
Наконец, последней допустимой конструкцией в теле класса является
объявление <span class="keyword">инициализаторов</span>. Записываются объектные <span class="keyword">инициализаторы</span> очень
просто – внутри фигурных скобок. </p>
            <div  class="example"><pre>
public class Test {
   private int x, y, z;

   // инициализатор объекта
   {
      x=3;
      if (x&gt;0)
         y=4;
      z=Math.max(x, y);
   }
} 
</pre></div>
            <p >
                <span class="keyword">Инициализаторы</span> не имеют имен, исполняются при создании объектов, не
могут быть вызваны явно, не передаются по наследству (хотя, конечно,
<span class="keyword">инициализаторы</span> в родительском классе продолжают исполняться при
создании объекта класса-наследника). </p>
            <p >
Было указано уже три вида инициализирующего кода в классах –
конструкторы, <span class="keyword">инициализаторы</span> переменных, а теперь добавились объектные
<span class="keyword">инициализаторы</span>. Необходимо разобраться, в какой последовательности что
выполняется, в том числе при наследовании. При создании экземпляра
класса вызванный конструктор выполняется следующим образом: </p>
            <ul >
                <li>если первой строкой идет обращение к конструктору родительского
класса (явное или добавленное компилятором по умолчанию), то этот
конструктор исполняется;</li>
                <li>в случае успешного исполнения вызываются все <span class="keyword">инициализаторы</span> полей 
и объекта в том порядке, в каком они объявлены в теле класса;</li>
                <li>если первой строкой идет обращение к другому конструктору
этого же класса, то он вызывается. Повторное выполнение <span class="keyword">инициализаторов</span>
не производится.</li>
            </ul>
            <p >
Второй пункт имеет ряд важных следствий. Во-первых, из него следует,
что в <span class="keyword">инициализаторах</span> нельзя использовать переменные класса, если их
объявление записано позже. </p>
            <p >
Во-вторых, теперь можно сформулировать наиболее гибкий подход к инициализации <span class="texample">final</span>-полей.
Главное требование – чтобы такие поля были проинициализированы ровно
один раз. Это можно обеспечить в следующих случаях: </p>
            <ul >
                <li>если инициализировать поле при объявлении;</li>
                <li>если инициализировать поле только один раз в <span class="keyword">инициализаторе</span> объекта 
(он должен быть записан после объявления поля); </li>
                <li>если инициализировать поле только один раз в каждом
конструкторе, в первой строке которого стоит явное или неявное
обращение к конструктору родителя. Конструктор, в первой строке
которого стоит <span class="texample">this</span>, не может и не должен 
инициализировать <span class="texample">final</span>-поле, так как цепочка <span class="texample">this</span>-вызовов 
приведет к конструктору с <span class="texample">super</span>, в котором эта инициализация 
обязательно присутствует.</li>
            </ul>
            <p >
Для иллюстрации порядка исполнения инициализирующих конструкций рассмотрим следующий пример: 
</p>
            <div  class="example"><pre>
public class Test {
   {
      System.out.println("initializer");
   }
   int x, y=getY();
   final int z;
   {
      System.out.println("initializer2");
   }
   private int getY() {
      System.out.println("getY() "+z);
      return z;
   }
   public Test() {
      System.out.println("Test()");
      z=3;
   }
   public Test(int x) {
      this();
      System.out.println("Test(int)");
      // z=4; - нельзя! final-поле уже 
      // было инициализировано
   }
} 
</pre></div>
            <p >
После выполнения выражения <span class="texample">new Test()</span> на консоли появится: 
</p>
            <div  class="example"><pre>
initializer
getY() 0
initializer2
Test() 
</pre></div>
            <p >
Обратите внимание, что для инициализации поля y вызывается <span class="keyword">метод</span>
                <span class="texample">getY()</span>, который возвращает значение <span class="texample">final</span>-поля <span class="texample">z</span>, которое еще не было инициализировано. Поэтому в итоге поле y получит значение по умолчанию <span class="texample">0</span>, а затем поле <span class="texample">z</span> получит постоянное значение <span class="texample">3</span>, которое никогда уже не изменится. 
</p>
            <p >
После выполнения выражения <span class="texample">new Test(3)</span> на консоли появится: 
</p>
            <div  class="example"><pre>
initializer
getY() 0
initializer2
Test()
Test(int) 
</pre></div>
        


    
	</td>		
	</tr>
	<tr><td height="8" colspan=2><img src="../../../img/empty.gif" width="1" height="8"></td></tr>

	<tr><td height="8" colspan=2><img src="../../../img/empty.gif" width="1" height="8"></td></tr>
	<tr><td colspan=2 align="center">

<a href="4.html" class="attention">Перейти к следующей странице &raquo;</b></a>

	</td></tr>
	<tr><td height="16" colspan=2><img src="../../../img/empty.gif" width="1" height="16"></td></tr>

<tr><td align="center" class="orang_light" colspan="2">
&nbsp;
<font class="rtxt">Если Вы заметили ошибку на этой странице - <a class="llecture_red" target="_blank" href="http://www.intuit.ru/help/askform.xhtml?course=57&url=http://www.intuit.ru/department/pl/javapl/6/3.html">сообщите нам.</a></font>
&nbsp;
</td></tr>

	<tr><td height="2" colspan=2><img src="../../../img/empty.gif" width="1" height="2"></td></tr>
<tr>

<td align=left><font class="rtitle">Страницы:</font>
<a class="rtitle" href="2.html">&laquo;</a> <font class="stitle">|</font>


<a class="rtitle" href="1.html">1</a>
<font class="stitle">|</font>


<a class="rtitle" href="2.html">2</a>
<font class="stitle">|</font>

<font class="rtitle">3</font>

<font class="stitle">|</font>


<a class="rtitle" href="4.html">4</a>
<font class="stitle">|</font>


<a class="rtitle" href="http://www.intuit.ru/department/pl/javapl/6/test/">вопросы</a> <font class="stitle">|</font> 
<a class="rtitle" href="4.html"><b>&raquo;</b></a>
</td>
<td align=right><font class="stitle">|</font>
<a href="http://www.intuit.ru/department/pl/javapl/6/javapl_6.html" class="rtitle" target="_blank">HTML для печати</a>




</td>

</tr>

	<tr><td height="8" colspan=2><img src="../../../img/empty.gif" width="1" height="8"></td></tr>
	<tr><td class="orang" height="1" colspan=2><img src="../../../img/empty.gif" width="1" height="1"></td></tr>
	</table>
	<!-- /content -->

</td>
<td width="6"><img src="../../../img/empty.gif" width="6"></td>
<td width="1" class="gray"><img src="../../../img/empty.gif"></td>
<td width="6"><img src="../../../img/empty.gif" width="6"></td>
<td width="180">
	<!-- rightcolumn -->
	<table border="0" cellpadding="2" cellspacing="0" background="" width="100%">
	<!---->


<!--Основные понятия-->
	<td class="bordo" height="24">&nbsp;&nbsp;Ключевые слова</td>
	</tr>
	<tr>
	<td><span class="rtxt"><span  class="keyword_list">заголовок метода</span>, <span  class="keyword_list">инициализатор</span>, <span  class="keyword_list">метод</span>, <span  class="keyword_list">сигнатура</span>, <span  class="keyword_list">тело метода</span><br ><br ><a  class="allnews" href="../keywords.html">все ключевые слова »</a>
</td>
	</tr>
	<tr><td>&nbsp;</td></tr>
<!--/Основные понятия-->

		<tr><td class="bordo" height="24">&nbsp;&nbsp;Информация о лекции</td></tr>
	<tr>
	<td>
<span class="rtxt">Центральная тема лекции – объявление классов, поскольку любое Java-приложение является набором классов.<br>
Первый рассматриваемый вопрос – система разграничения доступа в Java. Описывается, зачем вообще нужно управление доступом в ОО-языке программирования и как оно осуществляется в Java. Затем подробно рассматривается структура объявления заголовка класса и его тела, которое состоит из элементов (полей и методов), конструкторов и инициализаторов. Дополнительно описывается сигнатура метода main, с которого начинается работа Java-приложения, правила передачи параметров различных типов в методы, перегруженные методы.

	</td>
	</tr>
	<tr><td>&nbsp;</td></tr>

	

	
	<td class="bordo" height="24">&nbsp;&nbsp;Учебники к курсу</td>
	</tr>
	<tr>
<td>

		<table border="0" cellpadding="0" cellspacing="0">


		<tr valign="top">
		<td>

<table border="0" cellpadding="1" cellspacing="0"  align="left" hspace="5" vspace="2"><tr><td class="orang"><table border="0" cellpadding="2" cellspacing="0" bgcolor="#ffffff"><tr><td valign="middle" align="center"><a href="http://www.intuit.ru/shop/catalog/product.xhtml?id=2459325"><img width="72" height="105" src="../../../img/covers/i/in/int/intu006.jpg" alt="Программирование на Java" border="0"></a></td></tr></table></td></tr></table>

<a href="http://www.intuit.ru/shop/catalog/product.xhtml?id=2459325" class="spectitle">
Программирование на Java</a>
<br>
<font class="spectxt">
Вязовик Н.А.,
<br>
Интернет-университет информационных технологий - ИНТУИТ.ру.
<br>
Курс лекций посвящен современному и мощному языку программирования Java. В его рамках дается вводное изложение принципов ООП, необходимое для разработки на Java, основы языка, библиотеки для работы с файлами, сетью, для построения оконного интерфейса пользователя (GUI) и др.

</font>
		</td>
		</tr>

		</table>

</td>
	</tr>


	<tr><td height="10"><img src="../../../img/empty.gif" width="1" height="10"></td></tr>



	<tr>
<td>
		<table border="0" cellpadding="0" cellspacing="0">


		<tr valign="top">
		<td class="spectxt">
<span class="spectitle"><a href="http://www.intuit.ru/shop/catalog/product.xhtml?id=1412049" class="spectitle">Приемы объектно-ориентированного проектирования. Паттерны проектирования</a></span>
<br>
Гамма Э. и др.,
Питер.
		</td>
		</tr>


		</table>

</td>
	</tr>


<tr>
<td><a href="http://www.intuit.ru/cgi-bin/goto.fcgi?mode=books_of_course&cid=57" class="allnews">все книги по курсу &raquo;</a></td>
</tr>



	</table>
	<!-- /rightcolumn -->
</td>
<td width="6"><img src="../../../img/empty.gif" width="6"></td>
</tr>
</table>

<!-- /bottom -->
<table border="0" cellpadding="0" cellspacing="6" width="100%" height="73">
<tr>
<td align="center" class="menu">
    <table border="0" cellpadding="0" cellspacing="0" background="">
    <tr>
    <td class="copy">
    <a href="http://www.intuit.ru/all_departments.html" class="bot">Кафедры</a> |
    <a href="http://www.intuit.ru/all_courses.html" class="bot">Все курсы</a> |
    <a href="http://www.intuit.ru/syllabus.html" class="bot">Расписание</a> |
    <a href="http://www.intuit.ru/shop/catalog/index.html?" class="bot">Учебники</a> | 
    <a href="http://www.intuit.ru/news.html" class="bot">Новости</a> | 
    <a href="http://www.intuit.ru/department/forum/" class="bot">Форум</a>
    <br>
    <a href="http://www.intuit.ru/user/classes/" class="bot">Мои курсы</a> | 
    <a href="http://www.intuit.ru/user/adjustments/" class="bot">Личные настройки</a> | 
    <a href="http://www.intuit.ru/user/cart/" class="bot">Корзина</a> | 
    <a href="http://www.intuit.ru/help/" class="bot">Помощь</a><br><br>
    Телефон: (095) 253-9312, 253-9313, факс: (095) 253-9310, email: <a href="http://www.intuit.ru/help/askform.xhtml" class="bot">info@intuit.ru</a><br>
    Адрес: 123056 Москва, Электрический пер., 8, стр. 3<br>
    &copy; 2003-2004 INTUIT.ru. Все права защищены.
    </td>
    </tr>
    </table>
</td>
</tr>
</table>
<!-- /bottom -->


</body>
</html>
