<!-- by.ru advertising -->
<script language="JavaScript" src="/-/adover/upper.js"></script>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:04/24/2000
Translation Time:06:35:42
Translation Platform:Win32
Number of Output files:23
This File:Chapter02.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html; charset=windows-1251">
<TITLE>2: Everything is an Object</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF">
<DIV ALIGN="CENTER"> <a href="http://www.MindView.net"> </a> 
  <CENTER>
    <FONT FACE="Verdana" size = "-1"> </FONT> 
    <H2><FONT FACE="Verdana">
  Thinking in Java, 2nd edition, Revision 11</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1"> [ <a href="Chapter01.html">Предыдущая глава</a> 
    ] [ <a href="SimpleContents.html">Содержание</a> ] [ <a href="Contents.html">Оглавление</a> 
    ] [ <a href="DocIndex.html">Индекс</a> ] [ <a href="Chapter03.html">Следующая 
    глава </a> ] </FONT> 
  </CENTER>
  <p></P></DIV>
<FONT FACE = "Verdana">
<H1 ALIGN="LEFT"> 2: Все есть объекты</H1>
</FONT> 
<P><FONT FACE="Georgia" SIZE=4>Хотя он основывается на C++, Java более &#8220;чистый&#8221; 
  объектно-ориентированный язык.</FONT></P>
<P><FONT FACE="Georgia">И C++ и Java гибридные языки, но разработчики Java почувствовали, 
  что гибридизация не так важна, как в случае C++. Гибридные языки позволяют различные 
  стили программирования; причина гибридизации C++ в обратной совместимости с 
  языком C. Поэтому C++ является расширением языка C, он включает много нежелательных 
  особенностей этого языка, которые могут сделать некоторые аспекты C++ чрезмерно 
  запутанными.</FONT></P>
<P><FONT FACE="Georgia"> Язык Java предполагает, что вы хотите заниматься только 
  объектно-ориентированным программированием. Это значит, что прежде чем вы сможете 
  начать, вы должны продвинуть свой разум в объектно-ориентированный мир (если 
  вы еще не там). Польза от этого начального достижения - это способность программировать 
  на языке, который проще для изучения и использования, чем многие другие ООП 
  языки. В этой главе вы увидите основные компоненты Java программы, и мы выучим, 
  что все в Java - это объекты, даже Java программа.</FONT></P>
<A NAME="Heading86"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Вы управляете объектами через ссылки</H2>
</FONT> 
<P><FONT FACE="Georgia">Каждый язык программирования вкладывает совой собственный 
  смысл в управление данными. Иногда программисты должны постоянно осознавать, 
  какого типа управление происходит. Управляете ли вы объектом напрямую, или вы 
  имеете дело с определенного рода непрямым представлением (указатель в C и C++), 
  которое должно трактоваться в специальном синтаксисе?</FONT></P>
<P><FONT FACE="Georgia">Все это упрощено в Java. Вы трактуете все как объекты, 
  так что здесь однородный синтаксис, который вы используете везде. Хотя вы <i>трактуете</i> 
  все, как объекты, идентификатор, которым вы манипулируете, на самом деле является 
  &#8220;ссылкой&#8221; на объект</FONT> <a href="#fn20">[20]</a><FONT FACE="Georgia">. 
  Вы можете вообразить эту сцену, как телевизор (объект) с вашим пультом дистанционного 
  управление (ссылка). Столько, сколько вы держите эту ссылку, вы имеете связь 
  с телевизором, но когда что-то говорит: &#8220;измените канал&#8221; или &#8220;уменьшите 
  звук&#8221;, то, чем вы манипулируете, это ссылка, которая производит модификацию 
  объекта. Если вы хотите ходить по комнате и все равно хотите управлять телевизором, 
  вы берете пульт/ссылку с собой, но не телевизор.</FONT></P>
<P><FONT FACE="Georgia">Также пульт дистанционного управления может остаться без 
  телевизора. Таким образом, если вы просто имеете ссылку, это не значит, что 
  она связана с объектом. Так, если вы хотите иметь слово или предложение, вы 
  создаете ссылку <B>String</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>String s;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Но здесь вы создаете <i>только</i> ссылку, а не объект. 
  Если вы решите послать сообщение для <b>s</b> в этом месте, то вы получите ошибку 
  (времени выполнения), потому что <b>s</b> ни к чему не присоединено (здесь нет 
  телевизора). Безопасная практика, поэтому, всегда инициализировать ссылку, когда 
  вы создаете ее:</FONT> </P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>String s = <font color=#004488>"asdf"</font>;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Однако здесь использована специальная особенность Java: 
  строки могут быть инициализированы текстом в кавычках. Обычно, вы должны использовать 
  более общий тип инициализации для объектов.</FONT></P>
<A NAME="Heading87"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Вы должны создавать все объекты</H2>
</FONT>
<P><FONT FACE="Georgia">Когда вы создаете ссылку, вы хотите соединить ее с новым 
  объектом. Вы делаете это, в общем случае, с помощью ключевого слова <B>new</B>. 
  <B>new</B> говорит: &#8220;Создать один новый экземпляр этого объекта&#8221;. 
  В приведенном выше примере вы можете сказать:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>String s = <font color=#0000ff>new</font> String(<font color=#004488>"asdf"</font>);</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это значит не только &#8220;Создать мне новый <B>String</B>&#8221;, 
  но это также дает информацию о том, <i>как</i> создать <B>String</B>, указывая 
  инициализирующую строку.</FONT></P>
<P><FONT FACE="Georgia">Конечно, <B>String</B> - это не только существующий тип. 
  Java пришла с полноценными готовыми типами. Что более важно, так это то, что 
  вы можете создать свои собственные типы. Фактически, это основной род деятельность 
  при программировании на Java, и это то, что вы будите учиться делать в оставшейся 
  части книги.</FONT></P>
<A NAME="Heading88"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Где живет хранилище</H3>
</FONT> 
<P><FONT FACE="Georgia">Полезно показать некоторые аспекты тог, как размещаются 
  вещи во время работы программы, особенно, как распределяется память. Есть шесть 
  разных вещей для хранения данных:</FONT></P>
<OL>
  <LI><FONT FACE="Verdana"><B>Регистры</B></FONT><FONT FACE="Georgia"><B></B>. 
    Это самое быстрое хранилище, потому что оно существует в месте, отличном от 
    других хранилищ: внутри процессора. Однако число регистров сильно ограничено, 
    так что регистры резервируются компилятором в соответствии с его требованиями. 
    Вы не имеете прямого контроля, и при этом вы не видите никакого свидетельства 
    в вашей программе, что регистры вообще существуют.</FONT> 
  <LI><FONT FACE="Verdana"><B>Стек</B></FONT><FONT FACE="Georgia">. Он расположен 
    в области обычной RAM (память произвольного доступа - random-access memory), 
    но имеет прямую поддержку процессора через <i>указатель стека</i>. Указатель 
    стека перемещается вниз при создании новой памяти, и перемещается вверх при 
    освобождении памяти. Это чрезвычайно быстрый и эффективный способ для выделения 
    хранилища, второй после регистров. Компилятор Java должен знать во время создания 
    программы точный размер и продолжительность жизни всех данных, которые хранятся 
    в стеке, потому что он должен генерировать код для перемещения указателя стека 
    вверх и вниз. Это ограничение сказывается на гибкости ваших программ, так 
    что пока хранилище Java существует в стеке &#8212; обычно, для ссылок на объекты 
    &#8212; объекты Java не помещаются в стек.</FONT> 
  <LI><FONT FACE="Verdana"><B>Куча</B></FONT><FONT FACE="Georgia">. Это пул памяти 
    общего назначения (также в области RAM), где живут объекты Java. Главная прелесть 
    кучи, в отличие от стека, в том, что компилятору нет необходимости знать, 
    как много места необходимо выделить из кучи для хранилища или как долго это 
    хранилище будет оставаться в куче. Поэтому, большой плюс для гибкости при 
    создании хранилища в куче. Когда бы вам ни понадобилось создавать объект, 
    вы просто пишите код для его создания, используя <b>new</b>, а когда такой 
    код выполняется, хранилище выделяется в куче. Конечно, вы платите за эту гибкость: 
    это занимает больше времени при выделении хранилища в куче, чем при выделении 
    хранилища в стеке (если бы вы могли создать объект в стеке в Java, как вы 
    это можете в C++).</FONT> 
  <LI><FONT FACE="Verdana"><B> </B></FONT><FONT FACE="Georgia"><B>Статическое 
    хранилище</B>. &#8220;Статическое&#8221; здесь используется в смысле &#8220;в 
    фиксированном месте&#8221; (хотя это тоже в RAM). Статическое хранилище содержит 
    данные, которые доступны в течение всего времени выполнения программы. Вы 
    можете использовать ключевое слово <B>static</B>, чтобы указать, что определенный 
    элемент объекта - статический, но Java объект никогда не помещается в статическое 
    хранилище.</FONT> 
  <LI><FONT FACE="Verdana"><B>Хранилище констант</B></FONT><FONT FACE="Georgia"><B></B>. 
    Константные значения часто помещаются прямо в код программы, что является 
    безопасным, так как они никогда не могут измениться. Иногда константы огораживают 
    себя так, что они могут быть по выбору помещены в память только для чтения 
    (ROM).</FONT>
  <LI><FONT FACE="Georgia"><B>Не RAM хранилище</B>. Если данные живут полностью 
    вне программы, они могут существовать, пока программа не работает, вне управления 
    программы. Два основных примера - это <i>потоковые объекты</i>, в которых 
    объекты переведены в поток байтов, обычно для посылки на другую машину, и 
    <i>объекты представления</i>, в которых объекты помещаются на диск, так что 
    они сохраняют свое состояние, даже когда программа завершена. Фокус этих типов 
    хранилищ в переводи объектов во что-то, что может существовать на другом носителе, 
    и даже могут быть воскрешены в обычный объект в RAM, когда необходимо. Java 
    обеспечивает поддержку для <i>легковесной живучести</i>, и будущие 
    версии Java могут предлагать более полное решение для живучести.</FONT> 
</OL>
<A NAME="Heading89"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Особый случай: примитивные типы</H3>
</FONT>
<P><FONT FACE="Georgia">Есть группа типов, имеющих особое обращение; вы можете 
  думать о них, как о &#8220;примитивных&#8221; типах, которые вы достаточно часто 
  используете в вашем программировании. Причина специального использования в том, 
  что создание объектов с помощью <b>new</b> &#8212;особенно маленьких, простые 
  переменных &#8212; не очень существенно, поскольку <B>new</B> помещает объекты 
  в кучу. Для этих типов Java возвращается к подходу, принятому в C и C++. Так 
  что, вместо создания переменной с использованием <b>new</b>, &#8220;автоматические&#8221; 
  переменные создаются <i>не по ссылке</i>. Переменная хранит значение, и оно 
  помещается в стек, так как это более эффективно.</FONT></P>
<P><FONT FACE="Georgia">Java определяет размер каждого примитивного типа. Размеры 
  не меняются при переходе от одной архитектуры машины к другой, как это сделано 
  во многих языках. Этот размер инвариантен - это причина того, что программирование 
  на Java так переносимо.</FONT></P>
<div align="center"> 
  <TABLE BORDER>
    <TR VALIGN="TOP"> 
      <TH WIDTH=120 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> 
        <div align="center"><FONT FACE="Georgia">Примитивный тип</FONT></div>
      </TH>
      <TH WIDTH=61 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> 
        <div align="center"><FONT FACE="Georgia"><B>Размер</B></FONT></div>
      </TH>
      <TH WIDTH=76 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> 
        <div align="center"><FONT FACE="Georgia"><B>Минимум</B></FONT></div>
      </TH>
      <TH WIDTH=112 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> 
        <div align="center"><FONT FACE="Georgia"><B>Максимум</B></FONT></div>
      </TH>
      <TH WIDTH=95 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> 
        <div align="center"><FONT FACE="Georgia"><B>Тип оболочки</B></FONT></div>
      </TH>
    </TR>
    <TR VALIGN="TOP"> 
      <TD height="27" width="120"> <FONT FACE="Georgia"><B>boolean</B></FONT></TD>
      <TD height="27" width="61"> <FONT FACE="Georgia">&#8212;</FONT></TD>
      <TD height="27" width="76"> <FONT FACE="Georgia">&#8212;</FONT></TD>
      <TD height="27" width="112"> <FONT FACE="Georgia">&#8212;</FONT></TD>
      <TD height="27" width="95"> <FONT FACE="Georgia"><B>Boolean</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD width="120"> <FONT FACE="Georgia"><B>char</B></FONT></TD>
      <TD width="61"> <FONT FACE="Georgia">16-бит</FONT></TD>
      <TD width="76"> <FONT FACE="Georgia">Unicode 0</FONT> </TD>
      <TD width="112"> <FONT FACE="Georgia">Unicode 2<SUP>16</SUP>- 1</FONT> </TD>
      <TD width="95"> <FONT FACE="Georgia"><B>Character</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD width="120"> <FONT FACE="Georgia"><B>byte</B></FONT></TD>
      <TD width="61"> <FONT FACE="Georgia">8-bit</FONT></TD>
      <TD width="76"> <FONT FACE="Georgia">-128</FONT></TD>
      <TD width="112"> <FONT FACE="Georgia">+127</FONT></TD>
      <TD width="95"> <FONT FACE="Georgia"><B>Byte</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD width="120"> <FONT FACE="Georgia"><B>short</B></FONT></TD>
      <TD width="61"> <FONT FACE="Georgia">16-bit</FONT></TD>
      <TD width="76"> <FONT FACE="Georgia">-2<SUP>15</SUP></FONT></TD>
      <TD width="112"> <FONT FACE="Georgia">+2<SUP>15</SUP> &#8212; 1</FONT></TD>
      <TD width="95"> <B>Short</B></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD width="120"> <FONT FACE="Georgia"><B>int</B></FONT></TD>
      <TD width="61"> <FONT FACE="Georgia">32-bit</FONT></TD>
      <TD width="76"> <FONT FACE="Georgia">-2<SUP>31</SUP></FONT></TD>
      <TD width="112"> <FONT FACE="Georgia">+2<SUP>31</SUP> &#8212; 1</FONT></TD>
      <TD width="95"> <FONT FACE="Georgia"><B>Integer</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD width="120"> <FONT FACE="Georgia"><B>long</B></FONT></TD>
      <TD width="61"> <FONT FACE="Georgia">64-bit</FONT></TD>
      <TD width="76"> <FONT FACE="Georgia">-2<SUP>63</SUP></FONT></TD>
      <TD width="112"> <FONT FACE="Georgia">+2<SUP>63</SUP>&#8212;1</FONT></TD>
      <TD width="95"> <FONT FACE="Georgia"><B>Long</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD width="120"> <FONT FACE="Georgia"><B>float</B></FONT></TD>
      <TD width="61"> <FONT FACE="Georgia">32-bit</FONT></TD>
      <TD width="76"> <FONT FACE="Georgia">IEEE754</FONT></TD>
      <TD width="112"> <FONT FACE="Georgia">IEEE754</FONT></TD>
      <TD width="95"> <FONT FACE="Georgia"><B>Float</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD width="120"> <FONT FACE="Georgia"><B>double</B></FONT></TD>
      <TD width="61"> <FONT FACE="Georgia">64-bit</FONT></TD>
      <TD width="76"><FONT FACE="Georgia">IEEE754</FONT></TD>
      <TD width="112"> <FONT FACE="Georgia">IEEE754</FONT></TD>
      <TD width="95"> <FONT FACE="Georgia"><B>Double</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD width="120"> <FONT FACE="Georgia"><B>void</B></FONT></TD>
      <TD width="61"> <FONT FACE="Georgia">&#8212;</FONT></TD>
      <TD width="76"> <FONT FACE="Georgia">&#8212;</FONT></TD>
      <TD width="112"> <FONT FACE="Georgia">&#8212;</FONT></TD>
      <TD width="95"> <FONT FACE="Georgia"><B>Void</B></FONT></TD>
    </TR>
  </TABLE>
</div>
<P>&nbsp;</P>
<P><FONT FACE="Georgia">Все числовые типы знаковые, так что не ищите беззнаковые 
  типы.</FONT></P>
<P><FONT FACE="Georgia">Размер <B>boolean</B> типов точно не определено; только 
  указано, что они способны принимать литерные значения <B>true</B> или <B>false</B>.</FONT></P>
<P><FONT FACE="Georgia">Примитивные типы данных также имеют классы &#8220;оболочки&#8221; 
  <I> </I>для них. Это означает, что если вы хотите создать не примитивный объект 
  в куче для представления примитивного типа, вы используете ассоциированную оболочку. 
  Например:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>char</font> c = 'x';
Character C = <font color=#0000ff>new</font> Character(c);</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Или вы также моги использовать:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Character C = <font color=#0000ff>new</font> Character('x');</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Обоснования для этого действия будет дано в последующих 
  главах.</FONT></P>
<A NAME="Heading90"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Числа высокой точности</H4>
</FONT><DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Java включает два класса для работы с высокоточной арифметикой: 
    <B>BigInteger</B> и <B>BigDecimal</B>. Хотя они приблизительно попадают в 
    ту же категорию, что и классы &#8220;оболочки&#8221;, ни один из них не имеет 
    примитивного аналога.</FONT></P>
</DIV>
<P><FONT FACE="Georgia">Оба класса имеют методы, обеспечивающие аналогичные операции, 
  которые вы выполняете для примитивных типов. Так что с классами <B>BigInteger</B> 
  или <B>BigDecimal </B>вы можете делать все, что вы можете делать с <B>int</B> 
  или <B>float</B>, только вы должны использовать вызов методов вместо операторов. 
  Также, так как это более закручено, операции выполняются медленнее. Вы меняете 
  скорость на точность.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia"><B>BigInteger</B> поддерживают целые числа произвольной 
    точности. Это означает, что вы можете точно представить значение целого числа 
    любого размера без потерь любой информации во время операций.</FONT></P>
</DIV>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia"><B>BigDecimal</B> для чисел с фиксированной точкой произвольной 
    точности; вы можете использовать это, например, для точных денежных расчетов.</FONT></P>
</DIV>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Обратитесь к вашей онлайн документации, чтобы узнать 
    более детально относительно конструкторов и методов, которые вы можете вызывать 
    для этих двух классов.</FONT></P>
</DIV>
<A NAME="Heading91"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Массивы в Java</H3>
</FONT>
<P><FONT FACE="Georgia">Фактически, все языки программирования поддерживают массивы. 
  Использование массивов в C и C++ рискованно, поскольку эти массивы всего лишь 
  блоки памяти. Если программа обращается к массиву вне пределов этого блока, 
  или использует память до инициализации (общая ошибка программирования), получится 
  непредсказуемый результат.</FONT></P>
<P><FONT FACE="Georgia">Одна из главных целей Java - это безопасность, так что 
  многие проблемы, надоедающие программистам в C и C++, не повторяются в Java. 
  Java массив гарантированно инициализируется и нельзя получить доступ вне его 
  пределов. Цена такой проверки диапазона - выделение дополнительной памяти к 
  каждому массиву, так же как и за проверку индексов во время выполнения, но предположение, 
  что это безопасно и повышает продуктивность, стоит расходов.</FONT></P>
<P><FONT FACE="Georgia">Когда вы создаете массив объектов, на самом деле вы создаете 
  массив ссылок, а каждая из этих ссылок автоматически инициализируется специальным 
  значением, имеющим собственное ключевое слово: <B>null</B>. Когда Java видит 
  <B>null</B>, он распознает, что опрашиваемая ссылка не указывает на объект. 
  Вы должны присвоить объект каждой ссылке, прежде чем использовать ее, и, если 
  вы попробуете использовать ссылку, которая все еще <b>null</b>, о проблемах 
  вы узнаете во время выполнения. Таким образом, типичные ошибки при работе с 
  массивами предотвращены в Java.</FONT></P>
<P><FONT FACE="Georgia">Вы также можете создать массив примитивов. Опять компилятор 
  гарантирует инициализацию, поскольку он заполняет нулями память для этого массива.</FONT></P>
<P><FONT FACE="Georgia">Массивы более подробно будут рассмотрены в следующих главах.</FONT></P>
<A NAME="Heading92"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Вам никогда не нужно уничтожать объекты</H2>
</FONT>
<P><FONT FACE="Georgia">В большинстве языков программирования концепция времени 
  жизни переменной занимает значительную часть усилий при программировании. Как 
  долго переменная должна сохранятся? Если вы намереваетесь разрушить ее, кода 
  вы должны сделать это? Путаница со временем жизни переменных может стать причиной 
  многих ошибок, а этот раздел показывает, как Java сильно упрощает проблему, 
  делая всю работу по очистке за вас.</FONT></P>
<A NAME="Heading93"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Ограничивание</H3>
</FONT>
<P><FONT FACE="Georgia">Большинство процедурных языков имеют концепцию <i>границ</i>. 
  Они определяют и видимость, и время жизни имен, определенных в таких границах. 
  В C, C++ и Java границы определяются расстановкой фигурных скобок <B>{}</B>. 
  Так, например:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE>{
  <font color=#0000ff>int</font> x = 12;
  <font color=#009900>/* доступно только  x */</font>
  {
    <font color=#0000ff>int</font> q = 96;
    <font color=#009900>/* доступны и x, и q */</font>
  }
  <font color=#009900>/* Доступно только x */</font>
  <font color=#009900>/* q &#8220;за границами&#8221; */</font>
}</PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Переменная, определенная внутри границ доступна только 
  до конца этой границы.</FONT></P>
<P><FONT FACE="Georgia">Выравнивание делает Java код легким для чтения. Так как 
  Java - это язык свободной формы, дополнительные пробелы, табуляции и возврат 
  каретки не влияют на результат программы.</FONT></P>
<P><FONT FACE="Georgia">Обратите внимание, что в не можете сделать следующее, 
  хотя это разрешено в С и C ++:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE>{
  <font color=#0000ff>int</font> x = 12;
  {
    <font color=#0000ff>int</font> x = 96; <font color=#009900>/* недопустимо */</font>
  }
}</PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Компилятор объявит, что переменная <b>x</b> уже определена. 
  Таким образом, C и C++ способны &#8220;прятать&#8221; переменные в больших границах, 
  что не позволяется в Java, поскольку разработчики подумали, что это будет запутывать 
  программы.</FONT></P>
<A NAME="Heading94"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Границы объектов</H3>
</FONT>
<P><FONT FACE="Georgia">Java объекты не имеют то же самое время жизни, что и примитивы. 
  Когда вы создаете Java объект, используя <b>new</b>, он продолжает существовать 
  после конца границы. Таки образом, если вы используете:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE>{
  String s = <font color=#0000ff>new</font> String(<font color=#004488>"a string"</font>);
} <font color=#009900>/* конец блока */</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">ссылка <B>s</B> исчезает по окончании границы. Однако 
  объект <B>String</B>, на который указывал <B>s</B>, продолжает занимать память. 
  В этом кусочке кода нет способа получить доступ к объекту, поскольку есть ссылка 
  на него только внутри границ. В следующих главах вы увидите, как ссылка на объект 
  может быть передана и размножена по ходу программы.</FONT></P>
<P><FONT FACE="Georgia">Оказывается, потому что объекты создаются с помощью <B>new</B>, 
  они остаются столько, сколько вы этого хотите, что создавало в C++ проблемы 
  при программировании, и что просто исчезло в Java. Сложнейшие проблемы случаются 
  в C++ потому, что вы не получаете никакой помощи от языка, чтобы убедится, что 
  объект доступен, когда он нужен. И, что более важно, в C++ вы должны убеждаться, 
  что вы уничтожили объект, когда вы закончили работать с ним.</FONT></P>
<P><FONT FACE="Georgia">Это выявляет интересный вопрос. Если Java оставляет объекты 
  лежать вокруг, что предохраняет от переполнения памяти и остановки вашей программы? 
  Этот вид проблемы точно случается в C++. Здесь происходит немного магии. Java 
  имеет <i>сборщик мусора</i>, который смотрит на все объекты, которые были созданы 
  с помощью <b>new</b>, и решает, на какие из них больше нигде нет ссылок. Затем 
  он освобождает память этого объекта, так что память может использоваться для 
  новых объектов. Это означает, что вам нет необходимости самостоятельно заботится 
  об утилизации памяти. Вы просто создаете объекты и, когда он вам больше не нужен, 
  он сам исчезнет. Это подавляет определенных класс проблем программирования: 
  так называемую &#8220;утечку памяти&#8221;, при которой программисты забывают 
  освободить память.</FONT></P>
<A NAME="Heading95"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Создание новых типов данных: классов</H2>
</FONT>
<P><FONT FACE="Georgia">Если все - это объекты, что определяет, как выглядит и 
  ведет себя объект определенного класса? Или, другими словами, что основывает 
  <i>тип</i> объекта? Вы можете ожидать здесь ключевого слова &#8220;type&#8221;, 
  и, конечно, это бы имело смысл. Однако исторически сложилось, что большинство 
  объектно-ориентированных языков используют ключевое слово <B>class</B>, которое 
  означает: &#8220;Я говорю тебе, как выглядит новый тип объекта&#8221;. За ключевым 
  словом <B>class</B> (которое является настолько общим, что оно не будет поощряться 
  в этой книге) следует имя нового типа. Например:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#0000ff>class</font> ATypeName { <font color=#009900>/* Здесь помещается тело класса */</font> }</PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это вводит новый тип, так что вы можете теперь создавать 
  объекты этого типа, используя <B>new</B>:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>ATypeName a = <font color=#0000ff>new</font> ATypeName();</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Тело класса <B>ATypeName</B> содержит только комментарий 
  (звездочки и слеши, и то, что между ними, это все будет обсуждаться позже в 
  этой главе), так что здесь не достаточно много того, с чем вы могли бы работать. 
  Фактически, вы не можете сказать объекту делать что-нибудь (то есть, вы не можете 
  посылать ему любые интересные сообщения), пока вы не определите некоторые методы 
  класса.</FONT></P>
<FONT FACE = "Verdana">
<H3 ALIGN="LEFT"><A NAME="Heading96"></A>Поля и методы</H3>
</FONT>
<P><FONT FACE="Georgia">Когда вы определяете класс (а все, что вы делаете в Java 
  - это определение классов, создание объектов этих классов и посылка сообщений 
  этим объектам), вы можете поместить два типа элементов в ваш класс? Члены-данные 
  (иногда называемые <i>полями</i>) и члены-функции (обычно называемые <i>методами</i>). 
  Члены-данные - это объекты любого типа, с которыми вы можете взаимодействовать 
  через ссылку. Они также могут быть примитивными типами (которые не являются 
  ссылками). Если это ссылка на объект, вы должны инициализировать эту ссылку, 
  присоединив ее к реальному объекту (используя <b>new</b>, </FONT><FONT FACE="Georgia">как 
  показано ранее), в специальной функции, называемой конструктором (полностью 
  описано в Главе 4). Если это примитивный тип, вы можете инициализировать его 
  напрямую в точке определения в классе. (Как вы увидите позже, ссылки также могут 
  быть инициализированы в месте определения.)</FONT></P>
<P><FONT FACE="Georgia">Каждый объект держит свое собственное место для своих 
  членов-данных; члены-данные не делятся между объектами. Здесь приведен пример 
  класса с какими-то членами-данными:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> DataOnly {
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>boolean</font> b;
}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это класс <i>не делает</i> ничего, но вы можете создать 
  объект:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>DataOnly d = <font color=#0000ff>new</font> DataOnly();</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете присвоить значение члену-данному, но вы сначала 
  должны узнать, как обратиться к члену объекта. Это совершается, начиная с имени 
  ссылки объекта, далее следует разделитель (точка), далее следует имя члена внутри 
  объекта:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>objectReference.member</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Например:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>d.i = 47;
d.f = 1.1f;
d.b = <font color=#0000ff>false</font>;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Также возможно, чтобы ваш объект содержал другой объект, 
  который содержит данные, которые вы хотите модифицировать. Для этого вы используете 
  &#8220;соединяющие точки&#8221;. Например:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>myPlane.leftTank.capacity = 100;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Класс <B>DataOnly </B>не может делать ничего, кроме хранения 
  данных, потому что он не имеет членов-функций (методов). Чтобы понят как это 
  работает, вы должны сначала понять, что такое <i>аргумент </i>и <i>возвращаемое 
  значение</i>, которое будет коротко описано.</FONT></P>
<A NAME="Heading97"></A><FONT FACE = "Verdana">
<H4 ALIGN="LEFT"> Значения по умолчанию примитивных членов</H4>
</FONT>
<P><FONT FACE="Georgia">Когда примитивные типы данных являются членами класса, 
  они гарантировано получают значения по умолчанию, если вы их не инициализировали:</FONT><BR>
</P>
<DIV ALIGN="CENTER">
  <TABLE BORDER>
    <TR VALIGN="TOP"> 
      <TH WIDTH=100 COLSPAN=1 ROWSPAN=1 VALIGN="TOP"> <FONT FACE="Georgia">Тип 
        примитива </FONT></TH>
      <TH WIDTH=106 COLSPAN=1 ROWSPAN=1 VALIGN="middle"> <FONT FACE="Georgia"><B>Умолчание 
        </B></FONT></TH>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>boolean</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>false</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>char</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>&#8216;\u0000&#8217; (null)</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>byte</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>(byte)0</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>short</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>(short)0</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>int</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>0</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>long</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>0L</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>float</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>0.0f</B></FONT></TD>
    </TR>
    <TR VALIGN="TOP"> 
      <TD> <FONT FACE="Georgia"><B>double</B></FONT></TD>
      <TD> <FONT FACE="Georgia"><B>0.0d</B></FONT></TD>
    </TR>
  </TABLE>
  <p></P></DIV>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Обратите внимание, что значение по умолчанию Java гарантирует 
    тогда, когда переменная используется как член класса. Это означает, что переменные-члены 
    примитивных типов всегда будут инициализированы (кое-что C++ не делает), что 
    подавляет источник ошибок. Однако это начальное значение может быть не корректным 
    или разрешенным для написанных вами программ. Так что лучше всегда явно инициализировать 
    ваши переменные.</FONT></P>
</DIV>
<P><FONT FACE="Georgia">Эта гарантия не применяется к &#8220;локальным&#8221; 
  переменным, которые не являются полями класса. Так что, если в пределах определения 
  функции вы имеете:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> x;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Затем <B>x</B> получит произвольное значение (как и в 
  C, и в C++); она не будет автоматически инициализирована нулем. Вы несете ответственность 
  за присвоение и соответствие значения прежде, чем вы будете использовать <B>x</B>. 
  Если вы забудете, Java определенно лучше C++: вы получите ошибку времени компиляции, 
  которая скажет вам, что переменная возможно не инициализирована. (Многие C++ 
  компиляторы предупредят вас об отсутствии инициализации переменной, но в Java 
  - это ошибка.)</FONT></P>
<A NAME="Heading98"></A><FONT FACE = "Verdana"> 
<H2 ALIGN="LEFT"> Методы, аргументы и<br>
  возвращаемое значение</H2>
</FONT>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">До этих пор термин <i>функция</i> использовался для 
    описания поименованной процедуры. Термин, наиболее часто используемый в Java, 
    это <i>метод</i>, как &#8220;способ что-то сделать&#8221;. Если вы хотите, 
    вы можете продолжать думать в терминах функций. На самом деле, это только 
    семантическое различие, но далее в этой книге будет использоваться &#8220;метод&#8221;, 
    а не &#8220;функция&#8221;.</FONT></P>
</DIV>
<P><FONT FACE="Georgia">Методы в Java определяют сообщения, которые объекты могут 
  принимать. В этом разделе вы выучите как просто определить метод.</FONT></P>
<P><FONT FACE="Georgia">Фундаментальные части метода - это его имя, аргументы, 
  возвращаемое значение и тело. Посмотрите на основную форму:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE>returnType methodName( <font color=#009900>/* список аргументов */</font> ) {
  <font color=#009900>/* Тело метода */</font>
}</PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Возвращаемый тип - это тип значения, которое помещается 
  в память из метода после его вызова. Список аргументов дает типы и имена, чтобы 
  проинформировать вас, что вы должны передать в этот метод. Имя метода и список 
  аргументов вместе уникально идентифицируют метод.</FONT></P>
<P><FONT FACE="Georgia">Методы в Java могут создаваться только как часть класса. 
  Метод может быть вызван только для объекта, </FONT><a href="#fn21">[21]</a><FONT FACE="Georgia"> 
  а этот объект должен быть способен выполнить этот вызов метода. Если вы попытаетесь 
  вызвать неправильный метод для объекта, вы получите сообщение об ошибке во время 
  компиляции. Вы вызываете метод для объекта по имени объекта, за которым следует 
  разделитель (точка), а далее идет имя метода и список его аргументов, как здесь: 
  <B>objectName.methodName(arg1, arg2, arg3)</B>. Например, предположим, что вы 
  имеете метод <B>f(&#160;)</B> , который не принимает аргументов и возвращает 
  значение типа <B> int</B>. Тогда, если вы имеете объект с именем <B>a</B> для 
  которого может быть вызван <B>f(&#160;)</B> , вы можете сказать:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> x = a.f();</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Тип возвращаемого значения должен быть совместим с типом 
  <B>x</B>.</FONT></P>
<P><FONT FACE="Georgia">Этот вызов метода часто называется <i>посылкой сообщения 
  объекту</i>. В приведенном выше примере сообщение - <B>f(&#160;)</B> , а объект 
  - <B>a</B>. Объектно-ориентированное программирование часто резюмирует, как 
  просто &#8220;посылку сообщения объекту&#8221;.</FONT></P>
<A NAME="Heading99"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Список аргументов</H3>
</FONT>
<P><FONT FACE="Georgia">Список аргументов метода определяет, какую информацию 
  вы передаете в метод. Как вы можете догадаться, это информация &#8212; как и 
  все в Java &#8212; принимает форму объекта. Таким образом, то, что вы должны 
  указать в списке аргументов - это типы объектов для передачи и имена для использования 
  каждого из них. Как и в любой ситуации в Java, где вы кругом видите объекты, 
  на самом деле вы передаете ссылки </FONT><a href="#fn22">[22]</a><FONT FACE="Georgia">. 
  Однако, тип ссылки должен быть правильным. Если аргумент, предположим, <B>String</B>, 
  то, что вы передаете должно быть строкой.</FONT></P>
<P><FONT FACE="Georgia">Относительно метода, который получает <B>String</B> как 
  аргумент. Здесь приведено определение, которое должно быть помещено в определение 
  класса для компиляции:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> storage(String s) {
  <font color=#0000ff>return</font> s.length() * 2;
}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Этот метод говорит вам как много байт требуется для хранения 
  информации в обычном <B>String. </B>(Каждый <B>char </B>в <B>String </B>- это 
  16 бит длины, или два байта, для поддержки символов Unicode.) Аргумент типа 
  <B>String</B> и он называется <B>s</B>. Как только <B>s</B> передается в метод, 
  вы можете трактовать его, как и любой другой объект. (Вы можете посылать ему 
  сообщения.) Здесь вызывается метод <B>length(&#160;)</B>, который является одним 
  из методов для <B>String</B>; он возвращает число символов в строке.</FONT></P>
<P><FONT FACE="Georgia">Вы также можете увидеть использование ключевого слова 
  <B>return</B>, которая делает две вещи. Во-первых, оно означает &#8220;покинуть 
  метод, Я закончил&#8221;. Во-вторых, если метод произвел значение, это значение 
  помещается справа сразу за выражением <B>return</B>. В этом случае, возвращаемое 
  значение производится путем вычисления выражения <B>s.length(&#160;) * 2</B>.</FONT></P>
<P><FONT FACE="Georgia">Вы можете вернуть любой тип, который вы хотите, но если 
  вы не хотите ничего возвращать, вы делаете это, указывая, что метод возвращает 
  <B>void</B>. Здесь несколько примеров:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>boolean</font> flag() { <font color=#0000ff>return</font> <font color=#0000ff>true</font>; }
<font color=#0000ff>float</font> naturalLogBase() { <font color=#0000ff>return</font> 2.718f; }
<font color=#0000ff>void</font> nothing() { <font color=#0000ff>return</font>; }
<font color=#0000ff>void</font> nothing2() {}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Когда возвращаемый тип - <B>void</B>, то ключевое <B>return</B> 
  используется только для выхода из метода, и поэтому необязательно, когда вы 
  достигаете конца метода. </FONT><FONT FACE="Georgia">Вы можете вернуться из 
  метода в любом месте, но если вы имеете возвращаемый тип не <B>void</B>, компилятор 
  заставит вас (с помощью сообщения об ошибке) вернуть значение подходящего типа, 
  не зависимо от того, откуда вы возвращаетесь.</FONT></P>
<P><FONT FACE="Georgia">В этом месте функция может выглядеть как программа, собирающая 
  объекты и методы, которая принимает другие объекты как аргументы и посылает 
  сообщения этим другим объектам. Это, несомненно, многое, из того, что происходит, 
  но в следующих главах вы выучите, как детализируется выполнение работы по созданию 
  результата внутри метода на низком уровне. Для этой главы о посылке сообщения 
  достаточно.</FONT></P>
<A NAME="Heading100"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Построение Java программы</H2>
</FONT>
<P><FONT FACE="Georgia">Есть несколько других проблем, которые вы должны понимать, 
  прежде чем увидите свою первую Java программу.</FONT></P>
<A NAME="Heading101"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Видимость имен</H3>
</FONT>
<P><FONT FACE="Georgia">Проблема каждого языка программирования состоит в управлении 
  именами. Если вы используете имена в одном модуле программы, а другой программист 
  использует эти же имена в другом модуле, как вы отличите одно имя от другого 
  и предохраните два имени от &#8220;конфликта&#8221;? В C это обычная проблема, 
  поэтому программы часто содержат неуправляемое море имен. Классы C++ (на которых 
  основываются классы Java) содержат функции внутри классов, так что они не могут 
  конфликтовать с именами функций, расположенных в других классах. Однако C++ 
  все еще позволяет глобальные данные и глобальные функции, так что конфликт из-за 
  этого все еще возможен. Для решения этой проблемы C++ вводит <i>пространство 
  имен</i>, используя дополнительные ключевые слова.</FONT></P>
<P><FONT FACE="Georgia">Java способен предотвратить все это, выбрав свежий подход. 
  Для производства недвусмысленных имен для библиотеки, используется спецификатор, 
  мало чем отличающийся от доменных имен Internet. Фактически, создатели Java 
  хотят использовать ваши доменные имена Internet в обратном порядке, так как 
  это гарантирует их уникальность. Так как мое доменное имя <B>BruceEckel.com</B>, 
  мои библиотеки утилит foibles будет называться <B>com.bruceeckel.utility.foibles</B>. 
  После того, как вы развернете доменное имя, точки предназначены для представления 
  директорий.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">В Java 1.0 и Java 1.1 доменное расширение <B>com</B>, 
    <B>edu</B>, <B>org</B>, <B>net</B>, и т.д. по соглашению печатаются большими 
    буквами, так что библиотека будет выглядеть: <B>COM.bruceeckel.utility.foibles</B>. 
    Однако, отчасти из-за разработки Java 2, это стало причиной проблемы и теперь 
    все имя пакета пишется маленькими буквами.</FONT></P>
</DIV>
<P><FONT FACE="Georgia">Этот механизм означает, что все ваши файлы автоматически 
  живут в своем собственном пространстве имен, и каждый класс в файле должен иметь 
  уникальный идентификатор. Так что вам нет необходимости учить специальные особенности 
  языка для решения этих проблем &#8212; язык заботится об этом за вас.</FONT></P>
<A NAME="Heading102"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Использование других компонентов</H3>
</FONT>
<P><FONT FACE="Georgia">Когда бы вы ни пожелали использовать предопределенные 
  классы в вашей программе, компилятор должен знать, где они расположены. Конечно, 
  класс может существовать в том же самом файле исходного кода, из которого он 
  вызывается. В этом случае вы просто используете класс &#8212; даже если класс 
  определен дальше по файлу. Java устранит проблему &#8220;ранней ссылки&#8221;, 
  так что вам нет необходимости думать об этом.</FONT></P>
<P><FONT FACE="Georgia">Что можно сказать о классе, который существует в другом 
  файле? Вы можете подумать, что компилятор должен быть достаточно умным, чтобы 
  найти его, но это проблема. Вообразите, что вы хотите использовать класс с определенным 
  именем, но существует более одного определения этого класса (по-видимому, это 
  разные определения). Или хуже, вообразите, что вы написали программу и, когда 
  вы строили ее, вы добавили новый класс в вашу библиотеку, который конфликтует 
  с именем существующего класса.</FONT></P>
<P><FONT FACE="Georgia">Для решения этой проблемы вы должны устранить любую потенциальную 
  двусмысленность. Это выполняется путем точного сообщения компилятору Java классов, 
  которые вы хотите использовать с помощью ключевого слова <B>import</B>. <B>import</B> 
  говорит компилятору о введении <i>пакета</i>, который является библиотекой классов. 
  (В других языках библиотеки могут состоять из функций и данных так же, как и 
  из классов, но помните, что весь код в Java должен быть написан внутри класса.)</FONT></P>
<P><FONT FACE="Georgia">Большую часть времени вы будите использовать компоненты 
  из стандартных библиотек Java, которые идут вместе с компилятором. Поэтому, 
  вам нет необходимости заботиться о длинных, реверсированных доменных именах; 
  вы просто скажите, например:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> java.util.ArrayList;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">чтобы сказать компилятору, что вы хотите использовать 
  Java класс <B>ArrayList</B>. Однако <B>util</B> содержит несколько классов, 
  и вы можете использовать некоторые из них, не объявляя их точно. Это легче всего 
  выполнить, используя &#8216;<B>*</B>&#8217;, чтобы указать чистую карту:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>import</font> java.util.*;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Это более общий способ для импорта набора классов, в отличие 
  от индивидуального импорта каждого класса.</FONT></P>
<A NAME="Heading103"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Ключевое слово static</H3>
</FONT>
<P><FONT FACE="Georgia">Обычно, когда вы создаете класс, вы описываете, как выглядит 
  объект класса и как он будет себя вести. На самом деле вы ничего не получаете, 
  пока не создадите объект класса с помощью <B>new</B>, и в этом месте создается 
  хранилище данных, и становятся доступны методы.</FONT></P>
<P><FONT FACE="Georgia">Но есть две ситуации, в которых этот подход не достаточен. 
  Один из них, если вы хотите иметь только одну часть хранилища для определенных 
  данных, не зависимо от того, сколько объектов создано, или даже если не было 
  создано объектов этого класса. Второй, если вам нужен метод, который не ассоциируется 
  с объектом определенного класса. То есть, вам нужен метод, который вы можете 
  вызвать, даже если объект не создан. Вы можете достигнуть этих эффектов с помощью 
  ключевого слова <B>static</B>. Когда вы говорите о чем-то <B>static</B>, это 
  означает, что данные или метод не привязаны к определенному экземпляру объекта 
  класса. Даже если вы никогда не создадите объект этого класса, вы сможете вызвать 
  <B>статический</B> метод или получить доступ к части <B>статических</B> данных. 
  Как обычно, не <b>статические</b> данные и методы вы создаете объект и используете 
  его для доступа к данным или методам, так как не <b>статические</b> данные и 
  методы должны знать определенный объект, с которым они работают. Конечно, так 
  как статическим методам не нужно создавать объект до их использования, они не 
  могут получить <i>прямой</i> доступ к не <b>статическим</b> членам или методам 
  простым вызовом этих методов без указания имени объекта (так как не <b>статические</b> 
  члены и методы должны быть привязаны к определенному объекту).</FONT></P>
<P><FONT FACE="Georgia">Некоторые объектно-ориентированные языки используют термины 
  <i>данные класса</i> и <i>методы класса</i> в том смысле, что данные и методы 
  существуют только для класса, как целое, а не для любого определенного объекта 
  класса. Иногда литература по Java тоже использует эти термины.</FONT></P>
<P><FONT FACE="Georgia">Чтобы сделать член-данное или член-метод статическим, 
  вы просто помещаете ключевое слово перед определением. Например, следующий код 
  производит статический член-данное и инициализирует его:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> StaticTest {
    <font color=#0000ff>static</font> <font color=#0000ff>int</font> i = 47;
}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Теперь, даже если вы сделаете два объекта <B>StaticTest</B>, 
  будет только одна часть хранилища для <B>StaticTest.i.</B> Оба объекта будут 
  разделять одну и ту же <B>i</B>.<B> </B>Рассмотрим:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>StaticTest st1 = <font color=#0000ff>new</font> StaticTest();
StaticTest st2 = <font color=#0000ff>new</font> StaticTest();</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В этом месте и <B>st1.i,</B> и <B>st2.i</B> имеют одно 
  и то же значение 47, так как они ссылаются на одну и ту же область памяти.</FONT></P>
<P><FONT FACE="Georgia">Есть два способа сослаться на статическую переменную. 
  Как показано выше, вы можете назвать ее через объект, например, сказав <B>st2.i</B>. 
  Вы также можете прямо сослаться через имя класса, что вы не можете сделать с 
  не статическими членами. (Это предпочтительный способ сослаться на <b>статическую</b> 
  переменную, та как это подчеркивает, что переменная имеет <b>статическую</b> 
  природу.)</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>StaticTest.i++;</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Оператор <B>++</B> инкрементирует переменную. В этом месте 
  и <B>st1.i</B>, и <B>st2.i</B> будут иметь значение 48.</FONT></P>
<P><FONT FACE="Georgia">Сходная логика применима и к статическим методам. Вы можете 
  сослаться на статический метод либо через объект, как вы можете сделать с любым 
  методом, или с помощью специального дополнительного синтаксиса <B>ClassName.method(&#160;)</B>. 
  Вы определяете статический метод сходным образом:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>class</font> StaticFun {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> incr() { StaticTest.i++; }
}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вы можете увидеть, что метод <b>incr(&#160;)</b> класса 
  <B>StaticFun</B> инкрементирует <b>статическую</b> переменную <B>i</B>. Вы можете 
  вызвать <B>incr(&#160;)</B> обычным способом, через объект:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>StaticFun sf = <font color=#0000ff>new</font> StaticFun();
sf.incr();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Или, потому что <B>incr(&#160;) </B> - статический метод, 
    вы можете вызвать его прямо через класс:</FONT></P>
</DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>StaticFun.incr();</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Когда <B>static</B> применяется к членам-данным, это изменяет 
  путь создания данных (одни для всего класса против не статического: один для 
  каждого объекта), когда <b>static</b> применяется к методу - это не так драматично. 
  Важность использования <B>static</B> для методов в том, чтобы позволить вам 
  вызывать этот метод без создания объекта. Это неотъемлемая часть, как вы увидите 
  это в определении метода <B>main(&#160;)</B>, который является точкой входа 
  для запуска приложения.</FONT></P>
<DIV ALIGN="LEFT">
  <P><FONT FACE="Georgia">Как и любой метод, <b>статический</b> метод может создавать 
    или использовать именованные объекты того же типа, так что <b>статический</b> 
    метод часто используется как &#8220;пастух&#8221; для стада объектов одинакового 
    типа.</FONT></P>
</DIV>
<A NAME="Heading104"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Ваша первая Java программа</H2>
</FONT>
<P><FONT FACE="Georgia">Наконец, здесь приведена программа. </FONT><a href="#fn23">[23]</a><FONT FACE="Georgia"> 
  Она начинается с печати строки, а затем даты, используя класс <B>Date </B>из 
  стандартной библиотеки Java. Обратите внимание, что здесь приведен дополнительный 
  стиль комментариев: &#8216;<B>//</B>&#8217;, который объявляет комментарий до 
  конца строки:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>// HelloDate.java</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> HelloDate {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Hello, it's: "</font>);
    System.out.println(<font color=#0000ff>new</font> Date());
  }
}</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">В начале каждого файла программы вы должны поместить объявление 
  <B>import </B>об использовании любых дополнительных классов, которые вам нужны 
  в этом файле. Обратите внимание на слово &#8220;дополнительные&#8221;; это потому, 
  что есть определенные библиотеки классов, которые подключаются автоматически 
  к любому Java файлу: <B>java.lang</B>. Запустите ваш Web броузер посмотрите 
  документацию от Sun. (Если вы не загрузили ее с <I>java.sun.com</I> или не установили 
  документацию Java, сделайте это сейчас.) Если вы посмотрите на первую страницу, 
  вы увидите все различные библиотеки классов, которые поставляются с Java. Выберите 
  <B>java.lang</B>. Появится список всех классов, являющихся частью этой библиотеки. 
  Так как <B>java.lang</B> косвенно включается в каждый файл с Java кодом, эти 
  классы поддерживаются автоматически. В списке классов <b>java.lang</b> нет класса 
  <B>Date</B>, это означает, что вы должны импортировать другую библиотеку, чтобы 
  использовать его. Если вы не знаете библиотеку, где есть определенный класс, 
  или если вы хотите просмотреть все классы, вы можете выбрать &#8220;Дерево&#8221; 
  в документации Java. Теперь вы можете найти каждый единичный класс, который 
  поставляется с Java. Теперь вы можете использовать функцию поиска броузера для 
  нахождения <B>Date</B>.<B> </B>Когда вы сделаете это, вы увидите в списке <B>java.util.Date</B>, 
  что позволяет вам узнать, что она в библиотеке <B>util</B> и что вы должны написать 
  <B>import java.util.*</B> для использования <B>Date</B>.</FONT></P>
<P><FONT FACE="Georgia">Если вы вернетесь к началу, выберите <B>java.lang</B>, 
  а затем <B>System</B>, вы увидите, что класс <B>System</B> имеет несколько полей, 
  и если вы выберите <B>out</B>, вы обнаружите, что это объект <B>static</B> <B>PrintStream</B>. 
  Так как это <B>static</B>, вам нет необходимости создавать что-либо. Объект 
  <B>out</B> всегда здесь и вы можете просто использовать его. Что вы можете сделать 
  с этим объектом <B>out</B>, определяется типом: <B>PrintStream</B>. Удобство 
  в том, что <B>PrintStream </B>в описании показан как гиперссылка, так что если 
  вы кликните на ней, вы увидите все методы, которые вы можете вызвать для <B>PrintStream</B>. 
  Это не все и подробнее будет описано позже в этой книге. Мы же сейчас интересуемся 
  <B>println(&#160;)</B>, которая подразумевает &#8220;печатать то, что я передаю, 
  на консоль и выполнять переход на новую строку&#8221;. Таким образом, в Java 
  программе вы пишите то, что хотите сказать в виде<B> System.out.println(&#8220;things&#8221;)</B> 
  в любом месте, где бы вы ни захотели напечатать что-нибудь на консоль.</FONT></P>
<P><FONT FACE="Georgia">Имя класса такое же, что и имя файла. Когда вы создаете 
  самостоятельную программу, такую как эта, один из классов в этом файле должен 
  иметь такое же имя, что и файл. (Компилятор пожалуется, если вы не сделаете 
  это.) Этот класс должен содержать метод, называемый <B>main(&#160;)</B> с показанной 
  здесь сигнатурой:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Ключевое слово <B>public</B> означает, что метод доступен 
  извне (детально описано в Главе 5). Аргументом <B>main(&#160;)</B> является 
  массив объектов <B>String</B>. <B>args</B> не используется в этой программе, 
  но компилятор Java настаивает, чтобы он был, потому что он сохраняет аргументы 
  вызова командной строки.</FONT></P>
<P><FONT FACE="Georgia">Строка, печатающая дату, мало интересна:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println(<font color=#0000ff>new</font> Date());</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Относительно аргумента: объект <B>Date</B> создается только 
  для передачи его значения в <B>println(&#160;)</B>. Как только это выражение 
  закончится, <B>Date</B> становится ненужным и сборщик мусора может пройтись 
  и собрать его в любое время. Нам нет необходимости заботиться о его очистке.</FONT></P>
<A NAME="Heading105"></A><FONT FACE = "Verdana">
<H3 ALIGN="LEFT"> Компиляция и запуск</H3>
</FONT>
<P><FONT FACE="Georgia">Для компиляции и запуска этой программы и всех остальных 
  программ в этой книге вы должны сначала получить среду Java программирования. 
  Есть несколько сред разработки третьих фирм, но в этой книге мы будем предполагать, 
  что вы используете JDK от Sun, которая бесплатна. Если вы используете другую 
  систему разработки, вы найдете в документации для этой системы о том, как компилировать 
  и запускать программы.</FONT></P>
<P><FONT FACE="Georgia">Сходите в Internet на <I>java.sun.com</I>. Здесь вы найдете 
  информацию и ссылки, которые проведут вас через процесс скачивания и установки 
  JDK для вашей платформы.</FONT></P>
<P><FONT FACE="Georgia">Когда JDK установлен, и вы проставили информацию о путях 
  на своем компьютере, чтобы он нашел <B>javac</B> и <B>java</B>, скачайте и распакуйте 
  исходник для этой книге (вы можете найти его на CD ROM, прилагающийся к этой 
  книге, или на <I>www.BruceEckel.com</I>). Вы получите каталог для каждой главы 
  этой книги. У вас создадутся каталоги для каждой главы этой книги. Перейдите 
  в каталог <B>c02</B> и наберите:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>javac HelloDate.java</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">После этой команды ответа не ожидается. Если вы получили 
  сообщение об ошибки любого рода, это означает, что вы не правильно установили 
  JDK и вам необходимо исследовать эту проблему.</FONT></P>
<P><FONT FACE="Georgia">С другой стороны, если вы просто получили приглашение 
  командной строки, вы можете набрать:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java HelloDate</PRE></FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">и вы получите сообщение и дату в качестве вывода.</FONT></P>
<P><FONT FACE="Georgia">Этот процесс вы можете использовать для компиляции и запуска 
  каждой программы в этой книге. Однако вы увидите, что исходный код для этой 
  книги также имеет файл, называемый <B>makefile</B> в каждой главе и есть команда 
  &#8220;make&#8221; для автоматического построения файлов этой главы. Посмотрите 
  Web страницу этой книги на <I>www.BruceEckel.com</I> для получения более подробной 
  информации об использовании makefiles.</FONT></P>
<A NAME="Heading106"></A><FONT FACE = "Verdana">
<H2 ALIGN="LEFT"> Комментарии и встроенная документация</H2>
</FONT> 
<P><FONT FACE="Georgia">Есть два типа комментариев в Java. Первый - традиционный 
  комментарий в стиле C, который был унаследован из C++. Этот комментарий начинается 
  с <B>/*</B> и распространяется на много линий, пока не встретится <B>*/</B>. 
  Обратите внимание, что многие программисты начинают каждую линию продолжающихся 
  комментариев с <B>*</B>, так что вы часто можете видеть:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>/* Это комментарий,
*  который распространяется
*  на несколько строк
*/</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Однако помните, что все внутри <B>/*</B> и <B>*/</B> игнорируется, 
  так что это ничем не отличается от:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>/* Это комментарий, который
распространяется на несколько строк */</font></PRE>
  </FONT></BLOCKQUOTE>
<P><FONT FACE="Georgia">Вторая форма комментариев пришла из C++. Это однострочный 
  комментарий, который начинается с <B>//</B> и продолжается до конца линии. Этот 
  тип комментариев удобен и часто используется из-за своей простоты. Вам нет необходимости 
  охотиться за ключевыми словами, чтобы найти <B>/</B>, а затем <B>*</B> (вместо 
  этого вы нажимаете эту кнопку дважды), и вам нет необходимости закрывать комментарий. 
  Так что вы часто будете видеть:</FONT></P>
<BLOCKQUOTE><FONT SIZE = "+1">
  <PRE><font color=#009900>// Это однострочный комментарий</font><FONT FACE = "Verdana"></FONT></PRE>
  </FONT></BLOCKQUOTE>
<FONT FACE = "Verdana"> 
<H3 ALIGN="LEFT"> <a name="Heading107"></a> </H3>
</FONT>
<h3 align="LEFT"><font face="Verdana"> Комментарий-Документация</font></h3>
<p><font face="Georgia">Одна из вдумчивых частей языка Java в том, что его разработчики 
  не предполагали, что написание кода будет единственно важным действием &#8212; 
  они также подумали о его документации. Возможно, что наибольшая проблема с документированием 
  кода - это поддержка этой документации. Если документация и код разделены, вы 
  получаете трудности при изменении документации всякий раз, когда вы будете менять 
  код. Решение выглядит легким: свяжите код с документацией. Наилегчайший путь 
  для этого - поместить все в один файл. Однако для завершения картины вам нужен 
  специальный синтаксис для пометки специальной документации и инструмент для 
  выделения этих комментариев и помещения их в удобную форму. Это то, что делает 
  Java.</font></p>
<p><font face="Georgia">Инструмент, для выделения этих комментариев, называется 
  <i>javadoc.</i> Он использует ту же технологию, что и Java компилятор для поиска 
  специальных ярлыков комментариев, помещенных в вашу программу. Он не только 
  выделяет информацию, помеченную этими ярлыками, а так же помещает имя класса 
  или имя метода, присоединяя его к комментарию. Этим способом вы можете получить 
  при минимальной работе для генерации хорошей документации программы.</font></p>
<p><font face="Georgia">На выходе javadoc получается HTML файл, который вы можете 
  просмотреть вашим Web броузером. Этот инструмент позволяет вам создавать и поддерживать 
  единственный исходный файл и автоматически генерирует полезную документацию. 
  Поскольку с javadoc мы имеем стандарт для создания документации и это достаточно 
  легко, поэтому мы можем ожидать или даже требовать документации от Java библиотек.</font></p>
<a name="Heading108"></a> 
<h3 align="LEFT"><font face="Verdana"> Синтаксис</font></h3>
<p><font face="Georgia">Все команды javadoc встречаются только внутри комментариев 
  <b>/**</b>. Комментарий заканчивается <b>*/</b>, как обычно. Есть два основных 
  способа использовать javadoc: вставление HTML или использование &#8220;ярлыков 
  документации&#8221;. Ярлыки документации являются командами, которые начинаются 
  с &#8216;<b>@</b>&#8217;, которая помещается с начала строки комментария. (Однако 
  лидирующая &#8216;<b>*</b>&#8217; игнорируется.)</font></p>
<p><font face="Georgia">Есть три &#8220;типа&#8221; комментариев документации, 
  которые соответствуют элементам, предшествующий комментарию: класс, переменная 
  или метод. Таким образом, компоненты класса появляются прямо перед определением 
  класса; компонент переменная появляется прямо перед определением переменной, 
  а компонент метода появляется прямо перед определением метода. Как простой пример:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">/** Компонент - класс */</font>
<font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">class</font><font size="+1"> docTest {
  <font color=#009900>/** Компонент - переменная */</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">int</font><font size="+1"> i;
  <font color=#009900>/** Компонент - метод */</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">void</font><font size="+1"> f() {}
}</font></pre>
</blockquote>
<p><font face="Georgia">Обратите внимание, что javadoc будет обрабатывать компоненты 
  документации только для <b>public </b>и <b>protected </b>членов. Компоненты 
  для <b>private </b>и &#8220;дружественных&#8221; членов (смотрите Главу 5) игнорируются, 
  и вы не увидите их в выводе. (Однако вы можете использовать флаг <b>-private 
  </b>для включения <b>private</b> членов наряду с остальными.) Это имеет смысл, 
  так как только <b>public</b> и <b>protected</b> члены доступны извне файла, 
  которые просматривают программисты-клиенты. Однако все комментарии для <b>class</b> 
  включаются в выходной файл.</font></p>
<p><font face="Georgia">Вывод для приведенного выше кода - это HTML файл, который 
  имеет тот же стандартный формат, как и вся остальная документация по Java, так 
  что пользователи будут чувствовать себя комфортно с этим форматом и смогут легко 
  ориентироваться в ваших классах. Цена за это - ввод приведенного выше кода, 
  пропуск через javadoc и просмотр результирующего HTML файла.</font></p>
<a name="Heading109"></a> 
<h3 align="LEFT"><font face="Verdana"> Вставка HTML</font></h3>
<p><font face="Georgia">Javadoc пропускает HTML команды для генерации HTML документа. 
  Это позволяет вам использовать HTML; однако главный мотив состоит в позволении 
  вам форматировать код, например так:</font></p>
<blockquote>
  <pre><font color="#009900" size="+1">/**
* &lt;pre&gt;
* System.out.println(new Date());
* &lt;/pre&gt;
*/</font></pre>
</blockquote>
<p><font face="Georgia">Вы также можете использовать HTML, как вы это делаете 
  в других Web документах для форматирования обычного текста вашего документа:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">/**
* Вы можете &lt;em&gt;даже&lt;/em&gt; вставить список:
* &lt;ol&gt;
* &lt;li&gt; Первый элемент
* &lt;li&gt; Второй элемент
* &lt;li&gt; Третий элемент
* &lt;/ol&gt;
*/</font></pre>
</blockquote>
<p><font face="Georgia">Обратите внимание, что внутри комментариев-документации 
  звездочки в начале строки выбрасываются javadoc вместе с начальными пробелами. 
  Javadoc переформатирует все так, что документ принимает внешний вид стандартного. 
  Не используйте заголовки, такие как <b>&lt;h1&gt;</b> или <b>&lt;hr&gt;</b> 
  в качестве встраиваемого HTML, потому что javadoc вставляет свои собственные 
  заголовки, и вы можете запутаться в них.</font></p>
<p><font face="Georgia">Все компоненты документации &#8212; класс, переменная 
  и метод &#8212; могут поддерживать вставку HTML.</font></p>
<a name="Heading110"></a> 
<h3 align="LEFT"><font face="Verdana"> @see: ссылка на другой класс</font></h3>
<p><font face="Georgia">Все три типа компонентов документации (класс, переменная 
  и метод) могут содержать ярлык <b>@see</b>, который позволяет ссылаться на документацию 
  другого класса. Javadoc генерирует HTML с ярлыком <b>@see</b>, как гиперссылку 
  на другой документ. Форма:</font></p>
<blockquote>
  <pre><font size="+1">@see classname
@see fully-qualified-classname
@see fully-qualified-classname#method-name</font></pre>
</blockquote>
<p><font face="Georgia">Каждая вставка добавляет гиперссылку, входящую в раздел 
  &#8220;See Also&#8221;, при генерации документации. Javadoc не проверяет гиперссылки, 
  которые вы даете, чтобы убедится в их правильности.</font></p>
<a name="Heading111"></a> 
<h3 align="LEFT"><font face="Verdana"> Ярлыки документации класса</font></h3>
<div align="LEFT"> 
  <p><font face="Georgia">Наряду со встроенным HTML и ссылками <b>@see</b>, документация 
    класса может включать ярлыки для информации о версии и имени автора. Документация 
    класса также может быть использована для интерфейса (смотрите Главу 8).</font></p>
</div>
<a name="Heading112"></a> 
<h4 align="LEFT"><font face="Verdana"> @version</font></h4>
<p><font face="Georgia">Вот форма:</font></p>
<blockquote>
  <pre><font size="+1">@version version-information</font></pre>
</blockquote>
<p><font face="Georgia">в которой <b>version-information - </b>это любая важная 
  для вас информация., которую вы хотите включить. Когда вносится флаг <b>-version</b> 
  в командную строку javadoc, информация о номере версии специально будет включена 
  в генерируемый HTML документ.</font></p>
<a name="Heading113"></a> 
<h4 align="LEFT"><font face="Verdana"> @author</font></h4>
<div align="LEFT"> 
  <p><font face="Georgia">Вот форма:</font><br>
  </p>
</div>
<blockquote>
  <pre><font size="+1">@author author-information</font></pre>
</blockquote>
<p><font face="Georgia">в которой <b>author-information</b> это, предположительно, 
  ваше имя, но она так же может включать ваш электронный адрес или любую другую 
  подходящую информацию. Когда флаг <b>-author </b>вносится в командную строку 
  javadoc, информация об авторе специально включается в генерируемый HTML документ.</font></p>
<p><font face="Georgia">Вы можете иметь несколько ярлыков авторства для всего 
  списка авторов, но они будут помещены последовательно. Вся информация об авторах 
  будет собрана вместе в один параграф генерируемого HTML.</font></p>
<a name="Heading114"></a> 
<h4 align="LEFT"><font face="Verdana"> @since</font></h4>
<p><font face="Georgia">Этот флаг позволяет вам указывать версию того кода, с 
  которого началось использование определенной особенности. Вы увидите, что он 
  появится в HTML документации Java для указания какая версия JDK используется.</font></p>
<a name="Heading115"></a> 
<h3 align="LEFT"><font face="Verdana"> Ярлыки документации переменных</font></h3>
<p><font face="Georgia">Документация переменных может включать только встроенный 
  HTML код и ссылки <b>@see.</b></font></p>
<a name="Heading116"></a> 
<h3 align="LEFT"><font face="Verdana"> Ярлыки документации методов</font></h3>
<p><font face="Georgia">Так же как и встроенная документация и ссылки <b>@see</b>, 
  методы допускают ярлыки документации для параметров, возвращаемых значений и 
  исключений.</font></p>
<a name="Heading117"></a> 
<h4 align="LEFT"><font face="Verdana"> @param</font></h4>
<p><font face="Georgia">Эта форма:</font></p>
<blockquote>
  <pre><font size="+1">@param parameter-name description</font></pre>
</blockquote>
<p><font face="Georgia">в которой <b>parameter-name </b>- это идентификатор в 
  списке параметров, а <b>description </b>- текст, который может продолжаться 
  на последующих строках. Описание считается законченным, когда обнаруживается 
  новый ярлык документации. Вы можете иметь любое число таких ярлыков, предположительно, 
  по одному для каждого параметра.</font></p>
<a name="Heading118"></a> 
<h4 align="LEFT"><font face="Verdana"> @return</font></h4>
<p><font face="Georgia">Эта форма:</font></p>
<blockquote>
  <pre><font size="+1">@<font color=#0000ff>return</font> description</font></pre>
</blockquote>
<p><font face="Georgia">в которой <b>description</b> дает вам смысл возвращаемого 
  значения. Описание продолжается на последующих строках.</font></p>
<a name="Heading119"></a> 
<h4 align="LEFT"><font face="Verdana"> @throws</font></h4>
<p><font face="Georgia">Исключения будут продемонстрированы в Главе 10, но если 
  коротко: это объекты, которые могут быть &#8220;выброшены&#8221; из метода, 
  если метод окончится неудачей. Хотя только один объект исключение может появиться 
  при вызове метода, обычно метод может производить любое число исключений различных 
  типов, все они требуют описания. Форма ярлыка исключения следующая:</font></p>
<blockquote>
  <pre><font size="+1">@<font color=#0000ff>throws</font> fully-qualified-<font color=#0000ff>class</font>-name description</font></pre>
</blockquote>
<p><font face="Georgia">в которой <b>fully-qualified-class-name</b> дает вам уникальное 
  имя класса исключения, который где-нибудь определен, а <b>description</b> (которое 
  может продолжаться на последующих линиях) говорит вам, почему этот тип исключения 
  может возникнуть при вызове метода.</font></p>
<a name="Heading120"></a> 
<h4 align="LEFT"><font face="Verdana"> @deprecated</font></h4>
<p><font face="Georgia">Это используется для ярлыка особенностей, которые были 
  заменены улучшенными особенностями. Ярлык deprecated советует вам больше не 
  использовать эту определенную особенность, так как когда нибудь в будущем она 
  будет удалена. Метод, помеченный как <b>@deprecated</b> заставляет компилятор 
  выдавать предупреждение, если он используется.</font></p>
<a name="Heading121"></a> 
<h3 align="LEFT"><font face="Verdana"> Пример документации</font></h3>
<p><font face="Georgia"> Здесь снова приведена первая Java программа, на этот 
  раз с добавленными комментариями-документацией:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c02:HelloDate.java</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> java.util.*;

<font color=#009900>/** Первая программа - пример Thinking in Java.
 * Отображает строку и сегодняшнюю дату.
 * @author Bruce Eckel
 * @author www.BruceEckel.com
 * @version 2.0 
*/</font></font>
<font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">class</font><font size="+1"> HelloDate {
  <font color=#009900>/** Единственная точка входа для класса и приложения
   * @param args массив строк аргументов
   * @return Возвращаемого значения нет
   * @exception Исключения не выбрасываются
  */</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) {
    System.out.println(<font color=#004488>"Hello, it's: "</font>);
    System.out.println(<font color=#0000ff>new</font> Date());
  }
} <font color=#009900>///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Первая строка файла использует мою собственную технику 
  помещения &#8216;<b>:</b>&#8217; как специальный маркер для строки комментария 
  исходного имени файла. Эта строка содержит информацию о пути к файлу (в этом 
  случае <b>c02 </b>указывает Главу 2), за которой следует имя файла </font><a href="#fn24">[24]</a><font face="Georgia">. 
  Последняя строка также завершается комментарием, который означает конец исходного 
  кода, который позволяет автоматически выбирать его из текста этой книги и проверять 
  компилятором.</font></p>
<a name="Heading122"></a> 
<h2 align="LEFT"><font face="Verdana"> Стиль кодирования</font></h2>
<p><font face="Georgia">неофициальный стандарт в Java - написание имени класса 
  с большой буквы. Если имя класса содержит несколько слов, они идут вместе (так 
  как вы не можете использовать подчеркивания для разделения имен), и первая буква 
  каждого включенного слова пишется с большой буквы, как здесь:</font></p>
<blockquote>
  <pre><font color="#0000ff" size="+1">class</font><font size="+1"> AllTheColorsOfTheRainbow { <font color=#009900>// ...</font></font></pre>
</blockquote>
<p><font face="Georgia">Относительно всего остального: методы, поля (переменные-члены) 
  и имена ссылок на объекты принимает тот же стиль, что и для классов <i>за исключением</i> 
  того, что первая буква идентификатора в нижнем регистре. Например:</font></p>
<blockquote>
  <pre><font color="#0000ff" size="+1">class</font><font size="+1"> AllTheColorsOfTheRainbow {
  <font color=#0000ff>int</font> anIntegerRepresentingColors;
  <font color=#0000ff>void</font> changeTheHueOfTheColor(<font color=#0000ff>int</font> newHue) {
    <font color=#009900>// ...</font>
  }
  <font color=#009900>// ...</font>
}</font></pre>
</blockquote>
<p><font face="Georgia">Конечно, вы должны помнить, что пользователь тоже должен 
  печатать все эти длинные имена, и будьте милосердны.</font></p>
<p><font face="Georgia">Java код, который вы увидите в библиотеках от Sun, следует 
  размещению открывающих-закрывающих фигурных скобок, как вы видите в этой книге.</font></p>
<a name="Heading123"></a> 
<h2 align="LEFT"><font face="Verdana"> Резюме</font></h2>
<p><font face="Georgia">В этой главе вы увидели достаточно о программировании 
  на Java для понимания как писать простые программы, вы получили обзор языка 
  и некоторых его основных идей. Однако все примеры имели форму &#8220;сделай 
  это, затем сделай то, затем что-нибудь еще&#8221;. Что, если вы хотите программу 
  для выбора, такого как &#8220;если результат выполнения красный, выполнить это; 
  если нет, то что-нибудь другое&#8221;? Поддержка в Java для такого фундаментального 
  программирования будет освещен в следующей главе.</font></p>
<a name="Heading124"></a> 
<h2 align="LEFT"><font face="Verdana"> Упражнения</font></h2>
<div align="LEFT"> 
  <p><font face="Georgia" size=2>Решения для выбранных упражнений могут быть найдены 
    в электронной документации <i>The Thinking in Java Annotated Solution Guide</i>, 
    доступной за малую плату на <i>www.BruceEckel.com</i>.</font><br>
  </p>
</div>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Следуя примеру <b>HelloDate.java</b> 
    из этой главы, создайте программу &#8220;hello, world&#8221;, которая просто 
    печатает выражение. Вам необходим один метод в вашем классе (метод &#8220;main&#8221; 
    принимает выполнение, когда программа начинается). Не забудьте сделать его 
    статическим и включить список аргументов, даже если вы не используете его, 
    скомпилируйте программу с помощью <b>javac</b> и запустите ее, используя <b>java</b>. 
    Если вы используете другую среду разработки, отличную от JDK, выучите, как 
    скомпилировать и запустит программу в этой среде.</font> 
  <li>Найдите фрагмент кода, вводящий <font face="Georgia"> <b>ATypeName</b>, 
    и включите его в программу, затем скомпилируйте и запустите.</font> 
  <li>Включите фрагмент кода <font face="Georgia"> <b>DataOnly</b> в программу, 
    затем скомпилируйте и запустите.</font> 
  <li><font face="Verdana"> </font><font face="Georgia">Измените упражнение 3 
    так, чтобы значение данных в <b>DataOnly</b> назначалось и печаталось в <b>main(&#160;)</b>.</font> 
  <li>Напишите программу, которая включает и вызывает метод <font face="Georgia"> 
    <b>storage(&#160;)</b>, определенный как фрагмент кода в этой главе.</font> 
  <li><font face="Verdana"> </font><font face="Georgia">Включите фрагмент кода 
    <b>StaticFun</b> в работающую программу.</font> 
  <li>Напишите программу, которая печатает три аргумента, принимаемые из командной 
    строки. <font face="Georgia">Чтобы сделать это, вам нужно ввести индекс в 
    массив командной строки <b>String</b>s.</font> 
  <li><font face="Verdana"> </font><font face="Georgia">Включите <b>AllTheColorsOfTheRainbow</b> 
    пример в программу, затем скомпилируйте и запустите.</font> 
  <li>Найдите код для второй версии <font face="Georgia"> <b>HelloDate.java</b>, 
    который является просто примером документации. Запустите <b>javadoc</b> для 
    файла и просмотрите результат в вашем Web броузере.</font> 
  <li><font face="Verdana"> </font><font face="Georgia">Включите <b>docTest</b> 
    в файл, затем скомпилируйте и пропустите его через <b>javadoc</b>. проверьте 
    результат в вашем Web броузере.</font> 
  <li>Добавьте <font face="Georgia"> HTML список элементов в документацию упражнения 
    10.</font> 
  <li><font face="Verdana"> </font><font face="Georgia">Возьмите программу в упражнении 
    1 и добавьте в нее комментарии-документацию. Выберите эту документацию в HTML 
    файл, используя <b>javadoc</b> и просмотрите его в вашем Web броузере.</font> 
</ol>
<p><a name="fn20">[20]</a><font face="Georgia" size=2> Это может быть озарением. 
  Есть те, кто может сказать: &#8220;понятно, это указатель&#8221;, но это, предположительно, 
  лежащая в основе реализация. Также, ссылки Java во многом похожи на ссылки C++, 
  чем на указатели с их синтаксисом. В первой редакции книги я изобрел новый термин 
  &#8220;handle&#8221;, потому что ссылки C++ и ссылки Java имеют некоторое важное 
  различие. Я пришел из C++ и не хочу смущать программистов C++, которые будут 
  составлять самую большую аудиторию для Java. Во второй редакции я решил, что 
  &#8220;ссылка&#8221; будет наиболее часто используемым термином, и тот, кто 
  переходит с C++ будет иметь много больше для копирования с этой терминологией 
  ссылок, так что они могут прыгнуть сразу на обе ноги. Однако есть люди, которые 
  не согласны даже с термином &#8220;ссылка&#8221;. Я читал в одной книге, где 
  было &#8220;абсолютно неправильно сказано, что Java поддерживает передачу по 
  ссылке&#8221;, потому что идентификаторы объектов Java (в соответствии с авторами) 
  <i>реально</i> являются ссылками на объект&#8221;. И все <i>реально</i> передается 
  по значению. Так что вы не передаете по ссылке. Вы &#8220;передаете ссылку объекта 
  по значению&#8221;. Можно было приводить доводы в пользу точности таких замысловатых 
  объяснений, но я думаю, что мой подход упрощает понимание концепции без того, 
  чтобы повредить чему-нибудь (адвокаты языка могут утверждать, что я лгу вам, 
  но я скажу, что я обеспечиваю подходящую абстракцию).</font> </p>
<p><a name="#fnB21"></a>[21]<font face="Georgia" size=2> <b>статические </b> методы, 
  которые вы скоро выучите, могут вызываться <i>для класса</i> без объекта.</font></p>
<p><a name="fn22">[22]</a><font face="Georgia" size=2> С обычным исключениями 
  вышеупомянутых &#8220;специальных&#8221; типов данных <b>boolean, char</b>, 
  <b>byte</b>, <b>short</b>, <b>int</b>, <b>long</b>,<b> float </b>и <b>double</b>. 
  В общем, однако, вы передаете объекты, которые реально означают, что вы передаете 
  ссылку на объект.</font></p>
<div align="LEFT"> 
  <p><a name="fn23">[23]</a><font face="Georgia" size=2> Некоторые среды разработки 
    высвечивают программу на экране и закрывают ее прежде, чем вы получите шанс 
    увидеть результаты. Вы можете поместить следующий кусок кода в конец <b>main(&#160;)</b> 
    для приостановки вывода:</font></p>
</div>
<blockquote>
  <pre>    <font color="#0000ff" size="+1">try</font><font size="+1"> {
      System.in.read();
    } <font color=#0000ff>catch</font>(Exception e) {}</font></pre>
</blockquote>
<p><font face="Georgia" size=2>Это приостановит вывод, пока вы не нажмете &#8220;Enter&#8221; 
  (или любую другую кнопку). Этот код включает концепцию, которая будет введена 
  много позже в книге, так что вы не сможете понять его до этого места, но это 
  будет работать.</font></p>
<p><a name="fn24">[24]</a><font face="Georgia" size=2> Инструмент, которым я создавал, 
  используя Python (смотрите www.Python.org), использует эту информацию для выделения 
  файлов кода, помещения их в соответствующие поддириктории и создание мейкфайла.</font></p>
<p align="center"><font face="Verdana" size = "-1"> [ <a href="Chapter01.html">Предыдущая 
  глава </a> ] [ <a href="SimpleContents.html">Short TOC</a> ] [ <a href="Contents.html">Содержание</a> 
  ] [ <a href="DocIndex.html">Индекс</a> ] [ <a href="Chapter03.html">Следующая 
  глава </a> ]</font></p>
</BODY>

</HTML>
