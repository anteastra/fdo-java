<html><head><!-- by.ru advertising --><script language="JavaScript" src="AppendixC_files/upper.js"></script><title>Thinking in Java, 2nd edition. -- Руководство по программированию на Java.</title>

<meta http-equiv="author" content="KVV SoftWare">
<meta http-equiv="description" content="Советы разработчику программ на Java">
<meta http-equiv="keywords" content="java, ява, джава, script, скрипт, javascript, яваскрипт, programm, программа, programming, программирование, html, info, информация, information, инфо, sun, faq, чаво, frequently, часто, asked, задаваемые, questions, вопросы, odbc, jdbc, tips, советы, разработчику ">
<meta http-equiv="distribution" content="global">
<meta http-equiv="resource-type" content="document">
<meta http-equiv="Content-type" content="text/html; charset=Windows-1251"></head>



<body bgcolor="#fcfcfc">
<h2 align="center"><font face="Verdana">Thinking in Java, 2nd edition, Revision 
  11</font></h2>
<h3 align="center"><font face="Verdana">©2000 by Bruce Eckel</font></h3>
<h1 align="center"><font face="Verdana" size="-1">[ <a href=" AppendixB.html">Предыдущая 
  глава</a> ] [ <a href=" SimpleContents.html">Краткое описание</a> ] [ <a href=" Contents.html">Содержание</a> 
  ] [ <a href=" DocIndex.html">Список</a> ] [ <a href=" AppendixD.html">Следующая 
  глава</a> ] </font> <a name="Appendix_B"></a><a name="Appendix_C"></a><a name="_Toc375545509"></a><a name="_Toc477690738"></a><a name="_Toc481064959"></a><a name="Heading640"></a> 
</h1>
<h1 align="left">C: Руководящие принципы программирования на Java </h1>
<p><font size="4">Это приложение содержит предложения призванные помочь вам в осуществлении 
  низкоуровневой проектировки программных продуктов и последующего написания кода<a name="Index2295"></a><a name="Index2296"></a><a name="Index2297"></a>.</font></p>
<p>В действительности же, это только принципы, но не правила. Идея заключается 
  в использовании заложенных в них идей и при этом следует не забывать об исключениях 
  из правил, когда нужно отбросить или изменить какое-то правило.<a name="_Toc481064960"></a></p>
<a name="Heading641"></a>
<h2 align="left">
Проектировка</h2>
<ol>
  <li><b>Элегантность окупается всегда</b>. В этой короткой фразе заключается 
    глубокий смысл. Создание элегантного решения требует большего времени, но 
    в последствии адаптировать его для других задач или исправить ошибки будет 
    намного проще и быстрее, в противном случае, могут понадобиться дни, недели 
    или месяцы усилий прежде того, как Вы увидите результаты (даже если никто 
    их и не оценит). Элегантность не только позволяет вам проще создавать или 
    отлаживать программу, но и проще ее понять и обслуживать в дальнейшем, что 
    очень положительно сказывается на финансах. Этот способ требует некоторого 
    опыта для понимания, потому что он не может быть применен для небольшого кусочка 
    кода. И ограничьте различного рода "подгонятелей", они только замедляют 
    работу (в последствии).
  </li><li><b>Сначала пускай он работает, а затем сделаем его быстро работающим</b>. 
    Этот принцип верен, если Вы уверены, что этот кусочек кода действительно важен 
    и именно он будет бутылочным горлышком в вашей системе. Не делайте сразу его 
    полностью оптимизированным. Дайте системе сначала наивозможно простую модель. 
    Затем, если нужные участки не достаточно быстры, то оптимизируйте их. Затем 
    вы уже всегда будете понимать, действительно ли это узкое место или все-таки 
    нет. Сохраните ваше время для более важных дел.
  </li><li><b>Помни принцип "Разделяй и властвуй"</b>. Если разрешаемая проблема 
    слишком запутанна, то попытайтесь представить, что эта основная операция должна 
    быть составлена из "магических" кусочков, которые уже содержат сложные 
    части. Эти кусочки - объекты, напишите код, использующий эти объекты, а сложные 
    части инкапсулируйте в другие объекты и т.д.
  </li><li><b>Отделяй создателя класса от пользователя класса (клиентское программирование)</b>. 
    Пользователь класса - простой потребитель, он не должен знать что именно и 
    как происходит внутри ваших классов. Создатель класса должны быть экспертом 
    в создании и проектировки классов, поэтому получаемый класс должен быть максимально 
    прост в использовании. Библиотеки использовать легко, если они "прозрачны" 
    и ясны.
  </li><li><b>Когда Вы создаете класс, старайтесь дать ему имя такое, что бы не нужны 
    были комментарии</b>. Ваша задача сделать интерфейс клиентского программиста 
    концептуально простым. Для этого используйте перегрузку методов, когда нужно 
    и легкий в использовании интерфейс.
  </li><li><b>Ваша модель системы должна производить по минимуму классов, интерфейсов 
    и связей с другими классами, в частности с базовыми</b>. Если ваш проект создает 
    больше чем нужно, спросите себя, нужны ли все эти методы, интерфейсы и связи 
    во время работы программы? Если нет, то их поддержка вам еще встанет боком.<br>
    Члены групповой разработки стараются избавляться от ненужных частей проекта, 
    что существенно сказывается на их производительности.
  </li><li><b>Автоматизируй все!</b><b> </b>Пишите тестовый код в первую очередь (до 
    того, как напишите сам класс) и сохраните его вместе с классом. Автоматизируйте 
    запуск ваших тестов посредством makefile или похожей приблуды. Тогда любые 
    изменения в коде могут быть автоматически проверены запуском теста, а Вы при 
    этом немедленно получите все ваши ошибки. Поскольку Вы знаете о том, что ваши 
    тесты верны и безопасны (ведь так?), то Вы можете больше экспериментировать 
    в поиске правильного решения поставленных задач. Вспомните, что наибольшим 
    повышением производительности в языках программирования стал встроенный тест 
    по проверке типов, а так же по обработке исключений и т.д. Вы должны отойти 
    от создания трудоемкой системы к для созданию тестов, которые будут проверять 
    вашу программу на спецификации.
  </li><li><b>Пишите сперва тестовый код, до того, как Вы напишите ваш класс, в порядке 
    проверки правильности проектировки</b>. Если Вы не можете написать тестовый 
    код, то Вы и не знаете как будет выглядеть ваш класс в действительности. В 
    дополнение, написание тестового кода часто смывает дополнительные возможности 
    или принуждает внести необходимые возможности в ваш класс, а так же пересмотреть 
    модель вашего проекта. Тесты так же служат кодом примеров, показывающим, как 
    нужно использовать ваш класс.
  </li><li><b>Все проблемы проектировки программного обеспечения могут быть выявлены 
    введением дополнительного уровня абстрактного "отрешения"</b><i>.</i> 
    Это фундаментальное правило программных разработок<a href="#fn85">[85]</a><a name="Index2298"></a> 
    является базой абстракции, основной возможности объектно-ориентированного 
    программирования.
  </li><li><b>"Отрешение" должно иметь смысл </b>(в сочетании с принципом 
    9). Это означает, что все что "простое" должно быть отдельно (отдельный 
    код в отдельном методе). Если же Вы добавите еще один уровень абстракции, 
    то это будет уже плохо.
  </li><li><b>Создавайте классы настолько атомарными, на сколько это возможно</b>. 
    Давайте каждому классу простое, понятное предназначение. Если ваши классы 
    или ваша система проектирования растет слишком сложной, разделите сложные 
    классы на несколько простых. Наиболее понятным индикатором можно считать абсолютный 
    размер: если класс велик, то есть шанс его разделить на несколько маленьких.<br>
    Ключи для предположения по перепроектировке класса:<br>
    1) Запутанные операторы: подумайте о полиморфизме.<br>
    2) Большое число методов, которые обрабатывают различные типы или операции: подумайте о нескольких классах.<br>
    3) Большое число элементов переменных, которые относятся к различным характеристикам: 
    подумайте о нескольких классах.
  </li><li><b>Следите за длинными списками аргументов</b>. При этом вызовы, запись, 
    чтение или обработка методов значительно затруднены. Вместо этого попробуйте 
    переместить метод в класс, где его наиболее часто употребляют или передавайте 
    ему объекты, как аргументы.
  </li><li><b>Не повторяйтесь</b>. Если некий кусочек кода требуется в многих методах 
    дочерних классов, то поместите его в один метод базового класса, а затем вызывайте 
    его из дочернего. Это не только позволит сохранить место, но и позволит с 
    легкостью вносить изменения. Иногда изучение этого общего кода приносит дополнительную 
    функциональность вашему интерфейсу.
  </li><li><b>Следите за выражениями <i>switch</i> и цепочками <i>if-else</i></b>. 
    Это всего лишь индикатор проверки кодирования, что означает, что Вы выбираете, 
    какой код будет выполнен на основании некой информации (точный тип может быть 
    не известен первоначально). Вы должны заменять этот код посредством наследования 
    и полиморфизма; вызовы полиморфных методов выполняют за вас всю работу по 
    проверке типов, что в результате позволяет иметь более гибкую систему.
  </li><li><b> С точки зрения проектировки, найдите и отделите те вещи, которые могут 
    изменяться от тех, которые всегда постоянны</b>. Это означает, что нужно в 
    системе найти элементы, которые Вы можете изменить без принудительного редизайна, 
    затем инкапсулируйте их в отдельные классы. Вы можете значительно больше узнать 
    об этом в книге <i>Thinking in Patterns with Java</i>, доступной с <i><a href="http://www.bruceeckel.com/">www.BruceEckel.com</a></i>.
  </li><li><b>Не расширяйте фундаментальную функциональность посредством подклассов</b>. 
    Если элемент интерфейса для класса важен, то он должен быть в базовом классе, 
    а не добавлен в процессе наследования. Если же Вы добавляете методы во время 
    наследования, то стоит подумать о перепроектировке.
  </li><li><b>Меньше - больше</b>. Начинайте с минимума интерфейса класса, как можно 
    меньшего, что бы только хватало решить поставленную задачу, не пытайтесь предугадать 
    все варианты, как может быть использован ваш класс. Как только ваш класс будет 
    использован, то здесь уже можно посмотреть и расширять его интерфейс. Но все 
    равно, как только Вы "выпустите" класс, то уже будет невозможно 
    раширять его интерфейс, без изменения его кода. Если вам нужно расширить интерфейс 
    существующих методов, добавлением новых аргументов, создайте перегруженный 
    метод с новыми аргументами.
  </li><li><b>"Прочтите" ваш класс в слух, что бы убедиться, что он логичен</b>. 
    Убедитесь, что отношения между базовым классом и дочерним классом есть "это 
    - есть" ("is-a"), а у элементов класса "имеет это" 
    ("has-a").
  </li><li><b>Во время принятия решения по использованию наследования или композиции, 
    спросите себя, а нужно ли мне использовать приведение к базовому типу?</b> 
    Если нет, то предпочтите композицию наследованию. При этом отпадет необходимость 
    в множестве базовых типов. Если же Вы наследуете, то пользователи могут не 
    без оснований думать, что можно произвести приведение к базовому типу.
  </li><li><b>Используйте элементы данных для разнообразия в значениях, а переопределение 
    методов для разнообразия в поведении</b>. Это означает, что если Вы найдете 
    класс, который использует значения переменных в месте с методами, для того, 
    что бы изменять поведение в зависимости от значений этих переменных, то следует, 
    скорее всего, перепроектировать этот класс. Нужно выразить различие в поведении 
    в подклассы и переопределенные методы.
  </li><li><b>Следите за перегрузкой</b>. Метод не должен выполняться на основе аргумента, 
    вместо этого нужно создать два или более перегруженных методов.
  </li><li><b>Используйте иерархию исключений</b>, желательно наследовать от специального 
    класса в стандартной иерархии исключений Java. Если кто-то обрабатывает исключения, 
    то он может обрабатывать только определенные типы исключений, следующие от 
    этого базового класса. Если Вы добавляете новое дочернее исключение, то существующий 
    клиентский код его все равно обработает, основываясь на базовом типе.
  </li><li><b>Иногда простая агрегация выполняют всю работу</b>. "Система комфорта 
    пассажира" на авиалиниях состоит из различных, отсоединенных друг от 
    друга частей: сиденья, кондиционеры воздуха, видео и т.д., а теперь представьте, 
    что вам нужно создать несколько таких систем в самолете. Вы сделаете частные 
    (новые) элементы и создадите новый интерфейс? Нет, в этом случае, компоненты 
    также являются частью публичного интерфейса, поэтому Вы должны просто создать 
    публичные элементы-объекты. Эти объекты имеют свою собственную реализацию, 
    но при этом они так же безопасны. Знайте, что простая агрегация не то решение, 
    которое может часто применяться, но при его использовании все счастливы.
  </li><li><b>Примите во внимание клиентского программиста и того, кто будет обслуживать 
    ваш код</b>. Проектируйте ваш класс настолько ясно, насколько это возможно 
    для использования. Предвидьте те изменения, которые могут с ним произойти 
    и спроектируйте ваш класс так, что бы привнести их было в него просто.
  </li><li><b>Остерегайтесь синдрома гигантских объектов.</b> Этот синдром - частое 
    несчастье процедурных программистов, которые только начинают программировать 
    в ООП, и кто еще не закончил писать процедурные программы и обычно помещает 
    в своей объектной программе несколько больших объектов и все.
  </li><li><b>Если Вы должны сделать что-то ужасное, то меньшей мере сделайте это внутри 
    класса</b>.
  </li><li><b>Если вам нужно сделать что-то непереносимое, то создайте абстракцию и 
    локализуйте ее в отдельном классе</b>. Это уже более высокий уровень абстрагирования 
    непереносимых элементов, которые будут распространяться с вашей системой. 
    (Эта идиома материализована в шаблоне <i>Bridge</i>).
  </li><li><b>Объект должен не просто содержать данные</b>. Они должны так же иметь 
    и определенные принципы поведения. (Иногда, чистые объекты данных подходят, 
    но только когда они используются для хранения или передачи группы элементов.)
  </li><li><b>Сперва используйте композицию, когда создаете новый класс от уже существующего</b>. 
    Вы должны использовать наследование только, если это требование вашего дизайна. 
    Если Вы используете наследование, где должна быть использована композиция, 
    то тогда ваш дизайн без нужды запутанный.
  </li><li><b>Используйте наследование и переопределение методов для выражения различий 
    в поведении, а поля для выражения различий в положении</b>. Крайним случаем 
    того, чего не нужно делать - наследование различных классов для отображения 
    цвета, вместо использования поля цвета.
  </li><li><b>Остерегайтесь конфликтов</b>. Два семантически различных объектов могут 
    иметь идентичные возможности по действиям или по ответственности, при этом 
    возникает искушение попытаться создать один подкласс от этих классов посредством 
    наследования. Отсюда и возникает конфликт, однако в этом случае нет необходимости 
    оправдывающей создание связи дочернего класса с суперклассом. Поэтому лучшим 
    решением будет создать главный базовый класс, который реализует интерфейс 
    для обоих дочерних классов, при этом потребуется немного больше места, но 
    у вас останутся все преимущества наследования.
  </li><li><b>Остерегайтесь ограничений наследования</b>. В ясном дизайне новые возможности 
    добавляются в наследуемые объекты. Подозрительный дизайн удаляет старые возможности 
    во время наследования без добавления новых. Но правила могут нарушаться, и 
    если Вы работаете из старой библиотеки класса, то было бы лучше ограничить 
    существующий класс в его подклассе так что бы была возможность переработать 
    иерархию наследования, что бы ваш класс был там, где ему положено быть - над 
    старым классом.
  </li><li><b>Используйте шаблоны проектировки, что бы исключить "голую функциональность".</b> 
    Это означает, что если вам нужен только один созданный объект вашего класса, 
    то добавьте комментарий "Создавайте только один". Оберните его в 
    одноэлементное множество (синглтон). Если же у вас имеется много грязного 
    кода в вашей главной программе, которая создает ваши объекты, то, обратитесь 
    к шаблонам создания, например, к методам предприятия, с помощью которых Вы 
    и можете реализовать это создание. Исключение "голой функциональности" 
    не только сделает ваш код более легким для понимания и поддержки, оно так 
    же сделает его более пуленепробиваемым против "доброжелателей" пришедших 
    после вас.
  </li><li><b>Остерегайтесь аналитического паралитизма.</b> Запомните, что Вы должны 
    обычно продвигаться в перед в проекте до того, как Вы узнаете все о нем, а 
    лучшим способом при этом будет узнавать то, что Вы не знаете до того, как 
    Вы к этому приступите. Вы не будете знать решения до того, как Вы получите 
    его. Java сделана по принципу файрволов (брендмауеров), дайте им поработать 
    в ваших интересах. Ваши ошибки в классе или наборе классов не разрушат целостность 
    всей системы.
  </li><li><b>Когда Вы думаете, что Вы хорошо проанализировали систему, создали отличный 
    проект или его реализацию, то критично оцените (проанализируйте ее сквозным 
    методом) всю систему целиком</b>. Покажите систему какому - либо стороннему 
    лицу, кто не участвовал в разработке или консультациях. Взгляд на систему 
    парой "новых" глаз зачастую помогает выявить недостатки и недоделки.<a name="_Toc481064961"></a>
</li></ol>
<a name="Heading642"></a>
<h2 align="left">
Реализация</h2>
<ol>
  <li><b>В основном следуйте условностям кодирования от Sun-а</b>. Они доступны с<br>
    <i><a href="http://java.sun.com/docs/codeconv/index.html" target="_blank">java.sun.com/docs/codeconv/index.html</a></i> 
    (код же в этой книге следует им настолько, насколько это возможно). Эти принципы 
    используются для большого числа программ и большим числом программистов. Если 
    же Вы будете упорно использовать свой собственный стиль написания, то Вы доставите 
    немало трудностей читателю ваших исходных кодов. Но все равно, тот стиль кодирования, 
    который Вы предпочитаете должен соблюдаться на протяжении всего проекта. А 
    вот здесь раздается бесплатная утилита преобразующая код Java: <i><a href="http://home.wtal.de/software-solutions/jindent" target="_blank">home.wtal.de/software-solutions/jindent</a>.</i>
  </li><li><b>Независимо от того, какой стиль кодирования Вы используете, стиль исходного 
    кода будет различаться в вашей команде или целиком в вашей компании</b>. Это 
    означает, что следует приводить стиль написания к некоему общему стилю, что 
    в конечном результате позволит быстрее понимать написанное и сосредоточиваться 
    на там, что этим кодом описано, а не на том, что же там все-таки написано.
  </li><li><b>Следуйте стандартным правилам капитализации (изменения регистра)</b>.
Капитализируйте первые буквы имен классов.
Первые буквы полей, методов и объектов должны начинаться с маленькой
буквы. Все идентификаторы должны содержать все слова вместе с большими
буквами в начале каждого из слов. К примеру:<br>
    <b>ThisIsAClassName</b><br>
    <b>thisIsAMethodOrFieldName</b><br>
    Капитализируйте все буквы <b>static</b> <b>final</b>
примитивов, который были проинициализованы в константы при их
определении. Это будет означать, что они константы времени компиляции.<br>
    <b>Пакеты - особый случай,</b> они содержат все маленькие буквы, даже у внутренних 
    слов. Расширение домена (com, org, net, edu и т.д.) должны быть так же в нижнем 
    регистре. (Этим различаются Java 1.1 и Java 2.)
  </li><li><b>Не создавайте своих собственных, оформленных частных членов данных</b>. 
    Часто это выражается в виде висячих строк и символов. Яркий пример отвратительного 
    именования - венгерская нотация, где Вы должны добавлять дополнительные символы, 
    индицирующие тип данных, расположение и т.д., как если бы Вы писали на языке 
    ассемблера и компилятор без этих ухищрений не справится со своей задачей. 
    Такая нотация сбивает с толку, ее трудно читать, трудно ее соответственно 
    писать и обслуживать. Пусть имена классов и пакетов послужат для вас примером.
  </li><li><b>Следуйте каноническим формам </b>при создании классов для основного использования. 
    Включайте в него определения для <b>equals(&nbsp;)</b>, <b>hashCode(&nbsp;)</b>, 
    <b>toString(&nbsp;)</b>, <b>clone(&nbsp;)</b> (реализуйте <b>Cloneable</b>) 
    и реализуйте <b>Comparable </b>и <b>Serializable</b>.
  </li><li><b>Используйте JavaBean-овые "get", "set" и "is" 
    соглашения об именовании</b> для методов, которые читают и изменяют поля <b>private</b>, 
    даже если Вы думаете, что этому компоненту не жить долго. Это не только позволит 
    использовать этот класс как Bean, это так де и стандартный путь именования 
    такого рода методов, что несомненно же позволит читателю более легко разобраться 
    в исходном коде.
  </li><li><b>Рассмотрите возможность поместить в каждый из классов, который Вы создаете 
    метод <i>static public test(&nbsp;)</i>, который позволяет тестировать ваш 
    класс</b>. Вам не нужно удалять этот тестовый код из класса в проекте, но 
    а когда Вы что-то измените, то можно с легкостью его протестировать. Этот 
    же код может служить так же и примером по использованию вашего класса.
  </li><li><b>Иногда вам требуется наследовать, что бы получить доступ к защищенным 
    элементам базового класса</b>. Это может привести к необходимости восприятия 
    множественных базовых типов. Если же вам не нужно приводить к базовому типу, 
    тогда сперва создайте новый дочерний класс для доступа к закрытым областям 
    родительского класса. Затем сделайте этот новый класс элементом внутри любого 
    другого класса, которому требуется использовать эти данные, прежде чем наследовать.
  </li><li><b>Избегайте использования <i>final</i> методов в целях эффективности</b>. 
    Используйте <b>final </b>только если программа работает не так быстро как 
    хотелось бы, а ваш профайлер показывает, что именно в этом месте и есть то 
    самое бутылочное горлышко.
  </li><li><b>Если два класса взаимосвязаны между собой функционально (контейнерно 
    или итерационно), то попытайтесь сделать один из них внутренним классом другого</b>. 
    При этом будет не только предано специальное значение связи этих двух классов, 
    но и появится возможность повторного использования класса внутри отдельного 
    пакета вложением его в другой класс. Контейнерная библиотека Java-ы осуществляет 
    такую процедуру определением внутреннего класса <b>Iterator</b> внутри каждого 
    контейнерного класса, тем самым предоставляя контейнеры с общим интерфейсом. 
    Другая причина использования внутреннего класса - частная реализация. При 
    этом, внутренний класс скрывается от других классов и пространство имен при 
    этом не засоряется.
  </li><li><b>Всегда, когда Вы решаете, что существующий класс чересчур активно работает 
    с другим, то использование внутреннего класса позволит увеличить производительность 
    программы и кодирования</b>. Использование внутренних классов не разъединит 
    связанные классы, но сделает эту связь более ясной и простой.
  </li><li><b>Не станьте добычей преждевременной оптимизации</b>. Этот путь сравни 
    сумасшествию. В частности, не беспокойтесь о написании (или не написании) 
    нативных методов, создания некоторых методов с модификатором <b>final</b> 
    или настройкой кода для создания эффективной системы. Ваша основная задача 
    - реализовать проект, с наибольшей эффективностью дизайна.
  </li><li><b>Сохраняйте контекст таким маленьким, как только это возможно, поскольку 
    от этого зависит не только видимость, но и время жизни объектов</b>. При этом 
    уменьшается шанс использовать объект не в том контексте, а так же шанс на 
    скрытие трудно уловимых ошибок. К примеру, представьте, что у вас есть контейнер 
    и кусочек кода, проходящего сквозь него. Если Вы скопируете этот код для использования 
    с другим контейнером, то вполне вероятно, что так же скопируется и кусочек 
    старого контейнера. Или по другому может случить так, что ваш старый контейнер 
    будет вне контекста во время компиляции.
  </li><li><b>Используйте контейнеры в стандартных библиотеках Java</b>. Становясь 
    более профессиональным с использованием контейнеров, Вы еще к тому же значительно 
    повысите вашу производительность. Предпочитайте <b>ArrayList</b> для последовательностей, 
    <b>HashSet</b> для наборов, <b>HashMap</b> для ассоциативных массивов, а <b>LinkedList</b> 
    для стеков (а не <b>Stack</b>) и очередей.
  </li><li><b>Для программы, которая должна быть "крепкой", каждый их компонентов 
    должен быть "крепким"</b>. Используйте все инструменты представляемые 
    Java: управление доступом, исключения, проверка типов и т.д. для каждого класса, 
    который Вы создаете. При этом вы сможете перейти на следующий уровень абстракции 
    при создании вашей системы.
  </li><li><b>Предпочтите ошибки времени компиляции ошибкам времени выполнения</b>. 
    Попытайтесь обработать все ошибки по максимуму. Обрабатывайте ошибки на месте 
    возникновения исключения. Ловите исключения в наиближайшем хендлере, который 
    может предоставить вам наибольшую информацию. Делайте все, что можете с исключениями 
    на этом уровне, если же это не решает проблему, то передавайте обработку исключения 
    дальше.
  </li><li><b>Остерегайтесь длинного описания методов</b>. Методы должны быть кратки, 
    а функциональный модуль описывать и реализовать дискретную часть интерфейса 
    класса. Длинный и сложный метод труден для понимания и вызывает большие расходы 
    при выполнении, и кроме этого он пытается сделать слишком много для одного 
    метода. Если Вы найдете такой метод, то это означает, что как минимум он должен 
    быть разбит на несколько отдельных методов. Так же можно предложить создать 
    и новый класс для этих методов. Маленькие же методы еще и заставляют вас их 
    чаще повторно использовать. (Иногда методы должны быть большими, но при этом 
    они все еще должны выполнять одну вещь.)
  </li><li><b>Сохраняйте все как можно более частным образом (private).</b> Как только 
    вы извещаете об аспектах вашей библиотеки(метода, класса, поля), то Вы уже 
    не сможете взять эти слова обратно. Если Вы сделали это, то Вы должны передать 
    кому-то ваш существующий код, для дальнейшего его развития. Если же вы извещаете 
    только о том, что необходимо, то Вы после этого можете изменять не заявленные 

    части практически как хотите. При этом, реализация изменений окажет незначительные 
    потрясения и изменения на дочерние классы. Ограничение видимости играет большую 
    роль при работе с потоками, только <b>private</b> поля могут быть защищены 
    против несинхронного использования.
  </li><li><b>Используйте комментарии не стесняясь, а так же используйте синтаксис 
    самодокументации <i>javadoc</i></b>. Но все равно, комментарии должны добавлять 
    истинный смысл к коду, код с комментариями должен пониматься с легкостью, 
    а не наоборот, когда комментарии только раздражают. Заметьте, что обычно названия 
    классов и методов в Java уменьшают необходимость в комментариях.
  </li><li><b>Избегайте использования "магических чисел", </b>которые жестко 
    зашиты в код. Поскольку они будут вашим ночным кошмаром, если вам потребуется 
    однажды изменить, например, 100 значений или целый массив. Вместо этого, создавайте 
    константы с описаниями и используйте их в своей программе. При этом вашу программу 
    будет легче понять и опять же легче в последствии поддерживать.
  </li><li><b>Когда создаете конструкторы, не забывайте об исключениях</b>. В лучшем 
    случае, конструктор не должен ничего делать такого, что могло бы вызвать исключение. 
    Следующий по лучшести способ, это когда класс должен создаваться путем наследования 
    от "крепкого" класса, так что вам не нужна будет очистка если все 
    таки произойдет исключение. В противном случае, Вы должны производить очистку 
    в выражении <b>finally</b>. Если же конструктор должен провалиться, то он 
    должен сгенерировать исключение, иначе вызывающий его объект так и будет думать, 
    что он создался нормально.
  </li><li><b>Если ваш класс требует очистки, то поместите ваш код очистки в один, 
    хорошо названный метод, </b>с именем на подобии <b>cleanup(&nbsp;),</b> которое 
    понятно объясняет его назначение. В дополнение, поместите <b>boolean</b> флаг 
    в класс, для индицирования, когда объект был правильно очищен, по этому флагу 
    <b>finalize(&nbsp;)</b> может проверять правильность очистки (смотри <a href=" Chapter04.html">главу 
    4</a>).
  </li><li><b>Ответственность <i>finalize(&nbsp;)</i> может быть проверена только на 
    "смертельные условия".</b> (Смотри <a href=" Chapter04.html">главу 
    4</a>.) В специальных случаях, он может освобождать память, которая может 
    быть не освобождена сборщиком мусора. Поскольку сборщик мусора может так и 
    не вызваться для вашего проекта, то Вы не можете осуществлять требуемую очистку 
    используя <b>finalize(&nbsp;)</b>. Для этого следует создать свой собственный 
    метод очистки. В методе <b>finalize(&nbsp;)</b> для класса, проверяйте, был 
    ли данный объект правильно очищен и вызывайте исключение от <b>RuntimeException,</b> 
    если это не так, что бы тем самым просигнализировать программисту об ошибке. 
    До того, как реализовать данную схему, проверьте, работает ли на вашей системе 
    <b>finalize(&nbsp;)</b>. (Вам может понадобиться вызвать <b>System.gc(&nbsp;),</b> 
    что бы вызвать такое поведение.)
  </li><li><b>Если объект должен быть очищен (не сборщиком мусора) в частном случае, 
    то используйте следующую технику:</b> инициализируйте объект и если инициализация 
    прошла успешно, то незамедлительно войдите в блок <b>try</b> с выражением 
    <b>finally</b> для очистки.
  </li><li><b>Когда Вы переопределяете <i>finalize(&nbsp;)</i> во время наследования, 
    не забывайте вызывать <i>super.finalize(&nbsp;)</i>.</b> (Это не важно, если 
    <b>Object</b> прямой родитель вашего класса.) Вы должны вызывать <b>super.finalize(&nbsp;)</b> 
    как завершающую часть вашего переопределения <b>finalize(&nbsp;)</b> а не 
    раньше, что бы быть уверенным, что объекты базового класса все еще валидны.
  </li><li><b>Когда Вы создаете контейнеры фиксированного размера для объектов, то 
    передавайте их как массивы</b> если Вы возвращаете эти контейнеры из методов. 
    При этом у вас будет возможность осуществлять проверку типов времени компиляции, 
    а получатель массива может не заботиться о приведении к базовому типу. Заметьте, 
    что базовый класс контейнерной библиотеки <b>java.util.Collection</b>, содержит 
    целых два метода <b>toArray(&nbsp;)</b>.
  </li><li><b>Выбирайте интерфейсы перед абстрактными классами</b>. Если Вы знаете, 
    что что-то собирается стать базовым классом, вам бы следовало сперва сделать 
    его как <b>interface</b>, а только если Вы решаетесь включить в него определения 
    методов и переменных, то сделайте его <b>abstract</b> классом. <b>Interface 
    </b>декларирует, что клиент должен делать, а класс концентрирует внимание 
    на деталях реализации.
  </li><li><b>Внутри конструкторов делайте только то, что действительно нужно для инициализации 
    объекта</b>. Активно препятствуйте попыткам вызова других методов (исключая 
    <b>final</b>), поскольку эти методы могут быть переопределены кем угодно и 
    могут совершать неожиданные действия во время создания. (Смотри <a href=" Chapter07.html">главу 
    7</a>.) Маленькие, простые конструкторы намного более хороши для обработки 
    исключений или если возникают ошибки.
  </li><li><b>Что бы не набраться большого опыта по срыву проектов, убедитесь, что 
    в classpath существует только по одному экземпляру распакованного класса (уникального)</b>. 
    В противном случае, компилятор может найти не нужный класс с таким же именем 
    первее нужного и сообщить при этом об ошибке. Если Вы думаете, что у вас проблемы 
    с classpath, попытайтесь поискать классы с одинаковыми именами с начала вашей 
    записи classpath. В идеале, лучше хранить все ваши классы в пакетах.
  </li><li><b>Берегитесь случайной перегрузки</b>. Если Вы решились переопределить 
    метод базового класса, но при это Вы сделали небольшую ошибочку, то вам, лучше 
    прервать редактирование нового метода и начать сначала. Поскольку при этом 
    ошибки может и не быть, а вот метод работать правильно уже не будет.
  </li><li><b>Берегитесь преждевременной оптимизации</b>. Сначала заставьте его работать, 
    затем сделайте его быстрым, но только, если Вы должны сделать это, и только 
    если этот участок кода действительно бутылочное горлышко, тормозящее всю систему. 
    В противном случае, если Вы не знаете, что тормозит вашу систему, то используйте 
    профайлер, для поиска этого пресловутого бутылочного горлышка. К тому же минусом 
    оптимизации будет и то, что оптимизированный код будет труднее читать и обрабатывать.
  </li><li><b>Запомните, что код больше раз читается, нежели пишется</b>. Читая проектировка 
    создает легко понимаемые программы, но все таки без комментариев и разъяснения 
    деталей они будут не очень понятны. А проектировка и комментарии к ней с разъяснениями 
    помогут вашим последователям, кто придет после вас.
</li></ol>
<hr>
<p><a name="fn85">[85]</a><font size="2"> Разъяснено мне Andrew Koenig.</font></p>
<div align="center"><font size="-1"> [ <a href=" AppendixB.html">Предыдущая глава</a> 
  ] [ <a href=" SimpleContents.html">Краткое описание</a> ] [ <a href=" Contents.html">Содержание</a> 
  ] [ <a href=" DocIndex.html">Список</a> ] [ <a href=" AppendixD.html">Следующая 
  глава</a> ]</font></div>
</body></html>