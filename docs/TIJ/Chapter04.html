<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head lang="en"><!-- by.ru advertising --><script language="JavaScript" src="Chapter04_files/upper.js"></script><!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:04/24/2000
Translation Time:06:35:50
Translation Platform:Win32
Number of Output files:23
This File:Chapter04.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
--><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>4: Инициализация и очистка</title></head>





<body bgcolor="#ffffff">
<div align="center"> <font face="Verdana" size="-1"> </font> 
  <center>
    <h2><font face="Verdana">
  Thinking in Java, 2nd edition, Revision 11</font></h2>
  <h3><font face="Verdana">©2000 by Bruce Eckel</font></h3>
  
    <font face="Verdana" size="-1"> [ <a href=" Chapter03.html">Предыдущая глава 
    </a> ] [ <a href=" SimpleContents.html">Оглавление</a> ] [ <a href=" Contents.html">Содержание</a> 
    ] [ <a href=" DocIndex.html">Индекс</a> ] [ <a href=" Chapter05.html">Следующая 
    глава </a> ] </font> 
  </center>
  <p></p></div><a name="Chapter_4"></a><a name="_Toc375545274"></a><a name="_Toc477690724"></a><a name="_Toc481064568"></a><a name="Heading163"></a><font face="Verdana">
<h1 align="left"> 4: Инициализация и очистка</h1>
</font>
<p><font face="Georgia" size="4">В процессе компьютерной революции, “не безопасное” 
  программирование стало главной виной его удорожания.</font></p>
<p><font face="Georgia">Двумя основными проблемами безопасности являются <i>инициализация</i> 
  и <i>очистка</i>. Многие ошибки в C возникали тогда, когда программист забывал 
  инициализировать переменную. Это особенно верно для библиотек, когда пользователь 
  не знает о том, как инициализировать компонент библиотеки или о том, что он 
  должен это сделать. Очистка - это особая проблема, потому что легче забыть об 
  элементе, когда вы уже закончили работать с ним, так как он больше не притягивает 
  ваше внимание. Таким образом, ресурсы, используемые элементом, остаются, и вы 
  можете легко прийти к завершению программы из-за нехватки ресурсов (чаще всего, 
  это память).</font></p>
<p><font face="Georgia">В C++ введена концепция <i>конструктора</i> - это специальный 
  метод, вызывающийся автоматически при создании объекта. Java позаимствовала 
  конструктор и добавила сборщик мусора, который автоматически освобождает ресурсы 
  памяти, когда они более не используются. Эта глава исследует проблемы инициализации 
  и очистки, и то, как они решаются в Java.</font><a name="_Toc312373853"></a><a name="_Toc375545275"></a><a name="_Toc481064569"></a></p>
<div align="left"></div>
<a name="Heading164"></a><font face="Verdana">
<h2 align="left"> Гарантированная инициализация при использовании конструктора</h2>
</font> 
<p><font face="Georgia">Вы можете выбрать подход создания метода, называемого 
  <b>initialize(&nbsp;)</b> для каждого созданного вами класса. Имя является подсказкой 
  к тому, что он должен быть вызван перед использованием объекта. К сожалению, 
  это означает, что пользователь должен помнить о вызове метода. В Java разработчик 
  классов может гарантировать инициализацию каждого объекта, обеспечив специальный 
  метод, называемый <i>конструктором<a name="Index380"></a><a name="Index381"></a></i>. 
  Если класс имеет конструктор, Java автоматически вызывает конструктор, когда 
  создается объект, прежде чем пользователь сможет взять его в руки. Поэтому инициализация 
  гарантируется.</font></p>
<p><font face="Georgia">Следующая сложность состоит в названии метода. Есть две 
  проблемы. Первая заключается в том, что любое имя, которое вы используете, может 
  совпасть с именем, которое вы захотите использовать в качестве члена класса. 
  А вторая заключается в том, что, так как компилятор отвечает за вызов конструктора, 
  то он всегда должен знать, какой метод вызывать. Решение, принятое в C++ кажется 
  простым и логичным, так что оно также используется в Java: имя конструктора 
  <a name="Index382"></a>совпадает с именем класса. Это имеет смысл, так как такой 
  метод будет вызван автоматически при инициализации.</font></p>
<p><font face="Georgia">Вот пример класса с конструктором:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:SimpleConstructor.java</font>
<font color="#009900">// Демонстрация простого конструктора.</font>

<font color="#0000ff">class</font> Rock {
  Rock() { <font color="#009900">// это конструктор</font>
    System.out.println(<font color="#004488">"Creating Rock"</font>);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> SimpleConstructor {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i++)
      <font color="#0000ff">new</font> Rock();
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Теперь, когда <a name="Index383"></a>объект создан:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">new</font> Rock();</pre></font></blockquote>
<p><font face="Georgia">место хранения зарезервировано и конструктор вызван. Это 
  гарантирует то, что объект будет правильно инициализирован прежде, чем вы получите 
  его.</font></p>
<p>Обратите внимание, что стиль кода, в том плане, что первый символ всех методов 
  записывается в нижнем регистре, не применим к конструктору, так как имя конструктора 
  должно совпадать с именем класса <i>полностью</i>.</p>
<p><font face="Georgia">Как и любой другой метод, конструктор может иметь аргументы<a name="Index384"></a><a name="Index385"></a>, 
  которые позволят вам указать способ создания объекта. Приведенный выше пример 
  может быть легко изменен так, чтобы конструктор получал аргумент:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:SimpleConstructor2.java</font>
<font color="#009900">// конструктор может иметь аргументы.</font>

<font color="#0000ff">class</font> Rock2 {
  Rock2(<font color="#0000ff">int</font> i) {
    System.out.println(
      <font color="#004488">"Creating Rock number "</font> + i);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> SimpleConstructor2 {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i++)
      <font color="#0000ff">new</font> Rock2(i);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Конструктор аргумента обеспечивает вам способ передачи 
  параметров для инициализации объекта. Например, если класс <b>Tree</b> имеет 
  конструктор, который принимает единственный аргумент целого типа, указывающий 
  высоту дерева, то вы можете создать объект <b>Tree</b> следующим образом:</font></p>
<blockquote><font size="+1">
  <pre>Tree t = <font color="#0000ff">new</font> Tree(12);  <font color="#009900">// 12-ти футовое дерево</font></pre>
  </font></blockquote>
<p><font face="Georgia">Если <b>Tree(int)</b> ваш единственный конструктор, то 
  компилятор не позволит вам создать объект <b>Tree</b> другим способом.</font></p>
<p><font face="Georgia">Конструктор снимает большой класс проблем и делает код 
  легче для чтения. В приведенном выше фрагменте кода, например, вы не видите 
  явного вызова некоторого метода <b>initialize(&nbsp;)</b>, который концептуально 
  отделен от определения. В Java определение и инициализация является объединенной 
  концепцией — вы не можете получить одно без другого.</font></p>
<p><font face="Georgia">Конструктор является необычным типом метода, поскольку 
  он не имеет возвращаемого значения<a name="Index386"></a><a name="Index387"></a>. 
  Это заметно отличается от возвращаемого значения типа <b>void</b>, когда метод 
  не возвращает ничего, но вы все еще имеете возможность вернуть что-то иное. 
  Конструктор не возвращает ничего, и вы не имеете вариантов. Если бы он имел 
  возвращаемое значение, и если бы вы могли выбирать свое собственное, компилятор 
  не знал бы, что делать с этим возвращаемым значением.</font><a name="_Toc375545276"></a><a name="_Toc481064570"></a></p>
<div align="left"></div>
<a name="Heading165"></a><font face="Verdana">
<h2 align="left"> Перегрузка методов<a name="Index388"></a><a name="Index389"></a></h2>
</font> 
<p><font face="Georgia">Одна из главных особенностей в любом языке программирования 
  - это использование имен. Когда вы создаете объект, вы даете имя области хранения. 
  Метод - это имя действия. При использовании имен для описания вашей системы 
  вы создаете программу, которую людям легче понять и изменить. Это очень похоже 
  на написание прозаического произведения — целью является взаимодействие 
  с вашими читателями.</font></p>
<p><font face="Georgia">Вы обращаетесь ко всем объектам и методам по имени. Хороший 
  подбор имен облегчает понимание кода для вас и ваших читателей.</font></p>
<p>Проблемы возникают, когда происходит перекладывание нюансов концепции с человеческого 
  языка на язык программирования. Часто одни и те же слова выражают несколько 
  различных смыслов <font face="Georgia">—</font> это называется <i>перегрузкой</i>. 
  Это полезно, особенно когда имеете дело с тривиальными отличиями. Вы говорите 
  <font face="Georgia">“стирать (мыть) рубашку”, “мыть машину” 
  и “мыть собаку”. Было бы глупо ограничиваться фразами, типа “рубашкоМойка 
  рубашки”, “машиноМойка машины” и “собакоМойка собаки”, 
  так как слушателю события нет необходимости делать различия при выполнении действия. 
  Большинство человеческих языков являются многословными, так что даже если вы 
  пропустите несколько слов, вы все равно поймете смысл. Мы не нуждаемся в уникальных 
  идентификаторах — мы можем вывести смысл из контекста.</font></p>
<p><font face="Georgia">Большинство языков программирования (и в частности C) 
  требуют использования уникальных идентификаторов для каждой функции. Так что 
  вы не можете иметь одной функции с именем <b>print(&nbsp;)</b> для печати целых 
  чисел, а другой, с названием <b>print(&nbsp;)</b> для печати чисел с плавающей 
  точкой — каждая функция требует уникального имени.</font></p>
<p><font face="Georgia">В Java (и C++) один из факторов вынуждает использовать 
  перегрузку методов: конструктор<a name="Index390"></a><a name="Index391"></a>. 
  Поскольку имя конструктора является предопределенным именем класса, то может 
  быть только одно имя конструктора. Но что, если вы хотите создавать объект более 
  чем одним способом? Например, предположим, вы строите класс, который может инициализировать 
  себя стандартным способом или путем чтения информации из файла. Вам нужно два 
  конструктора, один не принимает аргументов (конструктор по умолчанию, также 
  называемый конструктором <i>без аргументов</i>), а другой принимает в качестве 
  аргумента <b>String</b>, который является именем файла, из которого инициализируется 
  объект. Ода они являются конструкторами, так что они должны иметь одно и то 
  же имя — имя класса. Таким образом, <i>перегрузка методов</i> необходима 
  для получения возможности использования одного и того же имени метода с разными 
  типами аргументов. И хотя перегрузка методов необходима для конструкторов, она 
  является общим соглашением и может использоваться для любого метода.</font></p>
<p><font face="Georgia">Вот пример, показывающий оба перегруженных конструктора 
  и перегрузку обычного метода:</font></p>
<div align="left"></div>

<blockquote><font size="+1">
  <pre><font color="#009900">//: c04:Overloading.java</font>
<font color="#009900">// Демонстрация перегрузки конструктора</font>
<font color="#009900">// и обычного метода.</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">class</font> Tree {
  <font color="#0000ff">int</font> height;
  Tree() {
    prt(<font color="#004488">"Planting a seedling"</font>);
    height = 0;
  }
  Tree(<font color="#0000ff">int</font> i) {
    prt(<font color="#004488">"Creating new Tree that is "</font>
        + i + <font color="#004488">" feet tall"</font>);
    height = i;
  }
  <font color="#0000ff">void</font> info() {
    prt(<font color="#004488">"Tree is "</font> + height
        + <font color="#004488">" feet tall"</font>);
  }
  <font color="#0000ff">void</font> info(String s) {
    prt(s + <font color="#004488">": Tree is "</font>
        + height + <font color="#004488">" feet tall"</font>);
  }
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> prt(String s) {
    System.out.println(s);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Overloading {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 5; i++) {
      Tree t = <font color="#0000ff">new</font> Tree(i);
      t.info();
      t.info(<font color="#004488">"overloaded method"</font>);
    }
    <font color="#009900">// Перегруженный конструктор:</font>
    <font color="#0000ff">new</font> Tree();
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia"> Объект Дерева(<b>Tree</b>) может быть создан либо рассадой, 
  без аргументов, либо получен плановой посадкой в лесном хозяйстве по заданной 
  высоте. Для поддержки этого есть два конструктора, один не принимает аргументов 
  (мы называем конструктор, который не принимает аргументов, <a name="Index392"></a><a name="Index393"></a><i>конструктором 
  по умолчанию</i> <a href="#fn27">[27]</a><a name="Index394"></a><a name="Index395"></a>), 
  а другой принимает существующую высоту. </font></p>
<p><font face="Georgia">Вы так же можете захотеть вызвать метод <b>info(&nbsp;)</b> 
  более чем одним способом. Например, с аргументом <b>String</b>, если у вас есть 
  желание напечатать дополнительное сообщение, и без него, если вам нечего сказать. 
  Было бы странным давать два разных имени для того, что имеет одну и ту же концепцию. 
  К счастью, перегрузка методов позволяет вам использовать одно и то же имя в 
  обоих случаях.</font><a name="_Toc375545277"></a><a name="_Toc481064571"></a></p>
<a name="Heading166"></a><font face="Verdana"> 
<h3 align="left"> Как различать перегруженные методы<a name="Index396"></a><a name="Index397"></a></h3>
</font>
<p><font face="Georgia">Если методы имеют одинаковое имя, как Java может знать, 
  какой метод вы имеете в виду? Есть простое правило: каждый перегруженный метод 
  должен иметь уникальный список типов аргументов.</font></p>
<p><font face="Georgia">Если вы немного подумаете об этом, вы поймете смысл: как 
  еще программист может указать различия между методами, имеющими одно и то же 
  имя, кроме как по типу их аргументов?</font></p>
<p><font face="Georgia">Даже различия в порядке следования аргументов существенны 
  для различения двух методов: (Хотя обычно вы не захотите использовать такой 
  подход, так как в результате вы получите трудный в поддержке код.)</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c04:OverloadingOrder.java</font>
<font color="#009900">// Перегрузка, основывающаяся на</font>
<font color="#009900">// порядке следования аргументов.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> OverloadingOrder {
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> print(String s, <font color="#0000ff">int</font> i) {
    System.out.println(
      <font color="#004488">"String: "</font> + s +
      <font color="#004488">", int: "</font> + i);
  }
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> print(<font color="#0000ff">int</font> i, String s) {
    System.out.println(
      <font color="#004488">"int: "</font> + i +
      <font color="#004488">", String: "</font> + s);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    print(<font color="#004488">"String first"</font>, 11);
    print(99, <font color="#004488">"Int first"</font>);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Два метода <b>print(&nbsp;)</b> имеют идентичные аргументы, 
  но порядок их следования различается. Это дает возможность различать их.</font><a name="_Toc312373866"></a><a name="_Toc375545278"></a><a name="_Toc481064572"></a></p>
<a name="Heading167"></a><font face="Verdana">
<h3 align="left"> Перегрузка с помощью примитивных типов</h3>
</font>
<p><font face="Georgia">Примитивные типы могут автоматически преобразовываться 
  от меньшего типа к большему, и это может вносить путаницу в комбинации с перегрузкой. 
  Следующий пример демонстрирует, что случается, когда примитивные типы используются 
  для перегрузки методов:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:PrimitiveOverloading.java</font>
<font color="#009900">// Преобразование примитивных типов и перегрузка.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> PrimitiveOverloading {
  <font color="#009900">// boolean не может конвертироваться автоматически</font>
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> prt(String s) { 
    System.out.println(s); 
  }

  <font color="#0000ff">void</font> f1(<font color="#0000ff">char</font> x) { prt(<font color="#004488">"f1(char)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">byte</font> x) { prt(<font color="#004488">"f1(byte)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">short</font> x) { prt(<font color="#004488">"f1(short)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">int</font> x) { prt(<font color="#004488">"f1(int)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">long</font> x) { prt(<font color="#004488">"f1(long)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">float</font> x) { prt(<font color="#004488">"f1(float)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">double</font> x) { prt(<font color="#004488">"f1(double)"</font>); }

  <font color="#0000ff">void</font> f2(<font color="#0000ff">byte</font> x) { prt(<font color="#004488">"f2(byte)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">short</font> x) { prt(<font color="#004488">"f2(short)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">int</font> x) { prt(<font color="#004488">"f2(int)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">long</font> x) { prt(<font color="#004488">"f2(long)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">float</font> x) { prt(<font color="#004488">"f2(float)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">double</font> x) { prt(<font color="#004488">"f2(double)"</font>); }

  <font color="#0000ff">void</font> f3(<font color="#0000ff">short</font> x) { prt(<font color="#004488">"f3(short)"</font>); }
  <font color="#0000ff">void</font> f3(<font color="#0000ff">int</font> x) { prt(<font color="#004488">"f3(int)"</font>); }
  <font color="#0000ff">void</font> f3(<font color="#0000ff">long</font> x) { prt(<font color="#004488">"f3(long)"</font>); }
  <font color="#0000ff">void</font> f3(<font color="#0000ff">float</font> x) { prt(<font color="#004488">"f3(float)"</font>); }
  <font color="#0000ff">void</font> f3(<font color="#0000ff">double</font> x) { prt(<font color="#004488">"f3(double)"</font>); }

  <font color="#0000ff">void</font> f4(<font color="#0000ff">int</font> x) { prt(<font color="#004488">"f4(int)"</font>); }
  <font color="#0000ff">void</font> f4(<font color="#0000ff">long</font> x) { prt(<font color="#004488">"f4(long)"</font>); }
  <font color="#0000ff">void</font> f4(<font color="#0000ff">float</font> x) { prt(<font color="#004488">"f4(float)"</font>); }
  <font color="#0000ff">void</font> f4(<font color="#0000ff">double</font> x) { prt(<font color="#004488">"f4(double)"</font>); }

  <font color="#0000ff">void</font> f5(<font color="#0000ff">long</font> x) { prt(<font color="#004488">"f5(long)"</font>); }
  <font color="#0000ff">void</font> f5(<font color="#0000ff">float</font> x) { prt(<font color="#004488">"f5(float)"</font>); }
  <font color="#0000ff">void</font> f5(<font color="#0000ff">double</font> x) { prt(<font color="#004488">"f5(double)"</font>); }

  <font color="#0000ff">void</font> f6(<font color="#0000ff">float</font> x) { prt(<font color="#004488">"f6(float)"</font>); }
  <font color="#0000ff">void</font> f6(<font color="#0000ff">double</font> x) { prt(<font color="#004488">"f6(double)"</font>); }

  <font color="#0000ff">void</font> f7(<font color="#0000ff">double</font> x) { prt(<font color="#004488">"f7(double)"</font>); }

  <font color="#0000ff">void</font> testConstVal() {
    prt(<font color="#004488">"Testing with 5"</font>);
    f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5);
  }
  <font color="#0000ff">void</font> testChar() {
    <font color="#0000ff">char</font> x = 'x';
    prt(<font color="#004488">"char argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color="#0000ff">void</font> testByte() {
    <font color="#0000ff">byte</font> x = 0;
    prt(<font color="#004488">"byte argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color="#0000ff">void</font> testShort() {
    <font color="#0000ff">short</font> x = 0;
    prt(<font color="#004488">"short argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color="#0000ff">void</font> testInt() {
    <font color="#0000ff">int</font> x = 0;
    prt(<font color="#004488">"int argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color="#0000ff">void</font> testLong() {
    <font color="#0000ff">long</font> x = 0;
    prt(<font color="#004488">"long argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color="#0000ff">void</font> testFloat() {
    <font color="#0000ff">float</font> x = 0;
    prt(<font color="#004488">"float argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color="#0000ff">void</font> testDouble() {
    <font color="#0000ff">double</font> x = 0;
    prt(<font color="#004488">"double argument:"</font>);
    f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    PrimitiveOverloading p = 
      <font color="#0000ff">new</font> PrimitiveOverloading();
    p.testConstVal();
    p.testChar();
    p.testByte();
    p.testShort();
    p.testInt();
    p.testLong();
    p.testFloat();
    p.testDouble();
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Если вы посмотрите на результаты работы этой программы, 
  вы увидите, что значение константы 5 трактуется как <b>int</b>, так что, несмотря 
  на то, что есть перегруженный метод, используется тот, который принимает <b>int</b>. 
  Во всех остальных случаях, если вы имеете тип данных, который меньше, чем аргумент 
  метода, тип данный преобразуется. <b>char</b> производит немного отличающийся 
  эффект, так как если точное совпадение с <b>char</b> не будет найдено, он преобразуется 
  в <b>int</b>.</font></p>
<p><font face="Georgia">Что произойдет, если ваш аргумент <i>больше</i>, чем аргумент, 
  ожидаемый перегруженным методом? Модифицированная программа дает ответ на этот 
  вопрос:</font></p>
<div align="left"></div>

<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:Demotion.java</font>
<font color="#009900">// Понижение примитивных типов и перегрузка.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Demotion {
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> prt(String s) { 
    System.out.println(s); 
  }

  <font color="#0000ff">void</font> f1(<font color="#0000ff">char</font> x) { prt(<font color="#004488">"f1(char)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">byte</font> x) { prt(<font color="#004488">"f1(byte)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">short</font> x) { prt(<font color="#004488">"f1(short)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">int</font> x) { prt(<font color="#004488">"f1(int)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">long</font> x) { prt(<font color="#004488">"f1(long)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">float</font> x) { prt(<font color="#004488">"f1(float)"</font>); }
  <font color="#0000ff">void</font> f1(<font color="#0000ff">double</font> x) { prt(<font color="#004488">"f1(double)"</font>); }

  <font color="#0000ff">void</font> f2(<font color="#0000ff">char</font> x) { prt(<font color="#004488">"f2(char)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">byte</font> x) { prt(<font color="#004488">"f2(byte)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">short</font> x) { prt(<font color="#004488">"f2(short)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">int</font> x) { prt(<font color="#004488">"f2(int)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">long</font> x) { prt(<font color="#004488">"f2(long)"</font>); }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">float</font> x) { prt(<font color="#004488">"f2(float)"</font>); }

  <font color="#0000ff">void</font> f3(<font color="#0000ff">char</font> x) { prt(<font color="#004488">"f3(char)"</font>); }
  <font color="#0000ff">void</font> f3(<font color="#0000ff">byte</font> x) { prt(<font color="#004488">"f3(byte)"</font>); }
  <font color="#0000ff">void</font> f3(<font color="#0000ff">short</font> x) { prt(<font color="#004488">"f3(short)"</font>); }
  <font color="#0000ff">void</font> f3(<font color="#0000ff">int</font> x) { prt(<font color="#004488">"f3(int)"</font>); }
  <font color="#0000ff">void</font> f3(<font color="#0000ff">long</font> x) { prt(<font color="#004488">"f3(long)"</font>); }

  <font color="#0000ff">void</font> f4(<font color="#0000ff">char</font> x) { prt(<font color="#004488">"f4(char)"</font>); }
  <font color="#0000ff">void</font> f4(<font color="#0000ff">byte</font> x) { prt(<font color="#004488">"f4(byte)"</font>); }
  <font color="#0000ff">void</font> f4(<font color="#0000ff">short</font> x) { prt(<font color="#004488">"f4(short)"</font>); }
  <font color="#0000ff">void</font> f4(<font color="#0000ff">int</font> x) { prt(<font color="#004488">"f4(int)"</font>); }

  <font color="#0000ff">void</font> f5(<font color="#0000ff">char</font> x) { prt(<font color="#004488">"f5(char)"</font>); }
  <font color="#0000ff">void</font> f5(<font color="#0000ff">byte</font> x) { prt(<font color="#004488">"f5(byte)"</font>); }
  <font color="#0000ff">void</font> f5(<font color="#0000ff">short</font> x) { prt(<font color="#004488">"f5(short)"</font>); }

  <font color="#0000ff">void</font> f6(<font color="#0000ff">char</font> x) { prt(<font color="#004488">"f6(char)"</font>); }
  <font color="#0000ff">void</font> f6(<font color="#0000ff">byte</font> x) { prt(<font color="#004488">"f6(byte)"</font>); }

  <font color="#0000ff">void</font> f7(<font color="#0000ff">char</font> x) { prt(<font color="#004488">"f7(char)"</font>); }

  <font color="#0000ff">void</font> testDouble() {
    <font color="#0000ff">double</font> x = 0;
    prt(<font color="#004488">"double argument:"</font>);
    f1(x);f2((<font color="#0000ff">float</font>)x);f3((<font color="#0000ff">long</font>)x);f4((<font color="#0000ff">int</font>)x);
    f5((<font color="#0000ff">short</font>)x);f6((<font color="#0000ff">byte</font>)x);f7((<font color="#0000ff">char</font>)x);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Demotion p = <font color="#0000ff">new</font> Demotion();
    p.testDouble();
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Здесь методы принимают сужающие примитивные типы. Если 
  ваш список аргументов широк, вы должны выполнять <a name="Index398"></a><i>приведение 
  типа</i>, используя нужное имя типа в круглых скобках. Если вы не сделаете это, 
  компилятор выдаст сообщение об ошибки.</font></p>
<p><font face="Georgia">Вы должны быть знать, что это <a name="Index399"></a><a name="Index400"></a><i>ограничивающее 
  преобразование</i>, которое вы означает, что вы можете потерять информацию во 
  время приведения типа. По этой причине компилятор заставляет вас сделать это 
  — чтобы указать на ограничивающее преобразование.</font><a name="_Toc481064573"></a></p>
<a name="Heading168"></a><font face="Verdana">
<h3 align="left"> Перегрузка по возвращаемому значению<a name="Index401"></a><a name="Index402"></a></h3>
</font>
<p><font face="Georgia">Это обычное удивление: “Почему только имена классов 
  и список аргументов метода? Почему не делать различия между методами, основываясь 
  на их возвращаемом значении?” Например, эти методы имеют одинаковое имя 
  и список аргументов, но легко отличаются друг от друга:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">void</font> f() {}
<font color="#0000ff">int</font> f() {}</pre></font></blockquote>
<p><font face="Georgia">Это хорошо работает, когда компилятор может недвусмысленно 
  определить смысл из контекста, как в случае <b>int x = f(&nbsp;)</b>. Однако, 
  вы можете вызвать метод и проигнорировать возвращаемое значение; это часто называется 
  <i><a name="Index403"></a>побочным действием вызова метода</i>, так как вы не 
  заботитесь о возвращаемом значении, а просто ждете других эффектов от вызова 
  метода. Таким образом, если вы вызываете функция следующим образом:</font></p>
<blockquote><font size="+1"><pre>f();</pre></font></blockquote>
<p><font face="Georgia">как Java может определить какой из методов <b>f(&nbsp;)</b> 
  должен быть вызван? И как другой человек мог бы прочесть приведенный код? Из-за 
  возникновения проблем такого рода вы не можете использовать тип возвращаемого 
  значения для различения перегруженных методов.</font><a name="_Toc375545279"></a><a name="_Toc481064574"></a></p>
<a name="Heading169"></a><font face="Verdana">
<h3 align="left"> Конструктор по умолчанию</h3>
</font> 
<p><font face="Georgia">Как упоминалось ранее, конструктор по умолчанию <a name="Index404"></a><a name="Index405"></a>является 
  единственным конструктором без аргументов, который используется для создания 
  объекта”. Если вы создаете класс, который не имеет конструкторов, компилятор 
  автоматически создаст конструктор по умолчанию вместо вас. Например:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c04:DefaultConstructor.java</font>

<font color="#0000ff">class</font> Bird {
  <font color="#0000ff">int</font> i;
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> DefaultConstructor {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Bird nc = <font color="#0000ff">new</font> Bird(); <font color="#009900">// по умолчанию!</font>
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Строка</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">new</font> Bird();</pre></font></blockquote>
<p><font face="Georgia">создает новый объект и вызывает конструктор по умолчанию, 
  даже не смотря на то, что он не был явно определен. Без этого мы не имели бы 
  метода построения нашего объекта. Однако если вы определили любой конструктор 
  (с аргументами или без них) компилятор <i>не</i> будет синтезировать его за 
  вас:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">class</font> Bush {
  Bush(<font color="#0000ff">int</font> i) {}
  Bush(<font color="#0000ff">double</font> d) {}
}</pre></font></blockquote>
<p><font face="Georgia">Теперь, если вы скажете:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">new</font> Bush();</pre></font></blockquote>
<p><font face="Georgia">компилятор заявит, что он не может найти соответствующий 
  конструктор. Это похоже на то, что когда вы не определяете ни одного конструктора, 
  компилятор говорит: “Вы обязаны иметь <i>какой-то</i> конструктор, так 
  что позвольте мне создать его за вас”. Но если вы написали конструктор, 
  компилятор говорит: “Вы написали конструктор, так что вы знаете, что вы 
  делаете; если вы не создали конструктор по умолчанию, это значит, что он вам 
  не нужен”.</font><a name="_Toc375545280"></a><a name="_Toc481064575"></a></p>
<a name="Heading170"></a><font face="Verdana">
<h3 align="left"> Ключевое слово <a name="Index406"></a>this</h3>
</font>
<p><font face="Georgia">Если вы имеете два объекта одного и того же типа, с именами 
  <b>a</b> и <b>b</b>, вы можете задуматься, как вы можете вызвать метод <b>f(&nbsp;)</b> 
  для этих обоих объектов:</font></p>
<blockquote><font size="+1"></font><pre><font size="+1"><font color="#0000ff">class</font> Banana { <font color="#0000ff">void</font> f(<font color="#0000ff">int</font> i) { <font color="#009900">/* ... */</font> } }
Banana a = <font color="#0000ff">new</font> Banana(), b = <font color="#0000ff">new</font> Banana();
a.f(1);
b.f(2);</font></pre></blockquote>
<p><font face="Georgia">Если есть только один метод с именем <b>f(&nbsp;)</b>, 
  как этот метод узнает, был ли он вызван объектом <b>a</b> или <b>b</b>?</font></p>
<p><font face="Georgia">Чтобы позволить вам писать код в последовательном объектно-ориентированном 
  синтаксисе, в котором вы “посылаете сообщения объекту”, компилятор 
  выполняет некоторую скрытую от вас работу. Секрет в первом аргументе, передаваемом 
  методу <b>f(&nbsp;)</b>, и который отражает ссылку на объект, с которым происходит 
  манипуляция. Так что эти два вызова метода, приведенные выше, становятся похожи 
  на следующие вызовы:</font></p>
<blockquote><font size="+1"><pre>Banana.f(a,1);
Banana.f(b,2);</pre></font></blockquote>
<p><font face="Georgia">Это внутренний формат и вы не можете записать эти выражения 
  и дать компилятору доступ к ним, но это дает вам представление об идеи происходящего.</font></p>
<p><font face="Georgia">Предположим, вы находитесь внутри метода и хотите получить 
  ссылку на текущий объект. Так как эта ссылка передается компилятором <i>в тайне</i>, 
  здесь нет идентификатора для нее. Однако для этих целей существует ключевое 
  слово: <b>this</b>. Ключевое слово <b>this</b>, которое может использоваться 
  только внутри метода, производит ссылку на объект, который вызвал метод. Вы 
  можете трактовать эту ссылку, как и любой другой объект. Примите во внимание, 
  что если вы вызываете метод вашего класса из другого метода вашего класса, вам 
  не нужен <b>this</b>; вы просто вызываете метод. Текущая ссылка <b>this</b> 
  используется автоматически для другого метода. Таким образом, вы можете сказать:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">class</font> Apricot {
  <font color="#0000ff">void</font> pick() { <font color="#009900">/* ... */</font> }
  <font color="#0000ff">void</font> pit() { pick(); <font color="#009900">/* ... */</font> }
}</pre></font></blockquote>
<p><font face="Georgia">Внутри <b>pit(&nbsp;)</b>, вы <i>могли </i>сказать <b>this.pick(&nbsp;)</b>, 
  но в этом нет необходимости. Компилятор делает это за вас автоматически. Ключевое 
  слово <b>this</b> используется только в тех особых случаях, в которых вам нужно 
  явное использование ссылки на текущий объект. Например, оно часто используется 
  в инструкции <b>return</b>, когда вы хотите вернуть ссылку на текущий объект:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:Leaf.java</font>
<font color="#009900">// Простое использование ключевого слова "this".</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Leaf {
  <font color="#0000ff">int</font> i = 0;
  Leaf increment() {
    i++;
    <font color="#0000ff">return</font> <font color="#0000ff">this</font>;
  }
  <font color="#0000ff">void</font> print() {
    System.out.println(<font color="#004488">"i = "</font> + i);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Leaf x = <font color="#0000ff">new</font> Leaf();
    x.increment().increment().increment().print();
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Поскольку <b>increment(&nbsp;)</b> возвращает ссылку на 
  текущий объект через ключевое слово <b>this</b>, множественные операции могут 
  быть легко выполнены над тем же объектом.</font></p>
<a name="Heading171"></a><font face="Verdana">
<h4 align="left"> Вызов конструктора из конструктора<a name="Index407"></a></h4>
</font>
<p><font face="Georgia">Когда вы пишите несколько конструкторов для класса, бывают 
  случаи, когда вам нужно вызвать один конструктор из другого для предотвращения 
  дублирования кода. Вы можете сделать это, используя ключевое слово <b>this</b>.</font></p>
<p><font face="Georgia">Обычно, когда вы говорите <b>this</b>, это означает “этот 
  объект” или “текущий объект”, и само по себе это производит 
  ссылку на текущий объект. В конструкторе ключевое слово <b>this</b> принимает 
  другое значение, когда вы передаете его в списке аргументов: так создается явный 
  вызов конструктора, для которого совпадает список аргументов. Таким образом, 
  вы имеете прямой и понятный путь вызова других конструкторов:</font></p>
<div align="left"></div>

<blockquote><font size="+1">
  <pre><font color="#009900">//: c04:Flower.java</font>
<font color="#009900">// Вызов конструкторов с использованием "this".</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Flower {
  <font color="#0000ff">int</font> petalCount = 0;
  String s = <font color="#0000ff">new</font> String(<font color="#004488">"null"</font>);
  Flower(<font color="#0000ff">int</font> petals) {
    petalCount = petals;
    System.out.println(
      <font color="#004488">"Constructor w</font><font color="#004488">/ int arg only, petalCount= "</font>
      + petalCount);
  }
  Flower(String ss) {
    System.out.println(
      <font color="#004488">"Constructor w</font><font color="#004488">/ String arg only, s="</font> + ss);
    s = ss;
  }
  Flower(String s, <font color="#0000ff">int</font> petals) {
    <font color="#0000ff">this</font>(petals);
<font color="#009900">//!    this(s); // Нельзя вызвать два!</font>
    <font color="#0000ff">this</font>.s = s; <font color="#009900">// Другое использование "this"</font>
    System.out.println(<font color="#004488">"String &amp; int args"</font>);
  }
  Flower() {
    <font color="#0000ff">this</font>(<font color="#004488">"hi"</font>, 47);
    System.out.println(
      <font color="#004488">"default constructor (no args)"</font>);
  }
  <font color="#0000ff">void</font> print() {
<font color="#009900">//!    this(11); // Не внутри - не конструктор!</font>
    System.out.println(
      <font color="#004488">"petalCount = "</font> + petalCount + <font color="#004488">" s = "</font>+ s);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Flower x = <font color="#0000ff">new</font> Flower();
    x.print();
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Конструктор <b>Flower(String s, int petals)</b> показывает, 
  что когда вы вызываете один конструктор, используя <b>this</b>, вы не можете 
  вызвать второй. Кроме того, вызов конструктора должен быть первой вещью, которую 
  вы делаете, или вы получите сообщение об ошибке.</font></p>
<p><font face="Georgia">Этот пример также показывает другой способ, которым вы 
  можете использовать <b>this</b>. Так как имя аргумента <b>s </b>и имя члена-данного 
  <b>s</b> совпадает, здесь может возникнуть некоторая двусмысленность. Чтобы 
  разрешить ее, вы говорите <b>this.s</b>, чтобы указать на член-данное. Вы часто 
  будите видеть эту форму использования в Java коде, и она используется в некоторых 
  местах этой книги.</font></p>
<p><font face="Georgia">В <b>print(&nbsp;)</b> вы можете видеть, что компилятор 
  не позволяет вам вызывать конструктор изнутри любого метода, отличного от конструктора.</font></p>
<div align="left"></div>
<a name="Heading172"></a><font face="Verdana">
<h4 align="left"> Смысл static<a name="Index408"></a></h4>
</font> 
<p><font face="Georgia">Имея в виду ключевое слово </font><font face="Georgia"><b>this</b>, 
  вы можете более полно понимать, что означает создание <a name="Index409"></a><a name="Index410"></a><b>static</b> 
  метода. Это означает, что здесь нет <b>this</b> из обычного метода. Вы не можете 
  вызвать не-<b>static</b> метод изнутри <b>static</b> метода <a href="#fn28">[28]</a> 
  (хотя обратная ситуация возможна), но вы можете вызвать <b>static</b> метод 
  класса без любого объекта. Фактически, это первичная задача, для чего нужны 
  <b>static</b> методы. Это аналогично созданию глобальной функции (в C). Поскольку 
  глобальные функции в Java не допустимы, помещение <b>static</b> методов внутрь 
  класса позволяет получить доступ к другим <b>static</b> методам и <b>static</b> 
  полям.</font></p>
<p><font face="Georgia">Некоторые люди утверждают, что <b>static</b> методы не 
  являются объектно-ориентированными, так как они имеют семантику глобальных функций; 
  с помощью <b>static</b> метода вы не посылаете сообщение объекту, та как здесь 
  нет <b>this</b>. Это достаточно сильный аргумент, и если вы ловите себя на том, 
  что вы используете <i>очень много</i> статических методов, вероятно, вы должны 
  изменить свою стратегию. Однако <b>static</b> является практичным способом, 
  и иногда вы действительно нуждаетесь в нем, так что вопрос о том, относится 
  ли такой подход “истинным ООП”, оставим для теоретиков. На самом 
  деле, даже <a name="Index411"></a>Smalltalk имеет аналог среди своих “методов 
  класса”.</font><a name="_Toc375545281"></a><a name="_Toc481064576"></a></p>
<a name="Heading173"></a><font face="Verdana">
<h2 align="left"> Очистка: финализация и сборщик мусора</h2>
</font> 
<p><font face="Georgia">Программисты знают о важности инициализации, но часто 
  забывают о важности очистки. Помимо всего, кому понадобится очищать значения, 
  типа <b>int</b>? Но с библиотеками, просто “позволить идти своей дорогой” 
  тем объектам, с которыми вы закончили работать не всегда безопасно. Конечно, 
  Java имеет <a name="Index412"></a>сборщик мусора для освобождения памяти объектов, 
  которые более не используются. Теперь об очень редком случае. Предположим, что 
  ваш объект зарезервировал “специальную” память, не используя <a name="Index413"></a><b>new</b>. 
  Сборщик мусора знает только, как освобождать память, выделенную <i>с помощью</i> 
  <b>new</b>, так что он не может освободить “специальную” память 
  объектов. Для обработки этого случая Java обеспечивает метод, называемый <a name="Index414"></a><b>finalize(&nbsp;)</b>, 
  который вы можете определить в своем классе. Вот как это <i>должно</i> работать. 
  Когда сборщик мусора готов освободить хранилище, используемое вашим объектом, 
  он сначала вызовет <b>finalize(&nbsp;)</b>, а только на следующем этапе сборки 
  мусора он освободит память объекта. Так что, если вы выбрали использование <b>finalize(&nbsp;)</b>, 
  это даст вам возможность выполнить некоторые важные для очистки операции <i>во 
  время сборки мусора</i>.</font></p>
<p><font face="Georgia">Это потенциальная ловушка программистам, так как некоторые 
  из них, особенно программисты на C++, могут ошибочно полагать, что <b>finalize(&nbsp;)</b> 
  аналогично <a name="Index415"></a><i>деструкторам</i> в C++, которые являются 
  функциями, которые всегда вызываются при разрушении объекта. Но в этом заключается 
  важное различие между C++ и Java, потому что в C++ <i>объекты всегда разрушаются</i> 
  (в программах без ошибок), в то время как в Java объекты не всегда попадают 
  под сборку мусора. Или, говоря другими словами:</font></p>
<p><font face="Georgia" size="4">Сборка мусора - это не разрушение.</font></p>
<p><font face="Georgia">Если вы запомните это, вы не встретите трудностей. Это 
  означает, что если есть какие-то действия, которые необходимо выполнить прежде, 
  чем вы закончите работать с объектом, вы должны выполнить эти действия самостоятельно. 
  Java не имеет деструкторов или аналогичной концепции, так что вы должны создать 
  обычный метод для выполнения этой очистки. Например, предположим, что в процессе 
  создания вашего объекта он рисует себя на экране. Если вы явно не вызовите стирание 
  этого изображения с экрана, оно может никогда не очистится. Если вы помещаете 
  некоторое стирание внутри функции <b>finalize(&nbsp;)</b>, то если объект подвергнется 
  сборке мусора, изображение сначала будет стерто с экрана, но если этого не произойдет, 
  то изображение останется. Так что второе, что вы должны запомнить:</font></p>
<p><font face="Georgia" size="4">Ваши объекты могут не подвергнуться сборке мусора.</font></p>
<p><font face="Georgia">Вы можете обнаружить, что хранилище никогда не освобождается, 
  потому что ваша программа никогда не приближается к точке переполнения хранилища. 
  Если ваша программа завершена, и сборщик мусора ни разу не приступил к освобождению 
  хранилища для любого из ваших объектов, то хранилище будет возвращено операционной 
  системе целиком после завершения программы. Это хорошо, потому что сбор мусора 
  приводит к дополнительным накладным расходам, и если вы никогда не достигаете 
  этого, ваши затраты никогда не увеличиваются.</font><a name="_Toc375545282"></a><a name="_Toc481064577"></a></p>
<a name="Heading174"></a><font face="Verdana">
<h3 align="left"> Для чего нужен finalize(&nbsp;)?</h3>
</font>
<p><font face="Georgia">После всего изложенного выше вы можете предположить, что 
  вы не должны использовать <b>finalize(&nbsp;)</b> в целях очистки общего назначения. 
  Насколько это хорошо?</font></p>
<p><font face="Georgia">Третье, что вы должны помнить:</font></p>
<p><font face="Georgia" size="4">Сборка мусора относится только к памяти.</font></p>
<p><font face="Georgia">То есть, главная причина существования сборщика мусора 
  состоит в освобождении памяти, которую ваша программа более не использует. Таким 
  образом, любые действия, которые ассоциируются со сборкой мусора, больше всего 
  подходят для вашего метода <b>finalize(&nbsp;)</b>, и должны относится только 
  к памяти и ее освобождению.</font></p>
<p><font face="Georgia">Значит ли это, что если ваш объект содержит другие объекты, 
  <b>finalize(&nbsp;)</b> должен явно освободить эти объекты? Нет, сборщик мусора 
  позаботится об освобождении памяти всех объектов, независимо от того, как были 
  созданы объекты. Оказывается, что потребность в <b>finalize(&nbsp;)</b> ограничивается 
  особыми случаями, в которых объекты могут резервировать некоторое хранилище 
  другим способом, отличным от создания объектов. Но, вы можете заметить, что 
  все в Java - это объекты. Как же такое может быть?</font></p>
<p><font face="Georgia">Таким образом, <b>finalize(&nbsp;)</b> занимает свое место, 
  потому что существует возможность, что вы выполнили подобное C резервирование 
  памяти, используя механизм, отличный от естественного для Java. Это может произойти, 
  в основном, в родных методах, которые являются способом вызова не Java кода 
  из Java. (Родные методы обсуждаются в <a href=" AppendixB.html">Приложении B</a>.) 
  C и C++ являются теми языками, которые в настоящее время поддерживаются родными 
  методам, но так как они могут вызывать подпрограммы других языков, вы можете, 
  на самом деле, вызвать все, что угодно. Внутри не Java кода семейство функций 
  <b>malloc(&nbsp;)</b> из C может быть вызвано для резервирования хранилища, 
  и до тех пор, пока вы не вызовите <b>free(&nbsp;)</b>, это хранилище не будет 
  освобождено, что приводит к утечке памяти. Конечно, <b>free(&nbsp;)</b> является 
  функцией C и C++, так что вам необходимо вызывать ее в родном методе внутри 
  вашего <b>finalize(&nbsp;)</b>.</font></p>
<p><font face="Georgia">После того, что вы прочли, вы, вероятно, пришли к мысли, 
  что вам чаще всего не нужно использовать <b>finalize(&nbsp;)</b>. Вы правы; 
  это не подходящее место для выполнения обычной очистки. Тогда где должна выполнятся 
  обычная очистка?</font><a name="_Toc312373857"></a><a name="_Toc375545283"></a><a name="_Toc481064578"></a></p>
<div align="left"></div>
<a name="Heading175"></a><font face="Verdana">
<h3 align="left"> Вы должны выполнять очистку</h3>
</font> 
<p><font face="Georgia">Для очистки объекта пользователь этого объекта должен 
  вызвать <a name="Index416"></a>метод очистки в том месте, где это не обходимо. 
  Эти слова хорошо понятны, но это приводит к концепции <a name="Index417"></a>деструктора 
  из C++, что все объекты разрушаются. Или вернее, что все объекты должны разрушаться. 
  Если объекты C++ создаются локально (т.е. в стеке, что невозможно в Java), то 
  разрушение происходит в месте закрытия фигурной скобки того блока, в котором 
  объект был создан. Если объект был создан с помощью <b>new</b> (как в Java), 
  деструктор вызывается, когда программист вызовет оператор <b>delete</b> из C++ 
  (который не существует в Java). Если программист C++ забудет вызвать <b>delete</b>, 
  деструктор никогда не вызовется, и вы получите утечку памяти, в сочетании со 
  всеми другими прелестями отсутствия очистки объектов. Этот род ошибок могут 
  быть очень трудными в обнаружении.</font></p>
<p> <font face="Georgia">В противоположность этому, Java не позволяет создание 
  локальных объектов — вы всегда должны использовать <b>new</b>. Но в Java 
  нет “delete” для выполнения освобождения объекта, так как сборщик 
  мусора освобождает хранилище за вас. Так что, с точки зрения простоты, вы могли 
  бы сказать, что по причине сборки мусора Java не имеет деструкторов. Однако 
  в процессе чтения книги вы увидите, что присутствие <a name="Index418"></a>сборщика 
  мусора не снимает требования в существовании таких средств, как деструкторы. 
  (И вы никогда не должны вызывать <a name="Index419"></a><b>finalize(&nbsp;)</b> 
  напрямую, так что это не подходящий путь для решения.) Если вы некоторый род 
  очистки выполняет освобождение других ресурсов, отличных от хранилища, вы должны 
  <i>все-таки</i> явно вызвать соответствующий метод Java, который является эквивалентом 
  деструктора C++, без каких-либо соглашений.</font></p>
<p><font face="Georgia">Одна из вещей, для которых <b>finalize(&nbsp;)</b> может 
  быть полезна, это наблюдение за процессом сборки мусора. Следующий пример показывает 
  вам, что происходит и подводит итог предыдущего описания сборки мусора:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:Garbage.java</font>
<font color="#009900">// Демонстрация сборщика мусора</font>
<font color="#009900">// и финализации</font>

<font color="#0000ff">class</font> Chair {
  <font color="#0000ff">static</font> <font color="#0000ff">boolean</font> gcrun = <font color="#0000ff">false</font>;
  <font color="#0000ff">static</font> <font color="#0000ff">boolean</font> f = <font color="#0000ff">false</font>;
  <font color="#0000ff">static</font> <font color="#0000ff">int</font> created = 0;
  <font color="#0000ff">static</font> <font color="#0000ff">int</font> finalized = 0;
  <font color="#0000ff">int</font> i;
  Chair() {
    i = ++created;
    <font color="#0000ff">if</font>(created == 47) 
      System.out.println(<font color="#004488">"Created 47"</font>);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> finalize() {
    <font color="#0000ff">if</font>(!gcrun) {
      <font color="#009900">// Первый раз вызывается finalize():</font>
      gcrun = <font color="#0000ff">true</font>;
      System.out.println(
        <font color="#004488">"Beginning to finalize after "</font> +
        created + <font color="#004488">" Chairs have been created"</font>);
    }
    <font color="#0000ff">if</font>(i == 47) {
      System.out.println(
        <font color="#004488">"Finalizing Chair #47, "</font> +
        <font color="#004488">"Setting flag to stop Chair creation"</font>);
      f = <font color="#0000ff">true</font>;
    }
    finalized++;
    <font color="#0000ff">if</font>(finalized &gt;= created)
      System.out.println(
        <font color="#004488">"All "</font> + finalized + <font color="#004488">" finalized"</font>);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Garbage {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#009900">// До тех пор, пока флаг не установлен,</font>
    <font color="#009900">// создаются Chairs и Strings:</font>
    <font color="#0000ff">while</font>(!Chair.f) {
      <font color="#0000ff">new</font> Chair();
      <font color="#0000ff">new</font> String(<font color="#004488">"To take up space"</font>);
    }
    System.out.println(
      <font color="#004488">"After all Chairs have been created:\n"</font> +
      <font color="#004488">"total created = "</font> + Chair.created +
      <font color="#004488">", total finalized = "</font> + Chair.finalized);
    <font color="#009900">// Необязательные аргументы форсируют</font>
    <font color="#009900">// сборку мусора и финализацию</font>
    <font color="#0000ff">if</font>(args.length &gt; 0) {
      <font color="#0000ff">if</font>(args[0].equals(<font color="#004488">"gc"</font>) || 
         args[0].equals(<font color="#004488">"all"</font>)) {
        System.out.println(<font color="#004488">"gc():"</font>);
        System.gc();
      }
      <font color="#0000ff">if</font>(args[0].equals(<font color="#004488">"finalize"</font>) || 
         args[0].equals(<font color="#004488">"all"</font>)) {
        System.out.println(<font color="#004488">"runFinalization():"</font>);
        System.runFinalization();
      }
    }
    System.out.println(<font color="#004488">"bye!"</font>);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Приведенная выше программа создает множество объектов 
  <b>Chair</b>, и в некоторой точке, после начала работы сборщика мусора, программа 
  прекращает создание <b>Chair</b>. Так как сборщик мусора может запуститься в 
  любой момент, вы не можете точно знать, когда он стартует, поэтому есть флаг, 
  называемый <b>gcrun</b> для индикации того, произошел ли запуск сборщика мусора. 
  Второй флаг <b>f</b> дает возможность объекту <b>Chair</b> сообщить в цикл <b>main(&nbsp;)</b>, 
  что он должен остановить создание объектов. Оба эти флага устанавливаются в 
  <b>finalize(&nbsp;)</b>, который вызывается при сборке мусора.</font></p>
<p><font face="Georgia">Две другие <b>static</b> переменные: <b>created</b> и 
  <b>finalized</b>, следят за числом созданных <b>Chair</b> и за числом объектов, 
  подвергшихся финализации сборщиком мусора. И, наконец, каждый <b>Chair</b> имеет 
  свой собственный (не-<b>static</b>) <b>int</b> <b>i</b>, который следит за тем, 
  какой порядковый номер имеет объект. Когда финилизируется <b>Chair</b> с номером 
  47, флаг устанавливается в <b>true</b>, чтобы инициировать остановку процесса 
  создания <b>Chair</b>.</font></p>
<div align="left"></div>
<p><font face="Georgia">Все это происходит в цикле <b>main(&nbsp;)</b></font></p>
<blockquote><font size="+1"><pre>    <font color="#0000ff">while</font>(!Chair.f) {
      <font color="#0000ff">new</font> Chair();
      <font color="#0000ff">new</font> String(<font color="#004488">"To take up space"</font>);
    }</pre></font></blockquote>
<p><font face="Georgia">Вы можете удивиться, как этот цикл вообще может завершиться, 
  так как внутри нет ничего, что изменяло бы значение <b>Chair.f</b>. Однако <b>finalize(&nbsp;)</b>, 
  в конечном счете, сделает это, когда будет финализован объект номер 47.</font></p>
<p><font face="Georgia">Создание объекта <b>String</b> в каждой итерации просто 
  приводит к дополнительному выделению места для ускорения запуска сборщика мусора, 
  который начнет действовать, когда будет озабочен количеством доступной памяти.</font></p>
<p><font face="Georgia">Когда вы запускаете программу, вы передаете аргумент командной 
  строки “gc,” “finalize,” или “all”. Аргумент 
  “gc” приведет к вызову метода <b>System.gc(&nbsp;)<a name="Index420"></a></b> 
  (для форсирования работы сборщика мусора). Использование “finalize” 
  приведет к вызову <b>System.runFinalization(&nbsp;)<a name="Index421"></a></b>, 
  который, теоретически, является причиной того, что не финализированные объекты 
  будут финализированы. А “all” станет причиной вызова обоих методов.</font></p>
<p><font face="Georgia">Поведение этой программы в версии первой редакции этой 
  книги показывает, что все проблемы сборки мусора и финализации эволюционировали, 
  и большинство эволюции произошло за закрытыми дверями. Фактически, в то время, 
  когда вы читаете это, поведение программы может снова изменится.</font></p>
<p><font face="Georgia">Если вызван <b>System.gc(&nbsp;)</b>, то финализация происходит 
  для всех объектов. Это не было необходимо с предыдущей реализацией JDK, хотя 
  документация заявляла обратное. Кроме того, вы увидите, что кажется, что нет 
  каких-то различий, произошел ли вызов <b>System.runFinalization(&nbsp;).</b></font></p>
<p><font face="Georgia">Однако вы увидите, что если <b>System.gc(&nbsp;)</b> вызывается 
  после того, как все объекты будут созданы и работа с ними будет завершена, то 
  будут вызваны все методы финализации. Если вы не вызываете <b>System.gc(&nbsp;)</b>, 
  то только некоторые из объектов будут финализированы. В Java 1.1 метод <b>System.runFinalizersOnExit(&nbsp;)</b> 
  был введен, чтобы являться причиной, заставляющей запускать всех методов финализации 
  при выходе из программы, но при этом в дизайне появлялось много ошибок, поэтому 
  метод устарел и был заменен. Это дает представление о том, какие искания предпринимали 
  разработчики Java в попытках решить проблемы сбора мусора и финализации. Мы 
  можем только надеяться, что эти вещи достаточно хорошо разработаны в Java 2.</font></p>
<p><font face="Georgia">Предыдущая программа показывает, что обещание, что все 
  финализации всегда выполняются, справедлива только, если вы явно навязываете, 
  чтобы это происходило. Если вы не вызываете <b>System.gc(&nbsp;)</b>, на выходе 
  вы получите примерно следующее:</font></p>
<blockquote><font size="+1"><pre>Created 47
Beginning to finalize after 3486 Chairs have been created
Finalizing Chair #47, Setting flag to stop Chair creation
After all Chairs have been created:
total created = 3881, total finalized = 2684
bye!</pre></font></blockquote>
<p><font face="Georgia">Таким образом, не все финализации вызываются до того, 
  как программа завершится. Если вызван <b>System.gc(&nbsp;)</b>, это приведет 
  к финализации и разрушению всех объектов, которые более не используются в этот 
  момент.</font></p>
<p><font face="Georgia">Помните, что ни сборка мусора, ни финализация не гарантирована. 
  Если Виртуальная Java Машина (JVM) не приближается к переполнению памяти, то 
  она (что очень мудро) не тратит время на освобождение памяти с помощью сборки 
  мусора.</font><a name="_Toc481064579"></a></p>
<div align="left"></div>
<a name="Heading176"></a><font face="Verdana">
<h3 align="left"> Смертельное состояние<a name="Index422"></a></h3>
</font> 
<p><font face="Georgia"> <a name="Index423"></a>В общем случае вы не можете полагаться 
  на вызов <b>finalize(&nbsp;)</b>, и вы должны создавать другую функцию “очистки” 
  и явно вызывать ее. Это означает, что <b>finalize(&nbsp;)</b> полезен только 
  для задач очистки памяти, которые большинство программистов чаще всего не используют. 
  Однако есть очень интересное использование <b>finalize(&nbsp;)</b>, при котором 
  не предполагается, что метод вызывается каждый раз. Это проверка <i>состояния 
  смерти</i> <a href="#fn29">[29]</a> объекта.</font></p>
<p><font face="Georgia">В том месте, где вы более не интересуетесь объектом — 
  когда он готов к тому, чтобы быть очищенным — такой объект должен быть 
  в том состоянии, когда его память может быть безопасно освобождена. Например, 
  если объект представляет собой открытый файл, то файл должен быть закрыт программистом 
  прежде, чем объект подвергнется сборке мусора. Если любая часть объекта неправильно 
  очищена, то вы получите ошибку в вашей программе, которую будет очень трудно 
  обнаружить. Значение <b>finalize(&nbsp;)</b> в том, что он может быть использован 
  для определения такого состояния, даже если он еще не был вызван. Если срабатывает 
  одна из финализаций, выявляя ошибку, то вы обнаруживаете проблему, о которой 
  вы всегда можете позаботиться.</font></p>
<p><font face="Georgia">Вот простой пример, который вы можете использовать:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:DeathCondition.java</font>
<font color="#009900">// Использование finalize() для обнаружения объекта,</font>
<font color="#009900">// который не был правильно очищен.</font>

<font color="#0000ff">class</font> Book {
  <font color="#0000ff">boolean</font> checkedOut = <font color="#0000ff">false</font>;
  Book(<font color="#0000ff">boolean</font> checkOut) { 
    checkedOut = checkOut; 
  }
  <font color="#0000ff">void</font> checkIn() {
    checkedOut = <font color="#0000ff">false</font>;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> finalize() {
    <font color="#0000ff">if</font>(checkedOut)
      System.out.println(<font color="#004488">"Error: checked out"</font>);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> DeathCondition {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Book novel = <font color="#0000ff">new</font> Book(<font color="#0000ff">true</font>);
    <font color="#009900">// Правильная очистка:</font>
    novel.checkIn();
    <font color="#009900">// Бросаем ссылку, забываем очистить:</font>
    <font color="#0000ff">new</font> Book(<font color="#0000ff">true</font>);
    <font color="#009900">// Форсируем сбор мусора и финализацию:</font>
    System.gc();
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Состояние смерти состоит в том, что предполагается, что 
  все объекты <b>Book</b> проверяются перед сборкой мусора, но в <b>main(&nbsp;)</b> 
  программист не выполняет ни один из объектов. Без <b>finalize(&nbsp;)</b> с 
  проверкой состояния смерти было бы трудно обнаружить ошибку.</font></p>
<p><font face="Georgia">Обратите внимание, что <b>System.gc(&nbsp;)</b> используется 
  для форсирования финализации (и должно выполнятся во время разработке программы 
  для ускорения отладки). Но даже если это не так, то есть высокая вероятность 
  того, что блуждающий <b>Book</b> будет обязательно обнаружен при повторных запусках 
  программы (имеется в виду, что программа занимает достаточно места, что является 
  причиной запуска сборщика мусора).</font><a name="_Toc481064580"></a></p>
<a name="Heading177"></a><font face="Verdana">
<h3 align="left"> Как работает сборщик мусора<a name="Index424"></a></h3>
</font>
<p><font face="Georgia">Если вы переключились с языка, в котором резервирование 
  объектов в куче очень дорого, вы можете предположить, что схема Java, в которой 
  все резервируется (за исключением примитивных типов) в куче - очень дорогая. 
  Однако это означает, что сборщик мусора может значительно повлиять на увеличение 
  скорости создания объектов. Сначала это может казаться преимуществом, что освобождение 
  хранилища влияет на резервирование хранилища, но это тот способ, которым работают 
  некоторые JVM, и это означает, что резервирование места в куче для объектов 
  в Java мажет выполняться так же быстро, как и создание хранилища в стеке в других 
  языках.</font></p>
<p><font face="Georgia">Например, вы можете думать о куче C++, как о загоне, в 
  котором каждый объект содержится на своем участке площади. Это реальное положение 
  позже было отброшено, и должно использоваться вновь. В некоторых JVM куча Java 
  слегка отличается; она немного похожа на ленту конвейера, которая перемещается 
  вперед всякий раз, когда вы резервируете новый объект. Это означает, что выделение 
  хранилища для нового объекта происходит удивительно быстро. “Указатель 
  кучи” просто перемещается вперед на не тронутую территорию, так что этот 
  процесс по эффективности приближается к операциям со стеком в C++ (конечно в 
  этом есть небольшой дополнительный расход на двойную бухгалтерию, но это ничто 
  по сравнению с поиском хранилища).</font></p>
<p><font face="Georgia">Теперь вы можете заметить, что куча, фактически, не является 
  лентой конвейера, и если вы трактуете ее таким образом, в конечном счете станете 
  разбивать память на страницы (что советуется для увеличения производительности). 
  Хитрость в том, что когда сборщик мусора выступает на сцену, и пока он собирает 
  мусор, он компонует все объекты в куче так, что вы получаете реальное перемещение 
  “указателя кучи” ближе к началу ленты конвейера, что предотвращает 
  переполнение страницы. Сборщик мусора заново упорядочивает вещи и делает возможным 
  использование модели высокоскоростной, постоянно свободной кучи для выделения 
  хранилища.</font></p>
<p>Чтобы понять, как это работает, вам необходимо получить лучшее представление 
  о различиях в схемах работы сборщиков мусора (СМ). Простая, но медленная техника 
  СМ - это подсчет ссылок. Это означает, что каждый объект содержит счетчик ссылок, 
  и при каждом присоединении ссылки к объекту, счетчик увеличивается. При каждом 
  удалении ссылки из блока или установки ее в <font face="Georgia"><b>null</b>, 
  счетчик ссылок уменьшается. Таким образом, управление ссылками мало, но содержит 
  накладные расходы, которые возникают на протяжении всего времени работы вашей 
  программы. Сборщик мусора обходит весь список объектов, и когда находит объект, 
  у которого счетчик ссылок равен нулю, освобождает это хранилище. Один из недостатков 
  состоит в том, что если объект ссылается сам на себя, он может иметь не нулевой 
  счетчик ссылок в то время, когда он может быть собран. Обнаружение таких самоссылающихся 
  групп требует значительной дополнительной работы от сборщика мусора. Подсчет 
  ссылок часто используется для объяснения одного из видов сбора мусора, но он 
  не выглядит подходящим для реализации в любой JVM.</font></p>
<p><font face="Georgia">В быстрых схемах сбор мусора не основывается на подсчете 
  ссылок. Вместо этого он основывается на идее того, что любой живой объект должен 
  обязательно прослеживаться в обратном направлении к ссылке, которая расположена 
  либо в стеке, либо в статическом хранилище. Цепочка может тянуться через несколько 
  уровней объектов. Таким образом, если вы начнете в стеке и статическом хранилище, 
  и пройдете по всем ссылкам, вы найдете все живые объекты. Для каждой ссылки, 
  которую вы найдете, вы должны найти соответствующий объект, на который указывает 
  <i>эта</i> ссылка, а затем проследить все ссылки этого объекта, далее проследить 
  все ссылки тех объектов и т.д., пока вы не пройдете по всей паутине, тянущейся 
  за ссылкой из стека или статического хранилища. Каждый объект, который вы просматриваете, 
  должен быть живым. Обратите внимание, что нет проблем с определением самоссылающихся 
  групп, они просто не будут найдены, и поэтому собираются автоматически.</font></p>
<p><font face="Georgia">В описанном здесь подходе JVM использует <i>адаптивную</i> 
  схему сбора мусора, а то, что она делает с живыми объектами - это обнаруживает 
  зависимости от вариантов использования. Один из этих вариантов - это остановись-и-копируй. 
  Это означает, что — по некоторым причинам, которые вы увидите — 
  программа сначала останавливается (эта схема не относится к фоновым). Затем, 
  каждый найденный живой объект копируется из одной кучи в другую. То что осталось, 
  собирается. Кроме того, когда объекты копируются в новую кучу, они упаковываются 
  один к одному, таким образом, упаковывается новая куча (что позволяет быстро 
  распутать новое хранилище до конца, как описано выше).</font></p>
<p><font face="Georgia">Конечно, когда объект перемещается из одного места в другое, 
  все ссылки, которые указывают на этот объект, должны быть изменены. Ссылки, 
  которые привели из кучи или статического хранилища к этому объекту также могут 
  изменится, но здесь могут быть и другие ссылки, указывающие на этот объект, 
  которые будут обнаружены позднее, во время обхода. Они будут фиксироваться при 
  обнаружении (вы можете представить себе таблицу, которая ставит в соответствие 
  старые адреса и новые).</font></p>
<p><font face="Georgia">Есть две проблемы, которые делают этот так называемый 
  “копирующий сборщик” не эффективным. Первая заключается в том, что 
  вы имеете две кучи, и вы пересыпаете всю память вперед и назад между этими двумя 
  различными кучами, занимая в два раза больше памяти, чем вам нужно на самом 
  деле. Некоторые JVM делают это с помощью резервирования кучу частями, сколько 
  нужно, а потом просто копируют из одного куска в другой.</font></p>
<p><font face="Georgia">Вторая проблема в копировании. Как только ваша программа 
  стабилизируется, она будет генерировать мало мусора, или не генерировать его 
  вообще. Несмотря на это копирующий сборщик будет копировать всю память из одного 
  места в другое, что не экономично. Чтобы предотвратить это, некоторые JVM определяют, 
  что не было сгенерировано нового мусора, и переключаются на другую схему (это 
  “адаптивная” часть). Эта другая схема называется <i>пометка и уборка</i>. 
  Эта схема была реализована в ранних версиях JVM от Sun и использовалась все 
  время. Для общего использования, пометка и уборка достаточно медленна, но когда 
  вы знаете, что генерируете мало мусора, или не генерируете его вообще, она быстра.</font></p>
<p><font face="Georgia">Пометка и уборка следует то же логике, начиная со стека 
  и статического хранилища, и исследует все ссылки, найденные в живых объектах. 
  Однако, при каждом нахождении живого объекта, происходит пометка объекта флагом, 
  что объект еще не может быть собран. Только когда процесс пометки закончен, 
  происходит уборка. Во время уборки мертвые объекты освобождаются. Однако не 
  происходит копирования, так что если сборщик хочет уплотнить кучу, он делает 
  это, сдвигая объекты.</font></p>
<p><font face="Georgia"> “Остановка-и-копирование” обращаются к идее 
  того, что этот тип сборки мусора <i>не</i> выполняется в фоновом режиме; вместо 
  этого программа останавливается, пока работает СМ. В литературе от Sun вы найдете 
  много ссылок на сборку мусора, как на низкоприоритетный фоновый процесс, но 
  это означает, что СМ не реализует этот способ, по крайней мере, в ранних версиях 
  Sun JVM. Вместо этого сборщик мусора Sun запускается, когда памяти становится 
  мало. Кроме того, пометка-и-уборка требует, чтобы программа остановилась.</font></p>
<p><font face="Georgia">Как упоминалось ранее, в описанной здесь JVM память резервируется 
  большими блоками. Если вы резервируете большой объект, он получает свой собственный 
  блок. Строгие правила остановки-и-копирования требуют копирования каждого живого 
  объекта из исходной кучи в новую до того, как вы сможете освободить старую, 
  что занимает много памяти. С блоками, СМ может обычно использовать мертвые блоки 
  для копирования объектов, когда они будут собраны. Каждый блок имеет <i>счет 
  генерации</i>, для слежения, жив ли он. В обычном случае создаются только блоки, 
  так как СМ производит компактное расположение; все другие блоки получают увеличение 
  своего счета генерации, указывающее, что на них есть ссылка откуда-либо. Это 
  обработка обычного случая большинства временных объектов с коротким временем 
  жизни. Периодически производится полная уборка — большие объекты все еще 
  не копируются (просто получают увеличения счета генерации), а блоки, содержащие 
  маленькие объекты, копируются и уплотняются. JVM следит за эффективностью СМ, 
  и если она становится расточительной относительно времени, поскольку все объекты 
  являются долгожителями, то она переключается на пометку-и-уборку. Аналогично, 
  JVM следит, насколько успешна пометка-и-уборка, и, если куча становится слишком 
  фрагментирована, вновь переключается на остановку-и-копирование. Это то, что 
  составляет “адаптивную” часть, так что в завершении можно сказать 
  труднопроизносимую фразу: “адаптивность генерирует остановку-и-копирование 
  с пометкой-и-уборкой”.</font></p>
<p><font face="Georgia">Есть несколько дополнительный возможностей ускорения в 
  JVM. Особенно важно включение операции загрузчика и Just-In-Time (JIT) компилятора. 
  Когда класс должен быть загружен (обычно перед тем, как вы хотите создать объект 
  этого класса), происходит поиск <b>.class</b> файла и байт-код для класса переносится 
  в память. В этом месте один из подходов - упростит JIT весь код, но здесь есть 
  два недостатка: это займет немного больше времени, что отразится на продолжительности 
  работы программы, увеличив ее, и это увеличит размер выполнения (байт-код значительно 
  компактнее, чем расширенный JIT-код), а это приведет к разбиению на страницы, 
  которые значительно замедлят программу. Альтернативой является ленивое вычисление, 
  что означает, что код не является JIT-компилированные, если это ненужно. Таким 
  образом, код, который никогда не выполняется, никогда не будет компилироваться 
  JIT.</font><a name="_Toc375545284"></a><a name="_Toc481064581"></a></p>
<div align="left"></div>
<a name="Heading178"></a><font face="Verdana">
<h2 align="left"> Инициализация членов</h2>
</font>
<p><font face="Georgia">Java идет своей дорогой и гарантирует правильную инициализацию 
  переменных перед использованием. В случае определения локальных переменных метода 
  эта гарантия проистекает из получения ошибки компиляции. Так что, если вы запишите:</font></p>
<blockquote><font size="+1"><pre>  <font color="#0000ff">void</font> f() {
    <font color="#0000ff">int</font> i;
    i++;
  }</pre></font></blockquote>
<p><font face="Georgia">вы получите сообщение об ошибке, которое скажет, что возможно, 
  что <b>i</b> не инициализирована. Конечно, компилятор мог бы дать <b>i</b> значение 
  по умолчанию, но это больше похоже на ошибку программиста, а значение по умолчанию 
  может ее скрыть. Заставлять программиста выполнять инициализацию лучше с точки 
  зрения нахождения ошибок.</font><font face="Georgia"><a name="Index425"></a><a name="Index426"></a><a name="Index427"></a></font></p>
<p><font face="Georgia">Однако если <a name="Index428"></a><a name="Index429"></a><a name="Index430"></a>примитивный 
  тип является членом-данным класса, происходящее немного отличается. Так как 
  любой метод может инициализировать или использовать данные, становится не практично 
  заставлять пользователя инициализировать их соответствующим значением перед 
  использованием. Однако также не безопасно оставлять их, заполненными всяким 
  мусором, так как каждая переменная - член класса примитивного типа гарантированно 
  получает инициализирующее значение. Эти значения можно посмотреть здесь:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:InitialValues.java</font>
<font color="#009900">// Показываются значения инициализации по умолчанию.</font>

<font color="#0000ff">class</font> Measurement {
  <font color="#0000ff">boolean</font> t;
  <font color="#0000ff">char</font> c;
  <font color="#0000ff">byte</font> b;
  <font color="#0000ff">short</font> s;
  <font color="#0000ff">int</font> i;
  <font color="#0000ff">long</font> l;
  <font color="#0000ff">float</font> f;
  <font color="#0000ff">double</font> d;
  <font color="#0000ff">void</font> print() {
    System.out.println(
      <font color="#004488">"Data type      Initial value\n"</font> +
      <font color="#004488">"boolean        "</font> + t + <font color="#004488">"\n"</font> +
      <font color="#004488">"char           ["</font> + c + <font color="#004488">"] "</font>+ (<font color="#0000ff">int</font>)c +<font color="#004488">"\n"</font>+
      <font color="#004488">"byte           "</font> + b + <font color="#004488">"\n"</font> +
      <font color="#004488">"short          "</font> + s + <font color="#004488">"\n"</font> +
      <font color="#004488">"int            "</font> + i + <font color="#004488">"\n"</font> +
      <font color="#004488">"long           "</font> + l + <font color="#004488">"\n"</font> +
      <font color="#004488">"float          "</font> + f + <font color="#004488">"\n"</font> +
      <font color="#004488">"double         "</font> + d);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> InitialValues {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Measurement d = <font color="#0000ff">new</font> Measurement();
    d.print();
    <font color="#009900">/* В этом случае вы также можете сказать:
    new Measurement().print();
    */</font>
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Вот что программа печатает на выходе:</font></p>
<blockquote><font size="+1"><pre>Data type      Initial value
<font color="#0000ff">boolean</font>        <font color="#0000ff">false</font>
<font color="#0000ff">char</font>           [ ] 0
<font color="#0000ff">byte</font>           0
<font color="#0000ff">short</font>          0
<font color="#0000ff">int</font>            0
<font color="#0000ff">long</font>           0
<font color="#0000ff">float</font>          0.0
<font color="#0000ff">double</font>         0.0</pre></font></blockquote>
<p><font face="Georgia">Значение <b>char</b> - это ноль, который печатается как 
  пробел.</font></p>
<p><font face="Georgia">Позже вы увидите, что когда вы определяете ссылку на объект 
  внутри класса и инициализируете ее новым объектом, эта ссылка получает специальное 
  значение <b>null</b> (которое является ключевым словом Java).</font></p>
<p><font face="Georgia">Вы видите, что даже если значения не указаны, они автоматически 
  инициализируются. Таким образом, нет трудностей при работе с не инициализированными 
  переменными.</font><a name="_Toc375545285"></a><a name="_Toc481064582"></a></p>
<div align="left"></div>
<a name="Heading179"></a><font face="Verdana">
<h3 align="left"> Указание инициализации</h3>
</font>
<p><font face="Georgia">Что произойдет, если вы захотите присвоить переменной 
  начальное значение? Один прямой способ сделать это - это просто присвоить значение 
  в точке определения переменной в классе. (Обратите внимание, что вы не можете 
  сделать это в C++, хотя C++ всегда пробует все новое.) Вот определение полей 
  в классе <b>Measurement</b>, который изменен для обеспечения начальных значений:<a name="Index431"></a><a name="Index432"></a></font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">class</font> Measurement {
  <font color="#0000ff">boolean</font> b = <font color="#0000ff">true</font>;
  <font color="#0000ff">char</font> c = 'x';
  <font color="#0000ff">byte</font> B = 47;
  <font color="#0000ff">short</font> s = 0xff;
  <font color="#0000ff">int</font> i = 999;
  <font color="#0000ff">long</font> l = 1;
  <font color="#0000ff">float</font> f = 3.14f;
  <font color="#0000ff">double</font> d = 3.14159;
  <font color="#009900">//. . .</font></pre></font></blockquote>
<p><font face="Georgia">Вы также можете инициализировать не примитивные объекты 
  таким же способом. Если <b>Depth</b> - это класс, вы можете вставить переменную 
  и инициализировать ее следующим образом:</font></p>
<blockquote><font size="+1"></font><pre><font size="+1"><font color="#0000ff">class</font> Measurement {
  Depth o = <font color="#0000ff">new</font> Depth();
  <font color="#0000ff">boolean</font> b = <font color="#0000ff">true</font>;
  <font color="#009900">// . . .</font></font></pre></blockquote>
<p><font face="Georgia">Если вы не передадите <b>o</b> начальное значение и, тем 
  не менее, попробуете использовать ее, вы получите ошибку времени выполнения, 
  называемую <i>исключением</i> (это описано в <a href=" Chapter10.html">Главе 
  10</a>).</font></p>
<p><font face="Georgia">Вы даже можете вызвать метод для обеспечения начального 
  значения:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">class</font> CInit {
  <font color="#0000ff">int</font> i = f();
  <font color="#009900">//...</font>
}</pre></font></blockquote>
<p><font face="Georgia">Конечно, этот метод может иметь аргументы, но эти аргументы 
  не могут быть другими членами класса, которые еще не инициализированы. Таким 
  образом, вы можете сделать так:</font></p>
<blockquote><font size="+1">
  <pre><font color="#0000ff">class</font> CInit {
  <font color="#0000ff">int</font> i = f();
  <font color="#0000ff">int</font> j = g(i);
  <font color="#009900">//...</font>
}</pre>
  </font></blockquote>
<p><font face="Georgia">Но вы не можете сделать этого:</font></p>
<blockquote><font size="+1"></font><pre><font size="+1"><font color="#0000ff">class</font> CInit {
  <font color="#0000ff">int</font> j = g(i);
  <font color="#0000ff">int</font> i = f();
  <font color="#009900">//...</font>
}</font></pre></blockquote>
<p><font face="Georgia">Это одно из тех мест, когда компилятор <i>выразит</i> 
  недовольство по поводу <a name="Index433"></a><a name="Index434"></a>забегающей 
  ссылки, так как здесь имеем дело с порядком инициализации, и нет способа откомпилировать 
  такую программу.</font></p>
<p><font face="Georgia">Такой подход к инициализации прост и понятен. Он имеет 
  ограничения в том, что <i>каждый</i> объект типа <b>Measurement</b> будет иметь 
  одни и те же начальные значения. Иногда это именно то, что вам нужно, но в другое 
  время вам нужна большая гибкость.</font><a name="_Toc375545286"></a><a name="_Toc481064583"></a></p>
<a name="Heading180"></a><font face="Verdana">
<h3 align="left"> Инициализация в конструкторе</h3>
</font>
<p><font face="Georgia">Конструктор может быть использован для выполнения инициализации 
  и это даст вам отличную гибкость вашим программам, так как вы можете вызывать 
  методы и выполнять действия во время выполнения для определения начальных значений. 
  Но одно вы должны иметь в виду: вы не препятствуете автоматической инициализации, 
  которая происходит перед входом в конструктор. Так, например, если вы скажете:</font></p>
<blockquote><font size="+1"></font><pre><font size="+1"><font color="#0000ff">class</font> Counter {
  <font color="#0000ff">int</font> i;
  Counter() { i = 7; }
  <font color="#009900">// . . .</font></font></pre></blockquote>
<p><font face="Georgia">то <b>i </b>сначала будет инициализирована 0, а затем 
  7. Это верно для всех примитивных типов и для ссылок на объекты, включая те, 
  которые имеют явную инициализацию в точке определения. По этой причине компилятор 
  не пробует ограничить вас в инициализации элементов в любом месте конструктора, 
  или перед тем, как они будут использоваться — инициализация гарантирована 
  </font><a name="fnB30" href="#fn30">[30]</a><font face="Georgia">.</font></p>
<a name="Heading181"></a><font face="Verdana">
<h4 align="left"> Порядок инициализации<a name="Index435"></a><a name="Index436"></a><a name="Index437"></a></h4>
</font>
<p><font face="Georgia">Внутри класса порядок инициализации определяется порядком 
  определения переменных класса. Определения переменных может быть разбросано 
  внутри и между определений методов, но переменные инициализируются прежде, чем 
  любой метод может быть вызван — даже конструктор. Например:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:OrderOfInitialization.java</font>
<font color="#009900">// Демонстрация порядка инициализации.</font>

<font color="#009900">// Когда конструктор вызывается для создания</font>
<font color="#009900">// объекта Tag, вы увидите сообщение:</font>
<font color="#0000ff">class</font> Tag {
  Tag(<font color="#0000ff">int</font> marker) {
    System.out.println(<font color="#004488">"Tag("</font> + marker + <font color="#004488">")"</font>);
  }
}

<font color="#0000ff">class</font> Card {
  Tag t1 = <font color="#0000ff">new</font> Tag(1); <font color="#009900">// Перед конструктором</font>
  Card() {
    <font color="#009900">// Указывает, что мы в конструкторе:</font>
    System.out.println(<font color="#004488">"Card()"</font>);
    t3 = <font color="#0000ff">new</font> Tag(33); <font color="#009900">// Повторная инициализация t3</font>
  }
  Tag t2 = <font color="#0000ff">new</font> Tag(2); <font color="#009900">// После конструктора</font>
  <font color="#0000ff">void</font> f() {
    System.out.println(<font color="#004488">"f()"</font>);
  }
  Tag t3 = <font color="#0000ff">new</font> Tag(3); <font color="#009900">// В конце</font>
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> OrderOfInitialization {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Card t = <font color="#0000ff">new</font> Card();
    t.f(); <font color="#009900">// Показывает завершение конструктора</font>
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">В <b>Card</b> объекты <b>Tag</b> определяются вперемешку 
  для обеспечения, чтобы они все были инициализированы до входа в конструктор 
  и до того, как что-то еще случится. Кроме того, <b>t3</b> повторно инициализируется 
  внутри конструктора. На выходе получим:</font></p>
<blockquote><font size="+1"><pre>Tag(1)
Tag(2)
Tag(3)
Card()
Tag(33)
f()</pre></font></blockquote>
<p><font face="Georgia">Таким образом, ссылка <b>t3</b> инициализируется дважды, 
  один раз до входа в конструктор, а второй при вызове конструктора. (Первый объект 
  выбрасывается, так что он может быть позже обработан сборщиком мусора.) Сначала 
  это может показаться не эффективно, но это гарантирует правильную инициализацию 
  — что могло бы произойти, если бы был определен перегруженный конструктор, 
  который бы <i>не</i> инициализировал <b>t3</b>, и не было бы инициализации “по 
  умолчанию” для <b>t3</b> в точке определения?</font></p>
<a name="Heading182"></a><font face="Verdana">
<h4 align="left"> Инициализация статических данных</h4>
</font> 
<p><font face="Georgia">Когда <a name="Index438"></a><a name="Index439"></a>данные 
  являются статическими, происходит то же самое; если это примитивные типы и вы 
  не инициализируете их, они получают стандартное начальное значение примитивных 
  типов. Если это ссылка на объект, она становится равной <b>null</b>, если вы 
  не создадите новый объект и не присоедините его к этой ссылке.</font></p>
<p><font face="Georgia">Если вы хотите поместить инициализацию в точку определения, 
  это выглядит точно так же, как и для не статических членов. Есть единственный 
  кусочек хранилища для <b>static</b>, не зависимо от того, сколько объектов создано. 
  Но вопрос о том, когда инициализируется <b>static</b> хранилище, остается. Этот 
  пример снимает этот вопрос:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:StaticInitialization.java</font>
<font color="#009900">// Указание начальных значений в</font>
<font color="#009900">// определении класса.</font>

<font color="#0000ff">class</font> Bowl {
  Bowl(<font color="#0000ff">int</font> marker) {
    System.out.println(<font color="#004488">"Bowl("</font> + marker + <font color="#004488">")"</font>);
  }
  <font color="#0000ff">void</font> f(<font color="#0000ff">int</font> marker) {
    System.out.println(<font color="#004488">"f("</font> + marker + <font color="#004488">")"</font>);
  }
}

<font color="#0000ff">class</font> Table {
  <font color="#0000ff">static</font> Bowl b1 = <font color="#0000ff">new</font> Bowl(1);
  Table() {
    System.out.println(<font color="#004488">"Table()"</font>);
    b2.f(1);
  }
  <font color="#0000ff">void</font> f2(<font color="#0000ff">int</font> marker) {
    System.out.println(<font color="#004488">"f2("</font> + marker + <font color="#004488">")"</font>);
  }
  <font color="#0000ff">static</font> Bowl b2 = <font color="#0000ff">new</font> Bowl(2);
}

<font color="#0000ff">class</font> Cupboard {
  Bowl b3 = <font color="#0000ff">new</font> Bowl(3);
  <font color="#0000ff">static</font> Bowl b4 = <font color="#0000ff">new</font> Bowl(4);
  Cupboard() {
    System.out.println(<font color="#004488">"Cupboard()"</font>);
    b4.f(2);
  }
  <font color="#0000ff">void</font> f3(<font color="#0000ff">int</font> marker) {
    System.out.println(<font color="#004488">"f3("</font> + marker + <font color="#004488">")"</font>);
  }
  <font color="#0000ff">static</font> Bowl b5 = <font color="#0000ff">new</font> Bowl(5);
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> StaticInitialization {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    System.out.println(
      <font color="#004488">"Creating new Cupboard() in main"</font>);
    <font color="#0000ff">new</font> Cupboard();
    System.out.println(
      <font color="#004488">"Creating new Cupboard() in main"</font>);
    <font color="#0000ff">new</font> Cupboard();
    t2.f2(1);
    t3.f3(1);
  }
  <font color="#0000ff">static</font> Table t2 = <font color="#0000ff">new</font> Table();
  <font color="#0000ff">static</font> Cupboard t3 = <font color="#0000ff">new</font> Cupboard();
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia"><b>Bowl</b> позволяет вам наблюдать за созданием класса, 
  а <b>Table</b> и <b>Cupboard</b> создают <b>static</b>-члены <b>Bowl</b> вперемешку 
  в определении класса. Обратите внимание, что <b>Cupboard</b> создает не-<b>static</b> 
  <b>Bowl b3</b> перед <b>static</b> определением. На выводе вы видите, что произошло:</font></p>
<blockquote><font size="+1"><pre>Bowl(1)
Bowl(2)
Table()
f(1)
Bowl(4)
Bowl(5)
Bowl(3)
Cupboard()
f(2)
Creating <font color="#0000ff">new</font> Cupboard() in main
Bowl(3)
Cupboard()
f(2)
Creating <font color="#0000ff">new</font> Cupboard() in main
Bowl(3)
Cupboard()
f(2)
f2(1)
f3(1)</pre></font></blockquote>
<p><font face="Georgia"> <b>Static</b> инициализация происходит только при необходимости. 
  Если вы не создаете объект <b>Table</b> и никогда не обращаетесь к <b>Table.b1 
  </b>или <b>Table.b2</b>, <b>static Bowl b1 </b>и <b>b2 </b> никогда не будут 
  созданы. Однако они инициализируются, только когда создается <i>первый</i> объект 
  <b>Table </b> (или при возникновении первого <b>static</b> доступа <b>static</b>). 
  После этого <b>static</b> объекты не инициализируются повторно.</font></p>
<p><font face="Georgia">Порядок инициализации таков: сначала инициализируются 
  <b>static</b>, если они ранее не были инициализированы при создании предыдущего 
  объекта, а затем инициализируются не <b>static</b> объекты. Вы ясно можете видеть 
  в результатах работы программы.</font></p>
<p><font face="Georgia">Полезно просуммировать информацию о <a name="Index440"></a><a name="Index441"></a>процессе 
  создания объекта. Рассмотрим класс с названием <b>Dog</b>:</font></p>
<ol>
  <li> <font face="Georgia">В начале создания объекта 
    типа <b>Dog</b>, <i>или</i> при первом обращении к <b>static</b> методу или 
    <b>static </b>полу класса <b>Dog</b>, интерпретатор Java должен найти <b>Dog.class</b>, 
    что он выполняет, производя поиск по classpath.</font>
  </li><li> <font face="Georgia">После загрузки <b>Dog.class</b> (создания объекта 
    <b>Class</b>, о котором вы узнаете позже), выполняются все <b>static</b> инициализации. 
    Таким образом, <b>static </b>инициализации выполняются только однажды, когда 
    объект <b>Class</b> загружается в первое время.</font> 
  </li><li> <font face="Georgia">Когда вы создаете <b>new Dog(&nbsp;)</b>, в процессе 
    создания объекта <b>Dog</b> сначала резервируется хранилище для объекта <b>Dog</b> 
    в куче.</font>
  </li><li> <font face="Georgia">Это хранилище заполняется нулями, автоматически присваивая 
    всем переменным примитивных типов этого объекта <b>Dog</b> их начальное значение 
    (ноль для числовых и эквивалент для <b>boolean</b> и <b>char</b>), а все ссылки 
    в <b>null</b>.</font>
  </li><li> <font face="Georgia">Выполняются все инициализации, производящиеся в точке 
    определения.</font>
  </li><li> <font face="Georgia">Выполняется конструктор. Как вы увидите в <a href=" Chapter06.html">Главе 
    6</a>, это может стать источником повышенной активности, особенно когда привлекается 
    наследование.</font>
</li></ol><a name="Heading183"></a><font face="Verdana">
<h4 align="left"> Явная инициализация static</h4>
</font><div align="left">
  <p><font face="Georgia">Java позволяет вам сгруппировать другие <b>static</b> 
    инициализации внутри специального “<a name="Index442"></a><a name="Index443"></a><b>static</b> 
    предложения конструирования” (иногда называемому <a name="Index444"></a><i>статическим 
    блоком</i>) в классе. Это выглядит так:</font></p>
</div>

<blockquote><font size="+1"><pre><font color="#0000ff">class</font> Spoon {
  <font color="#0000ff">static</font> <font color="#0000ff">int</font> i;
  <font color="#0000ff">static</font> {
    i = 47;
  }
  <font color="#009900">// . . .</font></pre></font></blockquote>
<p><font face="Georgia">Он выглядит как метод, но это просто ключевое слово <b>static</b>, 
  за которым следует тело метода. Этот код, как и другие <b>static</b> инициализации, 
  выполняется только однажды, в первый раз, когда вы создаете объект этого класса 
  <i>или</i> при первом обращении к <b>static</b> члену класса (даже если вы никогда 
  не создадите объект этого класса). Например:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:ExplicitStatic.java</font>
<font color="#009900">// Явная static инициализация</font>
<font color="#009900">// с предложением "static".</font>

<font color="#0000ff">class</font> Cup {
  Cup(<font color="#0000ff">int</font> marker) {
    System.out.println(<font color="#004488">"Cup("</font> + marker + <font color="#004488">")"</font>);
  }
  <font color="#0000ff">void</font> f(<font color="#0000ff">int</font> marker) {
    System.out.println(<font color="#004488">"f("</font> + marker + <font color="#004488">")"</font>);
  }
}

<font color="#0000ff">class</font> Cups {
  <font color="#0000ff">static</font> Cup c1;
  <font color="#0000ff">static</font> Cup c2;
  <font color="#0000ff">static</font> {
    c1 = <font color="#0000ff">new</font> Cup(1);
    c2 = <font color="#0000ff">new</font> Cup(2);
  }
  Cups() {
    System.out.println(<font color="#004488">"Cups()"</font>);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ExplicitStatic {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    System.out.println(<font color="#004488">"Inside main()"</font>);
    Cups.c1.f(99);  <font color="#009900">// (1)</font>
  }
  <font color="#009900">// static Cups x = new Cups();  // (2)</font>
  <font color="#009900">// static Cups y = new Cups();  // (2) </font>
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia"> <b>Static</b> инициализаторы для <b>Cups</b> запускаются, 
  либо когда происходит обращение к <b>static</b> объекту <b>c1</b> в строке, 
  помеченной (1), а если строка (1) закомментирована, то в строке, помеченной 
  (2), если ее раскомментировать. Если и строка (1), и (2) закомментированы, <b>static</b> 
  инициализация для <b>Cups</b> никогда не происходит. Также не имеет значения, 
  если одна из двух строк, помеченных (2) раскомментированы; статическая инициализация 
  происходит только один раз.</font></p>
<a name="Heading184"></a><font face="Verdana">
<h4 align="left"> Не статическая инициализация экземпляра<a name="Index445"></a><a name="Index446"></a><a name="Index447"></a></h4>
</font>
<p><font face="Georgia">Java обеспечивает аналогичный синтаксис для не <b>static</b> 
  переменных для каждого объекта. Вот пример:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c04:Mugs.java</font>
<font color="#009900">// Java "Инициализация экземпляра".</font>

<font color="#0000ff">class</font> Mug {
  Mug(<font color="#0000ff">int</font> marker) {
    System.out.println(<font color="#004488">"Mug("</font> + marker + <font color="#004488">")"</font>);
  }
  <font color="#0000ff">void</font> f(<font color="#0000ff">int</font> marker) {
    System.out.println(<font color="#004488">"f("</font> + marker + <font color="#004488">")"</font>);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Mugs {
  Mug c1;
  Mug c2;
  {
    c1 = <font color="#0000ff">new</font> Mug(1);
    c2 = <font color="#0000ff">new</font> Mug(2);
    System.out.println(<font color="#004488">"c1 &amp; c2 initialized"</font>);
  }
  Mugs() {
    System.out.println(<font color="#004488">"Mugs()"</font>);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    System.out.println(<font color="#004488">"Inside main()"</font>);
    Mugs x = <font color="#0000ff">new</font> Mugs();
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Вы можете видеть, что предложение инициализации экземпляра:</font></p>
<blockquote><font size="+1"><pre>  {
    c1 = <font color="#0000ff">new</font> Mug(1);
    c2 = <font color="#0000ff">new</font> Mug(2);
    System.out.println(<font color="#004488">"c1 &amp; c2 initialized"</font>);
  }</pre></font></blockquote>
<div align="left">
  <p><font face="Georgia">выглядит точно так же, как и предложение статической 
    инициализации, за исключением отсутствия ключевого слова <b>static</b>. Этот 
    синтаксис необходим для поддержки инициализации <i>анонимного внутреннего 
    класса</i> (смотрите <a href=" Chapter08.html">Главу 8</a>).</font><a name="_Toc312373861"></a><a name="_Toc375545287"></a><a name="_Toc481064584"></a></p>
</div>
<a name="Heading185"></a><font face="Verdana">
<h2 align="left"> Инициализация массива</h2>
</font> 
<p><font face="Georgia">Инициализация массивов в C++ подвержена ошибкам и утомительна. 
  C++ используют <i>агрегатную инициализацию</i>, чтобы сделать ее более безопасной 
  <a href="#fn31">[31]</a>. Java не имеет “агрегатности”, как С++, 
  так как все, что есть в Java - это объекты. Он имеет массивы, которые поддерживают 
  <a name="Index448"></a><a name="Index449"></a>инициализацию массивов.</font></p>
<p><font face="Georgia">Массив - это просто последовательность либо объектов, 
  либо примитивных типов, которые все имеют один тип и упакованы вместе под одним 
  идентификатором. Массивы определяются и используются с квадратными скобками 
  <a name="Index451"></a><a name="Index452"></a><a name="Index453"></a><i>оператора 
  индексирования</i> <b>[ ]</b>. Для определения массива вы просто указываете 
  имя типа, за которым следуют пустые квадратные скобки:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">int</font>[] a1;</pre></font></blockquote>
<p><font face="Georgia">Вы также можете поместить квадратные скобки после идентификатора, 
  что имеет то же самое значение:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">int</font> a1[];</pre></font></blockquote>
<p><font face="Georgia">Это подтверждает ожидания программистов C и C++. Однако, 
  форма, вероятно, имеет более гибкий синтаксис, так как она объявляет тип “массив 
  <b>int</b>”. Этот стиль будет использоваться в этой книге.</font></p>
<p><font face="Georgia">Компилятор не позволяет вам объявить величину массива. 
  Это происходит из-за свойств “ссылок”. Все, что вы имеете в этой 
  точке - это ссылка на массив, и здесь не резервируется место для массива. Для 
  создания хранилища для массива вы должны написать выражение инициализации. Для 
  массивов, инициализация может быть выполнена в любом месте вашего кода, но вы 
  также можете использовать особый вид выражения инициализации, которая должна 
  происходить в точке создания. Эта особая инициализация обеспечивает набор значений, 
  заключенных в фигурные скобки. О резервировании хранилища (эквивалентно использованию 
  <b>new</b>) в этом случае заботится компилятор. Например:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">int</font>[] a1 = { 1, 2, 3, 4, 5 };</pre></font></blockquote>
<div align="left">
  <p><font face="Georgia">Почему вы иногда определяете ссылку на массив без массива?</font></p>
</div>

<blockquote><font size="+1"><pre><font color="#0000ff">int</font>[] a2;</pre></font></blockquote>
<p><font face="Georgia">Потому что возможно присвоить один массив в Java другому, 
  так что вы можете сказать:</font></p>
<blockquote><font size="+1"><pre>a2 = a1;</pre></font></blockquote>
<p><font face="Georgia">На самом деле вы выполняете копирование ссылок, как продемонстрировано 
  тут:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c04:Arrays.java</font>
<font color="#009900">// Массив примитивных типов.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Arrays {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#0000ff">int</font>[] a1 = { 1, 2, 3, 4, 5 };
    <font color="#0000ff">int</font>[] a2;
    a2 = a1;
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a2.length; i++)
      a2[i]++;
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a1.length; i++)
      System.out.println(
        <font color="#004488">"a1["</font> + i + <font color="#004488">"] = "</font> + a1[i]);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Вы можете видеть, что <b>a1</b> получает значения инициализации, 
  в то время как <b>a2</b> не имеет его; <b>a2</b> присваивается позже — 
  в этом случае, с помощью другого массива.</font></p>
<p><font face="Georgia">Здесь есть кое-что новое: все массивы имеют внутренний 
  член (не зависимо от того, есть ли массив объектов, или массив примитивных типов), 
  который вы можете опросить — но не изменить — и он скажет вам, сколько 
  элементов есть в массиве. Этот член - <b>length<a name="Index454"></a><a name="Index455"></a></b>. 
  Так как массивы в Java, как и в C и C++, начинают счет элементов с нуля, старший 
  элемент имеет индекс <b>length - 1</b>. Если вы выйдете за <a name="Index456"></a><a name="Index457"></a>пределы, 
  C и C++ примут это и позволят вам пройтись по вашей памяти, что будет являться 
  источником многих ошибок, трудных в обнаружении. Однако Java защищает вас от 
  этой проблемы, выдавая ошибку времени выполнения (<i>исключение</i>, описанное 
  в <a href=" Chapter10.html">Главе 10</a>), если вы выйдете за пределы. Конечно, 
  проверка каждого обращения к массиву влияет на время и код, и нет способа отключить 
  ее, в результате чего доступ к массиву может стать источником неэффективности 
  в вашей программе, если этот доступ происходит в критичном участке. Для безопасности 
  Internet и продуктивности программистов, разработчики Java подумали, что это 
  будет достаточно удобно.</font></p>
<p><font face="Georgia">Что, если вы не знаете, сколько элементов вам потребуется 
  в вашем массиве, когда вы пишите программу? Вы просто используете <b>new</b> 
  для создания элементов массива. Здесь <a name="Index458"></a><b>new</b> работает 
  даже для создания массива примитивных типов (<b>new</b> не может создавать не 
  массив примитивов):</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:ArrayNew.java</font>
<font color="#009900">// Создание массивов с помощью.</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ArrayNew {
  <font color="#0000ff">static</font> Random rand = <font color="#0000ff">new</font> Random();
  <font color="#0000ff">static</font> <font color="#0000ff">int</font> pRand(<font color="#0000ff">int</font> mod) {
    <font color="#0000ff">return</font> Math.abs(rand.nextInt()) % mod + 1;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#0000ff">int</font>[] a;
    a = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[pRand(20)];
    System.out.println(
      <font color="#004488">"length of a = "</font> + a.length);
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a.length; i++)
      System.out.println(
        <font color="#004488">"a["</font> + i + <font color="#004488">"] = "</font> + a[i]);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Так как размер массива выбирается случайно (используя 
  метод <b>pRand(&nbsp;)</b>), ясно, что создание массива происходит во время 
  выполнения. Кроме того, вы видите на выходе программы, что массив элементов 
  примитивных типов автоматически инициализируется “пустыми” значениями. 
  (Для чисел и <b>char</b> - это ноль, а для <b>boolean</b> - это <b>false</b>).</font></p>
<p><font face="Georgia">Конечно, массив может быть определен и инициализирован 
  в одной инструкции:</font></p>
<div align="left"></div>

<blockquote><font size="+1"><pre><font color="#0000ff">int</font>[] a = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[pRand(20)];</pre></font></blockquote>
<p><font face="Georgia">Если вы имеете дело с массивом не примитивных объектов, 
  вы должны всегда использовать <b>new</b>. Это происходит из-за использования 
  ссылок, так как вы создаете массив ссылок. Относительно типа-оболочки <b>Integer<a name="Index459"></a>, 
  </b>который является классом, а не примитивным типом:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:ArrayClassObj.java</font>
<font color="#009900">// Создание массива не примитивных объектов.</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ArrayClassObj {
  <font color="#0000ff">static</font> Random rand = <font color="#0000ff">new</font> Random();
  <font color="#0000ff">static</font> <font color="#0000ff">int</font> pRand(<font color="#0000ff">int</font> mod) {
    <font color="#0000ff">return</font> Math.abs(rand.nextInt()) % mod + 1;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Integer[] a = <font color="#0000ff">new</font> Integer[pRand(20)];
    System.out.println(
      <font color="#004488">"length of a = "</font> + a.length);
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a.length; i++) {
      a[i] = <font color="#0000ff">new</font> Integer(pRand(500));
      System.out.println(
        <font color="#004488">"a["</font> + i + <font color="#004488">"] = "</font> + a[i]);
    }
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Здесь, даже после вызова <b>new</b> для создания массива:</font></p>
<blockquote><font size="+1"><pre>Integer[] a = <font color="#0000ff">new</font> Integer[pRand(20)];</pre></font></blockquote>
<p><font face="Georgia">есть только массив ссылок, и пока ссылки не будут инициализированы 
  путем создания новых объектов <b>Integer</b>, инициализация будет не закончена:</font></p>
<blockquote><font size="+1"><pre>a[i] = <font color="#0000ff">new</font> Integer(pRand(500));</pre></font></blockquote>
<p><font face="Georgia">Однако если вы забудете создать объект, вы получите исключение 
  времени выполнения, когда попробуете прочесть пустую ячейку массива.</font></p>
<p><font face="Georgia">Взгляните на формирование объекта <b>String </b>внутри 
  инструкции печати. Вы увидите, что ссылка на объект <b>Integer</b> автоматически 
  конвертируется, для производства <b>String</b>, представляющую значение внутри 
  объекта.</font></p>
<p><font face="Georgia">Также возможно инициализировать массив, используя список, 
  окруженный фигурными скобками. Существует две формы:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c04:ArrayInit.java</font>
<font color="#009900">// Инициализация массива.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ArrayInit {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Integer[] a = {
      <font color="#0000ff">new</font> Integer(1),
      <font color="#0000ff">new</font> Integer(2),
      <font color="#0000ff">new</font> Integer(3),
    };

    Integer[] b = <font color="#0000ff">new</font> Integer[] {
      <font color="#0000ff">new</font> Integer(1),
      <font color="#0000ff">new</font> Integer(2),
      <font color="#0000ff">new</font> Integer(3),
    };
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Иногда это полезно, но это более ограниченный способ, 
  так как размер массива определяется во время компиляции. Последняя запятая в 
  списке инициализации не обязательна. (Эта особенность облегчает обслуживание 
  длинных списков.)</font></p>
<p><font face="Georgia">Вторая форма инициализации массива обеспечивает последовательный 
  синтаксис для создания и вызова методов, которые могут обеспечить такой же эффект, 
  что и <a name="Index460"></a><a name="Index461"></a><i>список переменной длины</i> 
  из C. Это может включать неизвестное количество аргументов неизвестного типа. 
  Так как все классы обязательно наследуются от общего корневого класса <b>Object</b> 
  (более подробно об этом вы узнаете на протяжении чтения этой книги), вы можете 
  создать метод, который принимает массив <b>Object</b> и вызывает его. Например:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c04:VarArgs.java</font>
<font color="#009900">// Использование синтаксиса массива для</font>
<font color="#009900">// списка переменной длины.</font>

<font color="#0000ff">class</font> A { <font color="#0000ff">int</font> i; }

<font color="#0000ff">public</font> <font color="#0000ff">class</font> VarArgs {
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> f(Object[] x) {
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; x.length; i++)
      System.out.println(x[i]);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    f(<font color="#0000ff">new</font> Object[] { 
        <font color="#0000ff">new</font> Integer(47), <font color="#0000ff">new</font> VarArgs(), 
        <font color="#0000ff">new</font> Float(3.14), <font color="#0000ff">new</font> Double(11.11) });
    f(<font color="#0000ff">new</font> Object[] {<font color="#004488">"one"</font>, <font color="#004488">"two"</font>, <font color="#004488">"three"</font> });
    f(<font color="#0000ff">new</font> Object[] {<font color="#0000ff">new</font> A(), <font color="#0000ff">new</font> A(), <font color="#0000ff">new</font> A()});
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">В этом месте есть не много вещей, которые вы можете сделать 
  с этими неизвестными объектами, и эта программа использует автоматическое преобразование 
  в <b>String</b> для получения некоторой пользы от каждого объекта <b>Object</b>. 
  В <a href=" Chapter12.html">Главе 12</a>, которая описывает <i>идентификацию 
  типа времени выполнения</i> (RTTI), вы выучите о том, как определять точный 
  тип каждого объекта, так чтобы вы смогли делать более интересные вещи.</font><a name="_Toc481064585"></a></p>
<a name="Heading186"></a><font face="Verdana">
<h3 align="left"> Многомерные массивы</h3>
</font>
<p><font face="Georgia">Java позволяет вам легко создавать <a name="Index462"></a><a name="Index463"></a>многомерные 
  массивы:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c04:MultiDimArray.java</font>
<font color="#009900">// Создание многомерных массивов.</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> MultiDimArray {
  <font color="#0000ff">static</font> Random rand = <font color="#0000ff">new</font> Random();
  <font color="#0000ff">static</font> <font color="#0000ff">int</font> pRand(<font color="#0000ff">int</font> mod) {
    <font color="#0000ff">return</font> Math.abs(rand.nextInt()) % mod + 1;
  }
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> prt(String s) {
    System.out.println(s);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#0000ff">int</font>[][] a1 = {
      { 1, 2, 3, },
      { 4, 5, 6, },
    };
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a1.length; i++)
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; a1[i].length; j++)
        prt(<font color="#004488">"a1["</font> + i + <font color="#004488">"]["</font> + j +
            <font color="#004488">"] = "</font> + a1[i][j]);
    <font color="#009900">// 3-х мерный массив фиксированной длины:</font>
    <font color="#0000ff">int</font>[][][] a2 = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[2][2][4];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a2.length; i++)
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; a2[i].length; j++)
        <font color="#0000ff">for</font>(<font color="#0000ff">int</font> k = 0; k &lt; a2[i][j].length;
            k++)
          prt(<font color="#004488">"a2["</font> + i + <font color="#004488">"]["</font> +
              j + <font color="#004488">"]["</font> + k +
              <font color="#004488">"] = "</font> + a2[i][j][k]);
    <font color="#009900">// 3-х мерный массив с векторами переменной длины:</font>
    <font color="#0000ff">int</font>[][][] a3 = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[pRand(7)][][];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a3.length; i++) {
      a3[i] = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[pRand(5)][];
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; a3[i].length; j++)
        a3[i][j] = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[pRand(5)];
    }
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a3.length; i++)
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; a3[i].length; j++)
        <font color="#0000ff">for</font>(<font color="#0000ff">int</font> k = 0; k &lt; a3[i][j].length;
            k++)
          prt(<font color="#004488">"a3["</font> + i + <font color="#004488">"]["</font> +
              j + <font color="#004488">"]["</font> + k +
              <font color="#004488">"] = "</font> + a3[i][j][k]);
    <font color="#009900">// Массив не примитивных объектов:</font>
    Integer[][] a4 = {
      { <font color="#0000ff">new</font> Integer(1), <font color="#0000ff">new</font> Integer(2)},
      { <font color="#0000ff">new</font> Integer(3), <font color="#0000ff">new</font> Integer(4)},
      { <font color="#0000ff">new</font> Integer(5), <font color="#0000ff">new</font> Integer(6)},
    };
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a4.length; i++)
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; a4[i].length; j++)
        prt(<font color="#004488">"a4["</font> + i + <font color="#004488">"]["</font> + j +
            <font color="#004488">"] = "</font> + a4[i][j]);
    Integer[][] a5;
    a5 = <font color="#0000ff">new</font> Integer[3][];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a5.length; i++) {
      a5[i] = <font color="#0000ff">new</font> Integer[3];
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; a5[i].length; j++)
        a5[i][j] = <font color="#0000ff">new</font> Integer(i*j);
    }
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a5.length; i++)
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; a5[i].length; j++)
        prt(<font color="#004488">"a5["</font> + i + <font color="#004488">"]["</font> + j +
            <font color="#004488">"] = "</font> + a5[i][j]);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Код, использующийся для печати, использует <b>length</b>, 
  так что он не зависит от того, имеет ли массив фиксированную длину.</font></p>
<p><font face="Georgia">Первый пример показывает многомерный массив примитивных 
  типов. Вы ограничиваете каждый вектор в массиве с помощью фигурных скобок:</font></p>
<blockquote><font size="+1"><pre>    <font color="#0000ff">int</font>[][] a1 = {
      { 1, 2, 3, },
      { 4, 5, 6, },
    };</pre></font></blockquote>
<p><font face="Georgia">Каждая пара квадратных скобок переносит нас на новый уровень 
  в массиве.</font></p>
<p><font face="Georgia">Второй пример показывает трехмерный массив, резервируемый 
  с помощью <b>new</b>. Здесь весь массив резервируется сразу:</font></p>
<blockquote><font size="+1"><pre><font color="#0000ff">int</font>[][][] a2 = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[2][2][4];</pre></font></blockquote>
<p><font face="Georgia">А в третьем примере показано, что каждый вектор массива, 
  создающий матрицу, может быть произвольной длины:</font></p>
<blockquote><font size="+1"><pre>    <font color="#0000ff">int</font>[][][] a3 = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[pRand(7)][][];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a3.length; i++) {
      a3[i] = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[pRand(5)][];
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; a3[i].length; j++)
        a3[i][j] = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[pRand(5)];
    }</pre></font></blockquote>
<p><font face="Georgia">Первый <b>new</b> создает массив произвольной длиной первого 
  элемента, а остальные элементы не определены. Второй <b>new</b>, внутри цикла 
  <b>for</b>, заполняет элементы, но оставляет третий индекс неопределенным, пока 
  вы не введете третий <b>new</b>.</font></p>
<p><font face="Georgia">Вы увидите на выводе, что значения массива автоматически 
  инициализируются нулями, если вы не передадите им явно начальные значения.</font></p>
<p><font face="Georgia">Вы можете работать с массивами не примитивных объектов 
  точно таким же образом, что показано в четвертом примере, демонстрирующем возможность 
  помещения множества выражений <b>new</b> в фигурных скобках:</font></p>
<blockquote><font size="+1"><pre>    Integer[][] a4 = {
      { <font color="#0000ff">new</font> Integer(1), <font color="#0000ff">new</font> Integer(2)},
      { <font color="#0000ff">new</font> Integer(3), <font color="#0000ff">new</font> Integer(4)},
      { <font color="#0000ff">new</font> Integer(5), <font color="#0000ff">new</font> Integer(6)},
    };</pre></font></blockquote>
<p><font face="Georgia">Пятый пример показывает, как можно построить массив не 
  примитивных объектов по частям:</font></p>
<blockquote><font size="+1"><pre>    Integer[][] a5;
    a5 = <font color="#0000ff">new</font> Integer[3][];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a5.length; i++) {
      a5[i] = <font color="#0000ff">new</font> Integer[3];
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; a5[i].length; j++)
        a5[i][j] = <font color="#0000ff">new</font> Integer(i*j);
    }</pre></font></blockquote>
<p><font face="Georgia"> <b>i*j</b> - это просто помещает отличное от нуля значение 
  в <b>Integer</b>.</font><a name="_Toc375545288"></a><a name="_Toc481064586"></a></p>
<a name="Heading187"></a><font face="Verdana"> 
<h2 align="left"> Резюме</h2>
</font> 
<p><font face="Georgia">Такая тщательность в разработки механизма инициализации 
  и конструкторов должна дать вам намек о повышенной важности инициализации в 
  языке. Когда Страуступ разрабатывал C++, одно из важнейших наблюдений, относительно 
  производительности C, было в том, что неправильная инициализация переменных 
  являлась источником значительной части проблем при программировании. Этот вид 
  ошибок трудно обнаружить. То же самое можно сказать и про неправильную очистку. 
  Поскольку конструкторы <i>гарантируют</i>, вам правильную инициализацию и очистку 
  (компилятор не позволяет объектам создаваться без правильного вызова конструктора), 
  вы получаете полный контроль и безопасность.</font></p>
<p><font face="Georgia">В C++ деструкторы очень важны, потому что объекты, созданные 
  с помощью <b>new</b> должны явно разрушаться. В Java сборщик мусора автоматически 
  освобождает память всех объектов, так что эквивалентный метод очистки в Java 
  не так необходим. В тех случаях, когда вам не нужно поведение, аналогичное деструктору, 
  сборщик мусора Java упрощает программирование и вносит дополнительную безопасность 
  в управление памятью. Некоторые сборщики мусора могут очищать даже такие ресурсы, 
  как графику и указатели на файлы. Однако сборщики мусора вносят дополнительные 
  затраты во время выполнения, стоимость которых трудно обозреть в перспективе 
  из-за медленности интерпретаторов Java в то время, когда это было написано. 
  Поскольку это меняется, мы будем способны обнаружить, устранит ли лучший из 
  сборщиков мусора Java накладные расходы для определенных типов программ. (Одна 
  из проблем - непредсказуемость сборщика мусора.)</font></p>
<p><font face="Georgia">Поскольку есть гарантия, что все объекты будут сконструированы, 
  о конструкторах можно сказать гораздо больше, чем есть здесь. Обычно, когда 
  вы создаете новый класс с использованием композиции или наследования, гарантия 
  конструирования также остается, но для поддержки этого необходим дополнительный 
  синтаксис. Вы узнаете о композиции и наследовании и то, как они влияют на конструкторы 
  в следующих главах</font><font face="Georgia">.</font><a name="_Toc375545289"></a><a name="_Toc481064587"></a></p>
<a name="Heading188"></a><font face="Verdana">
<h2 align="left"> Упражнения</h2>
</font> <font face="Georgia" size="2">Решения для выбранных упражнений могут быть 
найдены в электронной документации <i>The Thinking in Java Annotated Solution 
Guide</i>, доступной за малую плату на <i>www.BruceEckel.com</i>.</font>
<ol>
  <li><font face="Georgia">Создайте класс с конструктором по умолчанию (который 
    не принимает аргументов), печатающий сообщение. Создайте объект этого класса.</font>
  </li><li><font face="Georgia">Добавьте перегруженный конструктор к Упражнению 1, 
    который принимает аргумент типа <b>String</b> и печатает его наряду с вашим 
    сообщением.</font>
  </li><li> <font face="Georgia">Создайте массив ссылок на объекты вашего класса из 
    Упражнения 2, но не создавайте объекты для помещения их ссылок в массив. Когда 
    вы запустите программу, обратите внимание, есть ли сообщения об инициализации, 
    которые печатаются при вызове конструктора.</font>
  </li><li> <font face="Georgia">Завершите Упражнение 3, создав объекты, и присоедините 
    их к ссылкам в массиве.</font>
  </li><li> <font face="Georgia">Создайте массив из объектов <b>String</b> и присоедините 
    строку к каждому элементу. Распечатайте массив, используя цикл <b>for</b>.</font>
  </li><li> <font face="Georgia">Создайте класс с названием <b>Dog</b> с перегруженным 
    методом <b>bark(&nbsp;)</b>. Этот метод должен перегружаться, основываясь 
    на различных примитивных типах данных, и печатать различные типы лая, завывания 
    и т.п., в зависимости от того, какая перегруженная версия вызвана. Напишите 
    <b>main(&nbsp;)</b>, который вызывает различные версии.</font> 
  </li><li> <font face="Georgia">Измените Упражнение 6 так, чтобы два разных перегруженных 
    метода имели два аргумента (двух различных типов), но в разном порядке. Проверьте 
    как это работает.</font>
  </li><li> <font face="Georgia">Создайте класс без конструктора, а затем создайте 
    объект этого класса в <b>main(&nbsp;)</b> для проверки того, что конструктор 
    по умолчанию синтезируется автоматически.</font>
  </li><li> <font face="Georgia">Создайте класс с двумя методами. В первом методе вызовите 
    второй дважды: первый раз без использования <b>this</b>, а второй раз, используя 
    <b>this</b>.</font>
  </li><li> <font face="Georgia">Создайте класс с двумя (перегруженными) конструкторами. 
    Используя <b>this</b>, вызовите второй конструктор внутри первого.</font>
  </li><li> <font face="Georgia">Создайте класс с методом <b>finalize(&nbsp;)</b>, 
    который печатает сообщение. В <b>main(&nbsp;)</b> создайте объект вашего класса. 
    Объясните поведение вашей программы.</font>
  </li><li> <font face="Georgia">Измените Упражнение 11 так, чтобы ваш <b>finalize(&nbsp;)</b> 
    вызывался всегда.</font>
  </li><li> <font face="Georgia">Создайте класс, называемый <b>Tank</b>, который может 
    быть заполнен и опустошен, и имеет <i>смертельное состояние</i>, при котором 
    он должен быть опустошен во время очистки объекта. Напишите <b>finalize(&nbsp;)</b>, 
    который проверяет смертельное состояние. В <b>main(&nbsp;)</b> проверьте возможные 
    сценарии, которые возникают при использовании вашего <b>Tank</b>.</font>
  </li><li> <font face="Georgia">Создайте класс, содержащий <b>int</b> и <b>char</b>, 
    которые не инициализируются, и распечатайте их значения, чтобы проверить, 
    что Java выполнил инициализацию по умолчанию.</font>
  </li><li> <font face="Georgia">Создайте класс, содержащий не инициализированную ссылку 
    на <b>String</b>. Продемонстрируйте, что эта ссылка инициализируется Java 
    значением <b>null</b>.</font>
  </li><li> <font face="Georgia">Создайте класс с полем <b>String</b>, которое инициализируется 
    в точке определения, и другое поле, которое инициализируется конструктором. 
    Какие отличия есть в этих двух подходах?</font>
  </li><li> <font face="Georgia">Создайте класс с полем <b>static String</b>, которое 
    инициализируется в точке определения, и другое, которое инициализируется в 
    блоке <b>static</b>. Добавьте <b>static</b> метод, который печатает оба поля 
    и демонстрирует, что оба они инициализируются до использования.</font>
  </li><li> <font face="Georgia">Создайте класс с <b>String</b>, который инициализируется, 
    используя “инициализацию экземпляра”. Опишите использование этой 
    особенности (отличной от тех, которые описаны в этой книге).</font>
  </li><li> <font face="Georgia">Напишите метод, который создает и инициализирует двумерный 
    массив типа <b>double</b>. Размер массива определяется аргументами метода, 
    а диапазон начальных значений определяется начальным и конечным значением, 
    которые так же передаются, как аргументы метода. Создайте второй метод, который 
    будет печатать массив, сгенерированный первым методом. В <b>main(&nbsp;)</b> 
    проверьте методы, создав и распечатав несколько массивов с различным размером.</font>
  </li><li> <font face="Georgia">Повторите Упражнение 19 для трехмерного массива.</font>
  </li><li> <font face="Georgia">Закомментируйте строку, помеченную (1) в <b>ExplicitStatic.java</b> 
    и проверьте, что предложение статической инициализации не вызывается. Теперь 
    раскомментируйте одну из строк, помеченных (2) и проверьте, что предложение 
    статической инициализации вызвано. Теперь раскомментируйте вторую строку, 
    помеченную (2) и проверьте, что статическая инициализация происходит лишь 
    однажды.</font>
  </li><li> <font face="Georgia">Поэкспериментируйте с <b>Garbage.java</b>, запуская 
    программу, используя такие аргументы, как “gc”, “finalize” 
    или “all”. Повторите процесс и посмотрите, обнаружите ли вы какие-нибудь 
    шаблоны на выходе. Измените код так, чтобы <b>System.runFinalization(&nbsp;) 
    </b>вызывался <i>перед </i><b>System.gc(&nbsp;)</b> и посмотрите результат.</font>
</li></ol>
<hr>
<p><a name="fn27">[27]</a><font face="Georgia" size="2"> В части литературы по Java 
  от Sun они говорят об этом неуклюжим, но описательным именем “конструктор 
  без аргументов”. Термин “конструктор по умолчанию” был в использовании 
  уже много лет, поэтому он используется и сейчас.</font></p>
<p><a name="fn28">[28]</a><font face="Georgia" size="2"> Одна из причин, по которой 
  это возможно, если вы передаете ссылку на объект в <b>static</b> метод. Поэтому, 
  через ссылку (которая теперь аналогична <b>this</b>), вы можете вызвать не <b>static</b> 
  методы и получить доступ к не <b>static</b> полям. Но обычно, если вы хотите 
  сделать что-то подобное, вы сделаете обычный не <b>static</b> метод.</font></p>
<p><a name="fn29">[29]</a><font face="Georgia" size="2"> Термин, который был введен 
  Bill Venners (www.artima.com) во время семинара, который мы с ним проводили 
  вместе.</font></p>
<p><a name="fn30">[30]</a><font face="Georgia" size="2"> В отличие от этого, C++ 
  имеет <i>список инициализирующих конструкторов</i>, который является причиной 
  инициализации до попадания в тело конструктора и является обязательным для объектов. 
  Смотрите </font><font face="Georgia" size="2"><i>Thinking in C++, 2<sup>nd</sup> 
  edition</i> (доступную на CD ROM, поставляемый с книгой и на <i>www.BruceEckel.com</i>).</font></p>
<p><a name="fn31">[31]</a><font face="Georgia" size="2"> Смотрите <i>Thinking in 
  C++, 2<sup>nd</sup> edition</i> о более полном описании агрегатной инициализации 
  в C++.</font></p>
<div align="center"> <font face="Verdana" size="-1"> [ <a href=" Chapter03.html">Предыдущая 
  глава </a> ] [ <a href=" SimpleContents.html">Оглавление</a> ] [ <a href=" Contents.html">Содержание</a> 
  ] [ <a href=" DocIndex.html">Индекс</a> ] [ <a href=" Chapter05.html">Следующая 
  глава </a> ]</font></div>

</body></html>