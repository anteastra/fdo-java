<html><head><!-- by.ru advertising --><script language="JavaScript" src="Chapter15_files/upper.js"></script><title>Распределенные вычисления</title>

<meta http-equiv="Content-Type" content="text/html; charset=windows-1251"></head>



<body bgcolor="#ffffff">
<div align="center">
  <center>
    <h2><font face="Verdana"> Thinking in Java, 2nd edition, Revision 11</font></h2>
    <h3><font face="Verdana">©2000 by Bruce Eckel</font></h3>
    <font face="Verdana" size="-1"> [ <a href=" Chapter14.html">Предыдущая глава</a> 
    ] [ <a href=" SimpleContents.html">Оглавление</a> ] [ <a href=" Contents.html">Содержание</a> 
    ] [ <a href=" DocIndex.html">Индекс</a> ] [ <a href=" AppendixA.html">Следующая 
    глава </a> ] </font> 
  </center>
  <p></p>
</div>
<a name="Chapter_17"></a><a name="_Toc375545491"></a><a name="_Toc477690735"></a><a name="_Toc481064866"></a><a name="Heading510"></a><font face="Verdana"> 
<h1 align="left"> 15:Распределенные вычисления</h1>
</font> 
<div align="left"> 
  <p><font face="Georgia" size="4">Исторически, программирование для нескольких 
    машин было трудоемким, сложным и полным ошибок.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Программист должен знать множество деталей о сети, а 
    иногда, также об аппаратном обеспечении. Вам нужно было разбираться с различными 
    “слоями” сетевых протоколов, и, кроме того, существовало множество 
    функций в сетевых библиотеках для соединения, распаковки, упаковки блоков 
    информации; передачи этих блоков туда и обратно; и подтверждения связи. Это 
    была тяжелая задача.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Однако, основная идея распределенного программирования 
    не так сложна, и легко резюмируется в библиотеках Java. Вы хотите:</font><br>
  </p>
</div>
<ul>
  <li><font face="Wingdings"> </font><font face="Georgia">Получать информацию 
    с одной машины и переместить на другую машину, либо наоборот. Это выполняется 
    с помощью простейшего сетевого программирования.</font> 
  </li><li><font face="Wingdings"> </font><font face="Georgia">Подключаться к базе 
    данных, находящейся в сети. Это реализуется с помощью библиотеки <i>Java DataBase 
    Connectivity</i> (JDBC), которая абстрагируется от связанных с платформой 
    деталей SQL (the <i>structured query language - структурированный язык запросов 
    - </i> используемый в большинстве транзакций баз данных).</font> 
  </li><li><font face="Wingdings"> </font><font face="Georgia">Предоставлять услуги 
    через Web сервер. Достигается с помощью Java <i>сервлетов</i> и <i>Java Server 
    Pages</i> (JSPs).</font> 
  </li><li><font face="Wingdings"> </font><font face="Georgia">Выполнять прозрачный 
    запуск методов объектов Java, которые расположены на удаленных машинах, как 
    будто они располагаются на локальных машинах. Выполняется с помощью <i>Remote 
    Method Invocation</i> (RMI).</font> 
  </li><li><font face="Wingdings"> </font><font face="Georgia">Использовать код, написанный 
    на других языках, работающий в других архитектурах. Это выполняется с помощью 
    <i>Common Object Request Broker Architecture</i> (CORBA), технологии, которая 
    напрямую поддерживается языком Java.</font> 
  </li><li>Изолировать бизнес правила от соединения<font face="Georgia">, особенно, 
    соединения с базами данных, включающего обработку транзакций и безопасность. 
    Это выполняется с помощью <i>Enterprise JavaBeans </i>(EJBs). EJBs на самом 
    деле не является распределенной архитектурой, но конечные приложения обычно 
    используются в сетевых клиент-серверных системах.</font> 
  </li><li><font face="Wingdings"> </font><font face="Georgia">Простое, динамическое 
    добавление и удаление устройств из сетевого представления локальной системы. 
    Это выполняется с помощью Jini из Java.</font>
</li></ul>
<div align="left">
  <p><font face="Georgia">Для каждого пункта будет дано небольшое введение в этой 
    главе. Обратите внимание, что каждая тема довольно объемная и сама по себе 
    может занимать отдельную книгу, так что эта глава предназначена для ознакомления 
    с этими разделами. Это, конечно, не сделает Вас экспертами по данным вопросам 
    (хотя, Вы можете довольно далеко пройти с помощью информации представленной 
    здесь по сетевому программированию, сервлетам и JSPs). </font><a name="_Toc481064867"></a><br>
  </p>
</div>
<a name="Heading511"></a><font face="Verdana">
<h2 align="left"> Сетевое программирование<a name="_Toc375545492"></a><br>
  <a name="Index2044"></a></h2>
</font> 
<div align="left"> 
  <p><font face="Georgia">Одним из больших достижений Java является безболезненное 
    общение в сети. Проектировщики сетевой библиотеки Java сделали ее похожей 
    на чтение и запись файлов, за исключением того, что этот “файл” 
    находится на удаленной машине и удаленная машина может в точности определить, 
    что нужно сделать с информацией, которую Вы посылаете либо требуете. Насколько 
    возможно, внутренние детали сетевого общения абстрагированы и обрабатываются 
    внутри JVM и локальной машины, на которой установлена среда Java. Модель программирования 
    такая же, как Вы используете в файле; в действительности, Вы просто окутываете 
    сетевое соединение (“сокет”) потоковым объектом, и Вы действуете 
    используя те же вызовы методов, что и с другими потоковыми объектами. К тому 
    же, встроенная в Java множественность процессов очень удобна при общении в 
    сети: установка нескольких соединений сразу.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Этот раздел описывает поддержку сети в Java, используя 
    простые примеры.</font><a name="_Toc481064868"></a><br>
  </p>
</div>
<a name="Heading512"></a><font face="Verdana">
<h3 align="left"> Идентификация машины </h3>
</font>
<div align="left">
  <p><font face="Georgia">Конечно, чтобы убедиться, что соединение установлено 
    с конкретной машиной в сети, должен быть способ уникальной <a name="Index2045"></a>идентификации 
    машины в сети. Раньше, при работе в сети было достаточно предоставить уникальные 
    имена для машин внутри локальной сети. Но, Java работает в Internet, который 
    требует уникальной идентификации машины с любой другой во всей сети <i>по 
    всему миру</i>. Это достигается с помощью <a name="Index2046"></a><a name="Index2047"></a><a name="Index2048"></a>IP 
    (Internet Protocol) адресации, которая может иметь две формы:</font><br>
  </p>
</div>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Обычная</font> <font face="Georgia"><a name="Index2049"></a><a name="Index2050"></a>DNS 
    (<i>Domain Name System</i>) форма. Мое доменное имя - <b>bruceeckel.com</b>, 
    и если у меня есть компьютер с именем <b>Opus</b> в моем домене, его доменное 
    имя может быть <b>Opus.bruceeckel.com</b>. Это в точности тип имени, который 
    Вы используете при отсылке почты, и очень часто включается в WWW адрес.</font> 
  </li><li>С другой стороны<font face="Georgia">, Вы можете использовать </font> <font face="Georgia">“<a name="Index2051"></a><a name="Index2052"></a>четырехточечную” 
    форма, в которой четыре номера разделены точками, например <b>123.255.28.120</b>.</font><br>
</li></ol>
<div align="left">
  <p><font face="Georgia">В обоих случаях, IP адрес представляется как 32 битное 
    значение</font><a name="fnB72" href="#fn72">[72]</a><font face="Georgia"> 
    (каждое число из 4-х не может превышать 255), и Вы можете получить специальный 
    объект Java для представления этого номера из формы, представленной выше с 
    помощью метода <b>static</b> <b>InetAddress.getByName(&nbsp;)</b> в пакете 
    <b>java.net</b>. Результат это объект типа <b>InetAddress</b>, который Вы 
    можете использовать для создания “сокета”, как Вы позднее увидите.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Простой пример использования <b>InetAddress.getByName(&nbsp;)</b>, 
    показывает что происходит, когда у Вас есть провайдер интернет по коммутируемым 
    соединениям (ISP). Каждый раз, когда Вы дозваниваетесь, Вам присваивается 
    временный IP. Но, пока Вы соединены, Ваш IP адрес ничем не отличается от любого 
    другого IP адреса в интернет. Если кто-то подключится к Вашей машине, используя 
    Ваш IP адрес, он сможет подключиться также к Web или FTP серверу, который 
    запущен на Вашей машине. Конечно, сначала необходимо узнать Ваш IP адрес, 
    а т.к. при каждом соединении присваивается новый адрес, как Вы сможете его 
    узнать?</font><br>
  </p>
</div>
<div align="left"> 
  <p><font face="Georgia">Следующая программа использует <b>InetAddress.getByName(&nbsp;)</b> 
    для определения Вашего IP адреса. Чтобы использовать его, Вы должны знать 
    имя своего компьютера. В Windows 95/98, зайдите в “Settings”, 
    “Control Panel”, “Network”, а затем выберите страничку 
    “Identification”. “Computer name” это имя, которое 
    необходимо задать в командной строке.</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c15:WhoAmI.java</font>
<font color="#009900">// Определяет Ваш сетевой адрес</font>
<font color="#009900">// когда Вы подключены к Internet.</font>
<font color="#0000ff">import</font> java.net.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> WhoAmI {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) 
      <font color="#0000ff">throws</font> Exception {
    <font color="#0000ff">if</font>(args.length != 1) {
      System.err.println(
        <font color="#004488">"Usage: WhoAmI MachineName"</font>);
      System.exit(1);
    }
    InetAddress a = 
      InetAddress.getByName(args[0]);
    System.out.println(a);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<div align="left"> 
  <p><font face="Georgia">В этом случае, машина называется “peppy”. 
    Итак, когда я соединяюсь с моим провайдером, я запускаю программу:</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre>java WhoAmI peppy</pre>
  </font></blockquote>
<div align="left">
  <p><font face="Georgia">Я получаю в ответ сообщение подобное этому (конечно 
    адрес каждый раз новый):</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre>peppy/199.190.87.75</pre>
  </font></blockquote>
<div align="left">
  <p><font face="Georgia">Если я сообщу этот адрес моему другу, и у меня будет 
    Web сервер, запушенный на компьютере, они могут соединиться с ним, зайдя на 
    URL <i>http://199.190.87.75</i> (только пока я остаюсь в этом сеансе связи). 
    Это иногда может быть удобным способом предоставления информации кому-то другому, 
    либо тестирования конфигурации Web сайта перед тем как опубликовать его на 
    “реальном” сервере.</font><a name="_Toc375545493"></a><br>
  </p>
</div>
<a name="Heading513"></a><font face="Verdana">
<h4 align="left"> Сервера и клиенты </h4>
</font>
<div align="left">
  <p><font face="Georgia">Основная задача сети - предоставление двум машинам возможности 
    соединиться и общаться друг с другом. Как только две машины нашли друг друга, 
    они могут отличное иметь двухстороннее общение. Но как они находят друг друга? 
    Это как потеряться в парке развлечений: одна машина должна оставаться на месте 
    и слушать, пока другая машина не скажет, “Эй! Где ты?”</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Машина, которая “остается на одном месте” 
    называется <a name="Index2053"></a><a name="Index2054"></a><i>сервером</i>, 
    а тот, который ищет, называется <a name="Index2055"></a><a name="Index2056"></a><i>клиентом</i>. 
    Это различие важно только когда клиент пытается подключиться к серверу. Как 
    только они соединятся, происходит процесс двухстороннего общения и не важно, 
    что один является сервером, а другой - клиентом.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Итак, работа сервера - слушать соединение, и это выполняется 
    с помощью специального серверного объекта, который Вы создаете. Работа клиента 
    - попытаться создать соединение с сервером, что выполняется с помощью специального 
    клиентского объекта. Как только соединение установлено, Вы увидите, что у 
    клиента и сервера соединение магически превращается в потоковый объект ввода/вывода, 
    и с этого момента Вы можете рассматривать соединение как файл, который Вы 
    можете читать, и в который Вы можете записывать. Т.о., после установления 
    соединения Вы будете использовать уже знакомые Вам команды ввода/вывода из 
    Главы 11. Это одно из отличных расширений сетевой библиотеки Java.</font><br>
  </p>
</div>
<a name="Heading514"></a><font face="Verdana">
<h4 align="left"> Тестирование программ без наличия сети<br>
  <a name="Index2057"></a></h4>
</font> 
<div align="left"> 
  <p><font face="Georgia">По многим причинам, Вам может не быть доступна клиентская 
    машина, серверная машина, и вообще сеть для тестирования Вашей программы. 
    Вы можете выполнить упражнения в классной комнате, либо, Вы можете написать 
    программу, которая недостаточно устойчива для работы в сети. Создатели интернет 
    протокола были осведомлены о таких проблемах, и они создали специальный адрес, 
    называемый <a name="Index2058"></a><a name="Index2059"></a><b>localhost</b>, 
    <a name="Index2060"></a><a name="Index2061"></a>“локальная петля”, 
    который является IP адресом для тестирования без наличия сети. Обычный способ 
    получения этого адреса в Java это:</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre>InetAddress addr = InetAddress.getByName(<font color="#0000ff">null</font>);</pre>
  </font></blockquote>
<div align="left"> 
  <p><font face="Georgia">Если Вы ставите параметр <b>null </b>в метод <b>getByName(&nbsp;)</b>, 
    то, по умолчанию используется <b>localhost</b>. <b>InetAddress</b> это то, 
    что Вы используете для ссылки на конкретную машину, и Вы должны предоставлять 
    это, перед тем как продолжить дальнейшие действия. Вы не можете манипулировать 
    содержанием <b>InetAddress </b>(но Вы можете распечатать его, как Вы увидите 
    в следующем примере). Единственный способ создать <b>InetAddress</b> - это 
    использовать один из перегруженных статических методов <b>getByName(&nbsp;)</b> 
    (который Вы обычно используете), <b>getAllByName(&nbsp;)</b>, либо <b>getLocalHost(&nbsp;)</b>.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Вы можете создать адрес локальной петли, установкой 
    строкового параметра <b>localhost</b>:</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre>InetAddress.getByName(<font color="#004488">"localhost"</font>);</pre>
  </font></blockquote>
<div align="left">
  <p><font face="Georgia">(присваивание “localhost” конфигурируется 
    в таблице “hosts” на Вашей машине), либо с помощью четырехточечной 
    формы для именования зарезервированного IP адреса для петли:</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre>InetAddress.getByName(<font color="#004488">"127.0.0.1"</font>);</pre>
  </font></blockquote>
<div align="left">
  <p><font face="Georgia">Все три формы производят одинаковые результаты.</font><a name="_Toc375545494"></a><br>
  </p>
</div>
<a name="Heading515"></a><font face="Verdana">
<h4 align="left"> Порт: уникальное место <br>
  внутри машины </h4>
</font>
<div align="left">
  <p><font face="Georgia"> IP адреса недостаточно для индикации уникального сервера, 
    т.к. много серверов может существовать на одной машине. Каждая машина в IP 
    также содержит <i>порты</i>, и когда Вы устанавливаете клиента или сервера 
    Вы должны выбрать <a name="Index2062"></a><a name="Index2063"></a>порт, по 
    которому сервер и клиент договорились соединиться; если Вы встречаете кого-то, 
    IP адрес это окрестность и порт это бар.</font><br>
  </p>
</div>
<div align="left"> 
  <p><font face="Georgia">Порт это не физическое расположение в машине, а программная 
    абстракция (большей частью для бухгалтерского назначения). Клиентская программа 
    знает, как соединиться с машиной по IP адресу, но как соединиться с нужной 
    службой (потенциально одной из многих на этой машине)? Вот где номера портов 
    являются вторым уровнем адресации. Идея в том, что Вы запрашиваете конкретный 
    порт, этим запрашивая службу, ассоциированную с этим портом. Время дня это 
    простой пример службы. Обычно, каждая служба ассоциируется с уникальным номером 
    порта на заданной серверной машине. Необходимо знать заранее, на каком порту 
    запущена необходимая служба. </font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Системные службы резервируют номера портов с 1 по 1024, 
    так что Вы не должны использовать ни один из портов, который Вы знаете, что 
    он используется. Первый выбор порта для примеров в этой книге это порт номер 
    8080 (в память почтенного и древнего 8-битного чипа Intel 8080 на моем первом 
    компьютере, с операционной системой CP/M).</font><a name="_Toc375545495"></a><a name="_Toc481064869"></a><br>
  </p>
</div>
<a name="Heading516"></a><font face="Verdana">
<h3 align="left"> Сокеты </h3>
</font>
<div align="left"> 
  <p><font face="Georgia"><i>Сокет</i> это программная абстракция, используемая 
    для представления “терминалов” соединений между двумя машинами. 
    Для данного соединения, существует сокет на каждой машине, и Вы можете представить 
    гипотетический “кабель” соединяющий две машины, каждый конец которого 
    вставлен в сокет. Конечно, какое аппаратное обеспечение и кабель между ними 
    неизвестно. Основной смысл абстракции в том, что нам не нужно знать больше, 
    чем необходимо.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">В Java, Вы создаете сокет для установления соединения 
    с другой машиной, затем Вы получаете <b>InputStream</b> и <b>OutputStream</b> 
    (либо с помощью соответствующих преобразователей, <b>Reader</b> и <b>Writer</b>)<b> 
    </b>из сокета, который соответствующим образом представляет соединение, как 
    потоковый объект ввода вывода. Есть два класса сокетов, основанных на потоках: 
    <b>ServerSocket</b> - используется сервером, чтобы “слушать” входящие 
    соединения и <b>Socket</b> - используется клиентом для инициирования соединения. 
    Как только клиент создает соединение по сокету, <b>ServerSocket</b> возвращает 
    (с помощью метода <b>accept(&nbsp;)</b> <a name="Index2064"></a><a name="Index2065"></a>) 
    соответствующий объект <b>Socket</b> по которому будет происходить связь на 
    стороне сервера. Начиная с этого момента, у Вас появляется соединение <b>Socket</b> 
    к <b>Socket</b>, и Вы считаете эти соединения одинаковыми, потому что они 
    действительно одинаковые. В результате, Вы используете методы <a name="Index2066"></a><a name="Index2067"></a><b>getInputStream(&nbsp;)</b> 
    и <a name="Index2068"></a><a name="Index2069"></a><b>getOutputStream(&nbsp;)</b> 
    для создания соответствующих объектов <b>InputStream</b> и <b>OutputStream</b> 
    из каждого <b>Socket</b>. Они должны быть обернуты внутри буферов и форматирующих 
    классов, как и любой другой потоковый объект, описанный в Главе 11.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia"> <b>ServerSocket</b> может показаться еще одним примером 
    запутанной схемы имен в библиотеках Java. Вы можете подумать, что <b>ServerSocket</b> 
    лучше назвать “ServerConnector” либо как-нибудь иначе без слова 
    “Socket” в нем. Вы также можете подумать, что <b>ServerSocket</b> 
    и <b>Socket</b> должны быть оба унаследованы от одного из базовых классов. 
    В самом деле, оба класса содержат несколько методов совместно, но этого недостаточно, 
    чтобы дать им общий базовых класс. Взамен, работа <b>ServerSocket</b> ожидать, 
    пока не подсоединится другая машина, и затем возвратить подлинный <b>Socket</b>. 
    Вот почему <b>ServerSocket</b> кажется немного неправильно названным, т.к. 
    его работа в действительности не быт сокетом, а просто создавать объект <b>Socket</b>, 
    когда кто-то другой к нему подключается.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Однако <b>ServerSocket</b> создает физический “сервер” 
    либо слушающий сокет на серверной машине. Этот сокет слушает входящие соединения 
    и затем возвращает “установленный” сокет (с определенными локальными 
    и удаленными конечными точками) посредством метода <b>accept(&nbsp;)</b>. 
    В замешательство приводит то, что оба этих сокета (слушающий и установленный) 
    ассоциированы с тем же самым серверным сокетом. Слушающий сокет может допустить 
    только запросы на новое соединение но не пакеты данных. Итак, пока <b>ServerSocket</b> 
    не имеет смысла программного, зато имеет смысл “физический”</font>.<br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Когда Вы создаете <b>ServerSocket</b>, Вы задаете для 
    него только номер порта. Вам не нужно задавать IP адрес, т.к. он уже существует 
    на машине. Однако когда Вы создаете <b>Socket</b>, Вы должны задать и IP адрес 
    и номер порта машины, с которой Вы хотите соединиться. (Тем не менее, <b>Socket</b> 
    который возвращается методом <b>ServerSocket.accept(&nbsp;)</b> уже содержит 
    всю эту информацию.)</font><a name="_Toc375545496"></a><br>
  </p>
</div>
<a name="Heading517"></a><font face="Verdana">
<h4 align="left"> Простой пример сервера и клиента </h4>
</font>
<div align="left">
  <p><font face="Georgia">Этот пример показывает простую работу сервера и клиента 
    используя сокеты. Все, что делает сервер - это просто ожидание соединения, 
    затем использует <b>Socket</b> полученный из того соединения для создания 
    <b>InputStream</b> и <b>OutputStream</b>. Они конвертируются в <b>Reader</b> 
    и <b>Writer</b>, затем в <b>BufferedReader</b> и <b>PrintWriter</b>.<b> </b>После 
    этого, все что он получает из <b>BufferedReader</b> он отправляет на <b>PrintWriter</b> 
    пока не получит строку “END,” после чего, он закрывает соединение.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Клиент устанавливает соединение с сервером, затем создает 
    <b>OutputStream </b>и выполняет те же операции, что и сервер. Строки текста 
    посылаются через результирующий <b>PrintWriter</b>. Клиент также создает <b>InputStream</b> 
    (снова, с соответствующими конверсиями и облачениями) чтобы слушать, что говорит 
    сервер (а в нашем случае он возвращает слова назад).</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">И сервер, и клиент используют один и тот же номер порта, 
    а клиент использует адрес локальной петли для соединения с сервером на той 
    же машине, так что Вам не нужно тестировать это в сети. (Для некоторых конфигураций, 
    Вам не нужно будет подключаться к сети, чтобы программа работала, даже если 
    Вы общаетесь по сети.)</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Вот сервер:</font><br>
  </p>
</div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c15:JabberServer.java</font>
<font color="#009900">// Очень простой сервер, который только</font>
<font color="#009900">// отображает то, что посылает клиент.</font>
<font color="#0000ff">import</font> java.io.*;
<font color="#0000ff">import</font> java.net.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> JabberServer {  
  <font color="#009900">// Выбираем номер порта за пределами 1-1024:</font>
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">final</font> <font color="#0000ff">int</font> PORT = 8080;
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) 
      <font color="#0000ff">throws</font> IOException {
    ServerSocket s = <font color="#0000ff">new</font> ServerSocket(PORT);
    System.out.println(<font color="#004488">"Started: "</font> + s);
    <font color="#0000ff">try</font> {
      <font color="#009900">// Блокируем пока не произойдет соединение:</font>
      Socket socket = s.accept();
      <font color="#0000ff">try</font> {
        System.out.println(
          <font color="#004488">"Connection accepted: "</font>+ socket);
        BufferedReader in = 
          <font color="#0000ff">new</font> BufferedReader(
            <font color="#0000ff">new</font> InputStreamReader(
              socket.getInputStream()));
        <font color="#009900">// Вывод автоматически обновляется </font>
        <font color="#009900">// классом PrintWriter:</font>
        PrintWriter out = 
          <font color="#0000ff">new</font> PrintWriter(
            <font color="#0000ff">new</font> BufferedWriter(
              <font color="#0000ff">new</font> OutputStreamWriter(
                socket.getOutputStream())),<font color="#0000ff">true</font>);
        <font color="#0000ff">while</font> (<font color="#0000ff">true</font>) {  
          String str = in.readLine();
          <font color="#0000ff">if</font> (str.equals(<font color="#004488">"END"</font>)) <font color="#0000ff">break</font>;
          System.out.println(<font color="#004488">"Echoing: "</font> + str);
          out.println(str);
        }
      <font color="#009900">// всегда закрываем оба сокета...</font>
      } <font color="#0000ff">finally</font> {
        System.out.println(<font color="#004488">"closing..."</font>);
        socket.close();
      }
    } <font color="#0000ff">finally</font> {
      s.close();
    }
  } 
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<div align="left">
  <p><font face="Georgia">Вы видите, что объекту <b>ServerSocket</b> нужен только 
    номер порта, не IP адрес (т.к. он запущен на <i>этой</i> машине!). Когда Вы 
    вызываете метод <b>accept(&nbsp;)</b>, метод <i>блокирует</i> выполнение программы, 
    пока какой-нибудь клиент не попробует соединиться. То есть, он ожидает соединение, 
    но другие процессы могут выполняться (см. Главу 14). Когда соединение сделано, 
    <b>accept(&nbsp;)</b> возвращает объект <b>Socket</b> представляющий это соединение. 
    </font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Ответственность за очищение сокетов is crafted carefully 
    here. Если конструктор <b>ServerSocket</b> завершается неуспешно, программа 
    просто завершается (обратите внивание, что мы должны считать что конструктор 
    <b>ServerSocket</b> не оставляет открытых сетевых сокетов если он завершается 
    неудачно). В этом случает, <b>main(&nbsp;)</b> выбрасывает исключение <b>IOException</b> 
    и блок <b>try</b> не обязателен. Если конструктор <b>ServerSocket</b> завершается 
    успешно, то остальные вызовы методов должны быть окружены блоками <b>try-finally</b>, 
    чтобы убедиться, что независимо от того как блок завершит работу, <b>ServerSocket</b> 
    будет корректно закрыт.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Та же логика используется для <b>Socket</b> возвращаемого 
    методом <b>accept(&nbsp;)</b>. Если вызов <b>accept(&nbsp;)</b> неуспешный, 
    то мы должны считать что <b>Socket</b> не существует и не держит никаких ресурсов, 
    так что он не нуждается в очистке. Но, если вызов успешный, следующи объявления 
    должны быть окружены блоками <b>try-finally</b> так что в случае неуспешного 
    вызова <b>Socket</b> будет очищен. Заботиться здесь об этом обязательно, т.к. 
    сокеты используют важные ресурсы располагающиеся не в памяти, так что Вы должны 
    тщательно очищать их (поскольку в Java нет деструктора, чтобы сделать это 
    за Вас).</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">И <b>ServerSocket</b> и <b>Socket</b> созданные методом 
    <b>accept(&nbsp;)</b> печатаются в <b>System.out</b>. Это значит, что их методы 
    <b>toString(&nbsp;)</b> вызываются автоматически. Вот что получается:</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre>ServerSocket[addr=0.0.0.0,PORT=0,localport=8080]
Socket[addr=127.0.0.1,PORT=1077,localport=8080]</pre>
  </font></blockquote>
<div align="left">
  <p><font face="Georgia">Скоро Вы увидите как how они объединяются вместе с тем 
    что делает клиент.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Следующая часть программы выглядит как программа для 
    для открытия файлов для чтения и записи за исключением того, что <b>InputStream</b> 
    и <b>OutputStream</b> создаются из объекта <b>Socket</b>. И объект <b>InputStream</b> 
    и объект <b>OutputStream </b>конвертируются в объекты <a name="Index2070"></a><a name="Index2071"></a><b>Reader 
    </b>и <a name="Index2072"></a><a name="Index2073"></a><b>Writer</b> используя 
    классы “конвертеры” <a name="Index2074"></a><a name="Index2075"></a><b>InputStreamReader</b> 
    и <a name="Index2076"></a><a name="Index2077"></a><b>OutputStreamWriter</b>, 
    соответственно. Вы можете также использовать напрямую классы из Java 1.0 <a name="Index2078"></a><a name="Index2079"></a><b>InputStream</b> 
    и <a name="Index2080"></a><a name="Index2081"></a><b>OutputStream</b>, но 
    с выводом есть явное преимущество при использовании <b>Writer</b>. Это реализуется 
    с помощью <a name="Index2082"> </a><a name="Index2083"></a><b>PrintWriter</b>, 
    в котором перегруженный конструктор берет второй аргумент, а <b>boolean </b>флаг 
    который индицирует когда какой автоматически сбрасывает вывод в конце каждого 
    вывода <b>println(&nbsp;)</b> (но не<i> </i><b>print(&nbsp;)</b>) выражения. 
    Каждый раз, когды Вы направляете данные в <b>out</b>, его буфер должен сбрасываться 
    так информация передается о сети. Сброс важен для этого конкретного примера, 
    т.к. клиент и сервер ждут строку данных друг от друга, перед тем, как что-то 
    сделать. Если сброса буферов не происходит, информация не будет отправлена 
    по сети, пока буфер полон, что вызовем много проблем в этом примере.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">При написании сетевых программ Вы должны быть внимательными, 
    прииспользовании автоматического сброса буферов. Каждый раз, когда Вы сбрасываете 
    буфер, пакет должен создаться и отправиться. В этом случае, это именно то, 
    что мы хотим, т.к. если пакет, содержащий строку не отослан то обмен информацией 
    между сервером и клиентом остановится. С другой стороны, конец строки это 
    конец сообщения. Но во многих случаях, сообщения не ограничиваются строками, 
    так что более эффектино будет не использовать автоматический сброс, а позволить 
    встроенной буферизации решать, когда необходимо создать и отослать пакеты. 
    В этом случае, могут отсылаться большие пакеты и процесс пойдет быстрее.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Запомните, все потоки, которые Вы открываете, буферизованы. 
    В конце этой главы есть упражнение, показывающее Вам, что происходит, если 
    Вы не буферизуете потоки (все замедляется).</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Бесконечный цикл <b>while</b> читает строки из <b> BufferedReader 
    in </b>и записывает информацию в<b>System.out</b> and to the <b>PrintWriter</b> 
    <b>out</b>. Запомните, что <b>in</b> и <b>out</b> могут быть любыми потоками, 
    они просто соединены в сети. </font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Когда клиент отсылает строку, состоящую из “END,” 
    программа прерывает выполнение цикла и закрывает <b>Socket</b>. </font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Вот клиент:</font><br>
  </p>
</div>
<blockquote><font size="+1"> 
  </font><pre><font size="+1"><font color="#009900">//: c15:JabberClient.java</font>
<font color="#009900">// Очень простой клиент, который просто отсылает строки серверу</font>
<font color="#009900">// и читает строки, которые посылает сервер</font>
<font color="#0000ff">import</font> java.net.*;
<font color="#0000ff">import</font> java.io.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> JabberClient {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) 
      <font color="#0000ff">throws</font> IOException {
    <font color="#009900">// Установка параметра в null в getByName()</font>
    <font color="#009900">// возвращает специальный IP address - "Локальную петлю"</font><font color="#009900">,</font>
    <font color="#009900">// для тестирования на одной машине без наличия сети</font>
    InetAddress addr = 
      InetAddress.getByName(<font color="#0000ff">null</font>);
    <font color="#009900">// Альтернативно Вы можете использовать </font>
    <font color="#009900">// адрес или имя:</font>
    <font color="#009900">// InetAddress addr = </font>
    <font color="#009900">//    InetAddress.getByName("127.0.0.1");</font>
    <font color="#009900">// InetAddress addr = </font>
    <font color="#009900">//    InetAddress.getByName("localhost");</font>
    System.out.println(<font color="#004488">"addr = "</font> + addr);
    Socket socket = 
      <font color="#0000ff">new</font> Socket(addr, JabberServer.PORT);
    <font color="#009900">// Окружаем все блоками try-finally to make</font>
    <font color="#009900">// чтобы убедиться что сокет закрывается:</font>
    <font color="#0000ff">try</font> {
      System.out.println(<font color="#004488">"socket = "</font> + socket);
      BufferedReader in =
        <font color="#0000ff">new</font> BufferedReader(
          <font color="#0000ff">new</font> InputStreamReader(
            socket.getInputStream()));
      <font color="#009900">// Вывод автоматически сбрасывается</font>
      <font color="#009900">// с помощью PrintWriter:</font>
      PrintWriter out =
        <font color="#0000ff">new</font> PrintWriter(
          <font color="#0000ff">new</font> BufferedWriter(
            <font color="#0000ff">new</font> OutputStreamWriter(
              socket.getOutputStream())),<font color="#0000ff">true</font>);
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i ++) {
        out.println(<font color="#004488">"howdy "</font> + i);
        String str = in.readLine();
        System.out.println(str);
      }
      out.println(<font color="#004488">"END"</font>);
    } <font color="#0000ff">finally</font> {
      System.out.println(<font color="#004488">"closing..."</font>);
      socket.close();
    }
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<div align="left">
  <p><font face="Georgia">В методе <b>main(&nbsp;)</b> Вы видите все три пути 
    для возврата IP адреса локальной петли: используя <b>null</b>, <b>localhost</b>, 
    либо явно зарезервированный адрес <b>127.0.0.1</b>. Конечно, если Вы хотите 
    соединиться с машиной в сети Вы подставляете IP адрес этой машины. Когда <b>InetAddress 
    addr</b> печатается (с помощью автоматического вызова метода <b>toString(&nbsp;)</b>) 
    получается следующий результат:</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre>localhost/127.0.0.1</pre>
  </font></blockquote>
<div align="left">
  <p><font face="Georgia">Подстановкой параметра <b>null </b>в<b> getByName(&nbsp;)</b>, 
    она по умолчанию использует <b>localhost</b>, и это создает специальный адрес 
    <b>127.0.0.1</b>.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Обратите внимание, что <a name="Index2084"></a><a name="Index2085"></a><b>Socket</b> 
    названный <b>socket</b> создается и с типом <b>InetAddress</b> и с номером 
    порта. Чтобы понимать, что это значит, кгда Вы печаете один из этих объектов 
    <b>Socket</b>, помните, что соединение с Интернет определяется уникально этими 
    четырьмя элементами данных: <b>clientHost</b>, <b>clientPortNumber</b>, <b>serverHost</b>, 
    и <b>serverPortNumber</b>. Когда сервер запускается, он берет присвоенный 
    ему порт (8080) на localhost (127.0.0.1). Когда клиент приходит, распределяется 
    следующий доступный порт на той же машине, в нашем случае - 1077, который, 
    так случилось, оказался расположен на той же самой машине (127.0.0.1), что 
    и сервер. Теперь, необходимо данные перемещать между клиентом и сервером, 
    каждая сторона должнва знать, куда их посылать. Поэтому, во время процесса 
    соединения с “известным” сервером, клиент посылает “обратный 
    адрес”, так что сервер знает, куда отсылать его данные. Вот, что Вы 
    видите в примере серверной части:</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre>Socket[addr=127.0.0.1,port=1077,localport=8080]</pre>
  </font></blockquote>
<div align="left">
  <p><font face="Georgia">Это значит, что сервер тоьлко что принял соединение 
    с адреса 127.0.0.1 и порта 1077 когда слушал свой локальный порт (8080). На 
    стороне клиента:</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre>Socket[addr=localhost/127.0.0.1,PORT=8080,localport=1077]</pre>
  </font></blockquote>
<div align="left">
  <p><font face="Georgia">это значит, что клиент создал соединение с адресом 127.0.0.1 
    и портом 8080, используя локальный порт 1077.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Вы увидите, что каждый раз, когда Вы запускаете нового 
    клиента, номер локального порта увеличивается. Отсчет начинается с 1025 (предыдущие 
    являются зарезервированными) и продолжается до того момента, пока Вы не перезагрузите 
    машину, после чего он снова начинается с 1025. (На UNIX машинах, как только 
    достигается максимальное число сокетов, нумерация начинается с самого меньшего 
    доступного номера.)</font><br>
  </p>
</div>
<div align="left"> 
  <p><font face="Georgia">Как только объект <b>Socket</b> создан, процесс превода 
    его в <b>BufferedReader</b> и <b>PrintWriter</b> тот же самый, что и в серверной 
    части (снова, в обоих случаях Вы начинаете с <b>Socket</b>). Здесь, клиент 
    инициирует соединение отсылкой строки “howdy” следующе за номером. 
    Обратите внимание, что буфер должен быть снова сброшен (что происходит автоматически 
    по второму аргументу в конструкторе <b>PrintWriter</b>). Если буфер не будет 
    сброшен, все общение зависнет, т.к. строка “howdy” никогда не 
    будет отослана (буфер не будет достаточно полным, чтобы выполнить отсылку 
    автоматически). Каждая строка, отсылаемая сервером обратно записывается в 
    <b>System.out</b> для проверки, что все работает правильно. Для прекращения 
    общения, отсылается условный знак - строка “END”. Если клиент 
    прервывает соединение, то сервер выбрасывает исключение.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Вы видите, что такая же забота здесь тоже присутствует, 
    чтобы убедиться, что ресурсы представленные <b>Socket</b> корректно освобождаются, 
    с помощью блока <b>try-finally</b>.</font><br>
  </p>
</div>
<div align="left"> 
  <p><font face="Georgia">Сокеты создают <a name="Index2086"></a>“подписанное” 
    (dedicated) соединение, которое сохраняется, пока не произойдет явный разрыв 
    соединения. (Подписанное соединение может еще быть разорвано неявно, если 
    одна сторона , либо промежуточное соединение, разрушается.) Это значит, что 
    обе стороны заблокированы в общении и соединение постоянно открыто. Кажется, 
    что это просто логический подход к передаче данных, однако это дает дополнительную 
    нагрузку на сеть. Позже, в этой главе Вы увидите другой метод передачи данных 
    по сети, в котором соединения являются временными.</font><a name="_Toc375545497"></a><a name="_Toc481064870"></a><br>
  </p>
</div>
<a name="Heading518"></a><font face="Verdana">
<h3 align="left"> Обслуживание нескольких клиентов<br>
  <a name="Index2087"></a></h3>
</font> 
<div align="left"> 
  <p><font face="Georgia"><b>JabberServer</b> работает, но он может обслуживать 
    только одного клиента одновременно. В типичном сервере, Вы захотите иметь 
    возможность общаться со несколькими клиентами одновременно. Решение - это 
    <a name="Index2088"></a><a name="Index2089"></a>много поточность, а в языках, 
    которые напрямую не поддерживают многопоточность это означает все виды сложностей. 
    В Главе 14 Вы увидели, что многопоточность в Java настолько просто, насколько 
    это возможно, в то время, как многопоточность вообще является сложной темой. 
    Т.к. поддерка нитей в Java является прямой и открытой, то создание сервера, 
    поддерживающего множество клиентов оказывается относительно простой задачей.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Основная схема это создание единичного объекта <b>ServerSocket</b> 
    в серверной части и вызвать метод <b>accept(&nbsp;)</b> для ожидания нового 
    соединения. Когда <b>accept(&nbsp;)</b> возвращает управления, Вы берете возвращенный 
    <b>Socket</b> и используете его для создания новой нити(потока), чьей работой 
    является обслуживание этого клиента. Затем Вы вызываете метод <b>accept(&nbsp;)</b> 
    снова, для ожидания нового клиента.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">В следующем коде серверной части Вы увидите, что это 
    выглядит также как и в примере <b>JabberServer.java</b> за исключением того, 
    что все операции по обслуживанию конкретного клиента перемещены внутрь класса 
    нити (потока):</font><br>
  </p>
</div>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c15:MultiJabberServer.java</font>
<font color="#009900">// Сервер, использующий многопоточность </font>
<font color="#009900">// для обслуживания любого числа клиентов.</font>
<font color="#0000ff">import</font> java.io.*;
<font color="#0000ff">import</font> java.net.*;

<font color="#0000ff">class</font> ServeOneJabber <font color="#0000ff">extends</font> Thread {
  <font color="#0000ff">private</font> Socket socket;
  <font color="#0000ff">private</font> BufferedReader in;
  <font color="#0000ff">private</font> PrintWriter out;
  <font color="#0000ff">public</font> ServeOneJabber(Socket s) 
      <font color="#0000ff">throws</font> IOException {
    socket = s;
    in = 
      <font color="#0000ff">new</font> BufferedReader(
        <font color="#0000ff">new</font> InputStreamReader(
          socket.getInputStream()));
    <font color="#009900">// Включение автосброса буферов:</font>
    out = 
      <font color="#0000ff">new</font> PrintWriter(
        <font color="#0000ff">new</font> BufferedWriter(
          <font color="#0000ff">new</font> OutputStreamWriter(
            socket.getOutputStream())), <font color="#0000ff">true</font>);
    <font color="#009900">// Если какой либо, указанный выше класс выбросит исключение </font>
    <font color="#009900">// вызывающая процедура ответственна за закрытие сокета</font>
    <font color="#009900">// В противном случае нить(поток) закроет его</font><font color="#009900">.</font>

    start(); <font color="#009900">// Вызывает run()</font>
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> run() {
    <font color="#0000ff">try</font> {
      <font color="#0000ff">while</font> (<font color="#0000ff">true</font>) {  
        String str = in.readLine();
        <font color="#0000ff">if</font> (str.equals(<font color="#004488">"END"</font>)) <font color="#0000ff">break</font>;
        System.out.println(<font color="#004488">"Echoing: "</font> + str);
        out.println(str);
      }
      System.out.println(<font color="#004488">"closing..."</font>);
    } <font color="#0000ff">catch</font>(IOException e) {
      System.err.println(<font color="#004488">"IO Exception"</font>);
    } <font color="#0000ff">finally</font> {
      <font color="#0000ff">try</font> {
        socket.close();
      } <font color="#0000ff">catch</font>(IOException e) {
        System.err.println(<font color="#004488">"Socket not closed"</font>);
      }
    }
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> MultiJabberServer {  
  <font color="#0000ff">static</font> <font color="#0000ff">final</font> <font color="#0000ff">int</font> PORT = 8080;
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args)
      <font color="#0000ff">throws</font> IOException {
    ServerSocket s = <font color="#0000ff">new</font> ServerSocket(PORT);
    System.out.println(<font color="#004488">"Server Started"</font>);
    <font color="#0000ff">try</font> {
      <font color="#0000ff">while</font>(<font color="#0000ff">true</font>) {
        <font color="#009900">// Останавливает выполнение, до нового соединения:</font>
        Socket socket = s.accept();
        <font color="#0000ff">try</font> {
          <font color="#0000ff">new</font> ServeOneJabber(socket);
        } <font color="#0000ff">catch</font>(IOException e) {
          <font color="#009900">// Если неудача - закрываем сокет,</font>
          <font color="#009900">// в противном случае нить закроет его:</font>
          socket.close();
        }
      }
    } <font color="#0000ff">finally</font> {
      s.close();
    }
  } 
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<div align="left">
  <p><font face="Georgia">Нить <b>ServeOneJabber </b>берет объект <b>Socket,</b> 
    который создается<b> </b>методом <b>accept(&nbsp;)</b> в <b>main(&nbsp;)</b> 
    каждый раз, когда новый клиент создает соединение. Затем, как раньше, он создает 
    объект <b>BufferedReader</b> и объект <b>PrintWriter</b> с авто-сбросом используя 
    <b>Socket</b>. Наконец, он вызывает специальный метод объекта <b>Thread</b> 
    - <b>start(&nbsp;)</b>, который выполняет инициализации в нити и, затем вызывает 
    метод <b>run(&nbsp;)</b>. Здесь выполняются те же действия, что и в предыдущем 
    примере: чтение данных из сокета, а затем возврат этих данных обратно, пока 
    не придет специальный сигнал - строка “END”.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Ответственность за очистку сокета должна быть снова 
    тщательно обработана. В этом случае, сокет создается за пределами <b>ServeOneJabber</b> 
    так что ответственность может быть разделена. Если конструктор <b>ServeOneJabber</b> 
    завершится неудачно, он просто вызовет исключение вызывающему методу, который 
    затем очистит нить. Но если конструктор завершится успешно, то объект <b>ServeOneJabber</b> 
    возьмет ответственность за очистку нить на себя, в его методе <b>run(&nbsp;)</b>.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Посмотрите, насколько протая реализация у <b>MultiJabberServer</b>. 
    Как раньше, <b>ServerSocket</b> создается и вызывается метод <b>accept(&nbsp;)</b> 
    для ожидания нового соединения. Но в этот момент, возвращаемое значение <b>accept(&nbsp;)</b> 
    (объекты <b>Socket</b>) передается в конструктор <b>ServeOneJabber,</b> который 
    создает новую нить для обраболтки этого соединения. Когда соединение закрывается, 
    нить завершает свою работу.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Если создание <b>ServerSocket</b> прерывается, снова 
    выбрасывается в <b>main(&nbsp;)</b>. Но если создание успешное, внешний блок 
    <b>try-finally</b> гарантирует его очистку. Внутренний блок <b>try-catch</b> 
    защищает только от ошибок в конструкторе <b>ServeOneJabber</b>; если конструктор 
    выполняется без ошибок, то нить <b>ServeOneJabber</b> закроет связанный с 
    ней сокет.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Для проверки того, что сервер поддерживает несколько 
    клиентов, следующая программа создает множество клиентов (используя нити) 
    которые подключаются к одному и тому же серверу. Максимальное число нитей 
    определяется переменной <b>final int MAX_THREADS</b>. </font><br>
  </p>
</div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c15:MultiJabberClient.java</font>
<font color="#009900">// Клиент для проверки MultiJabberServer</font>
<font color="#009900">// посредством запуска множества клиентов.</font>
<font color="#0000ff">import</font> java.net.*;
<font color="#0000ff">import</font> java.io.*;

<font color="#0000ff">class</font> JabberClientThread <font color="#0000ff">extends</font> Thread {
  <font color="#0000ff">private</font> Socket socket;
  <font color="#0000ff">private</font> BufferedReader in;
  <font color="#0000ff">private</font> PrintWriter out;
  <font color="#0000ff">private</font> <font color="#0000ff">static</font> <font color="#0000ff">int</font> counter = 0;
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> id = counter++;
  <font color="#0000ff">private</font> <font color="#0000ff">static</font> <font color="#0000ff">int</font> threadcount = 0;
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">int</font> threadCount() { 
    <font color="#0000ff">return</font> threadcount; 
  }
  <font color="#0000ff">public</font> JabberClientThread(InetAddress addr) {
    System.out.println(<font color="#004488">"Making client "</font> + id);
    threadcount++;
    <font color="#0000ff">try</font> {
      socket = 
        <font color="#0000ff">new</font> Socket(addr, MultiJabberServer.PORT);
    } <font color="#0000ff">catch</font>(IOException e) {
      System.err.println(<font color="#004488">"Socket failed"</font>);
      <font color="#009900">// Если сокет не создался, </font>
      <font color="#009900">// ничего не надо чистить.</font>
    }
    <font color="#0000ff">try</font> {    
      in = 
        <font color="#0000ff">new</font> BufferedReader(
          <font color="#0000ff">new</font> InputStreamReader(
            socket.getInputStream()));
      <font color="#009900">// Включение авто-очистки буфера:</font>
      out = 
        <font color="#0000ff">new</font> PrintWriter(
          <font color="#0000ff">new</font> BufferedWriter(
            <font color="#0000ff">new</font> OutputStreamWriter(
              socket.getOutputStream())), <font color="#0000ff">true</font>);
      start();
    } <font color="#0000ff">catch</font>(IOException e) {
      <font color="#009900">// Сокет должен быть закрыт при появлении любой ошибки </font>
      <font color="#0000ff">try</font> {
        socket.close();
      } <font color="#0000ff">catch</font>(IOException e2) {
        System.err.println(<font color="#004488">"Socket not closed"</font>);
      }
    }
    <font color="#009900">// Иначе сокет будет закрыт </font>
    <font color="#009900">// методом run() у нити.</font>
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> run() {
    <font color="#0000ff">try</font> {
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 25; i++) {
        out.println(<font color="#004488">"Client "</font> + id + <font color="#004488">": "</font> + i);
        String str = in.readLine();
        System.out.println(str);
      }
      out.println(<font color="#004488">"END"</font>);
    } <font color="#0000ff">catch</font>(IOException e) {
      System.err.println(<font color="#004488">"IO Exception"</font>);
    } <font color="#0000ff">finally</font> {
      <font color="#009900">// Всегда закрывает его:</font>
      <font color="#0000ff">try</font> {
        socket.close();
      } <font color="#0000ff">catch</font>(IOException e) {
        System.err.println(<font color="#004488">"Socket not closed"</font>);
      }
      threadcount--; <font color="#009900">// Завершение нити</font>
    }
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> MultiJabberClient {
  <font color="#0000ff">static</font> <font color="#0000ff">final</font> <font color="#0000ff">int</font> MAX_THREADS = 40;
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) 
      <font color="#0000ff">throws</font> IOException, InterruptedException {
    InetAddress addr = 

      InetAddress.getByName(<font color="#0000ff">null</font>);
    <font color="#0000ff">while</font>(<font color="#0000ff">true</font>) {
      <font color="#0000ff">if</font>(JabberClientThread.threadCount() 
         &lt; MAX_THREADS)
        <font color="#0000ff">new</font> JabberClientThread(addr);
      Thread.currentThread().sleep(100);
    }
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<div align="left">
  <p><font face="Georgia">Конструктор <b>JabberClientThread</b> берет <b>InetAddress</b> 
    и использует его для открытия <b>Socket</b>. Вы возпожно уже начинаете видешь 
    шаблон: <b>Socket</b> используется всегда для создания некоторых типов <b>Reader 
    </b>и/или <b>Writer </b>(или <b>InputStream</b> и/или <b>OutputStream</b>) 
    объект, что является единственным способом, в котором <b>Socket</b> может 
    быть использован. (Вы можете, конечно, написать один-два класса для автоматизации 
    этого процесса, вместо того , чтобы заново все это набирать, если для Вас 
    это сложно.) Итак, <b>start(&nbsp;)</b> выполняет инициализации нити и вызывает 
    метод <b>run(&nbsp;)</b>. Здесь, сообщения отсылаются серверу и информация 
    с сервера печатается на экране. Однако, нить имеет ограниченное время жизни 
    и в один прекрасный момент завершается. Обратите внимание, что сокет очищается 
    если конструктор завершается неуспешно, после того как сокет создается, но 
    перед тем, как конструктор завершится. В противном случае ответственность 
    за вызов метода <b>close(&nbsp;)</b> для сокета ложится на метод <b>run(&nbsp;)</b>.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">Переменная <b>threadcount</b> хранит число - сколько 
    объектов <b>JabberClientThread</b> в данный момент существует. Она увеличивается 
    в конструкторе и уменьшается при выходе из метода <b>run(&nbsp;)</b> (и это 
    значит, что нить завершается). В методе <b>MultiJabberClient.main(&nbsp;),</b> 
    Вы видите, что число нитей проверяется, и если нитей слишком много - новые 
    не создаются. Затем метод засыпает. При этом, некоторые нити будут завершаться 
    и новые смогут быть созданы. Вы можете поэкспериментировать с <b>MAX_THREADS</b>, 
    чтобы посмотреть когда у Вашей системы появятся проблемы с обслуживанием большого 
    количества соединений.</font><a name="_Toc375545498"></a><a name="_Toc481064871"></a><br>
  </p>
</div>
<p><a name="Heading519"></a> </p>
<h3 align="left"><font face="Verdana">Дейтаграммы<br>
  <a name="Index2090"></a><a name="Index2091"></a></font></h3>
<div align="left">
  <p><font face="Georgia">Примеры, которые Вы увидели используют протокол<a name="Index2092"></a><a name="Index2093"></a><a name="Index2094"></a><i>Transmission 
    Control Protocol</i> (TCP, также известный как<a name="Index2095"></a><a name="Index2096"></a><a name="Index2097"></a><i>сокеты 
    основанные на потоках</i>), который создан для исключительной надежности и 
    гарантирует, что данные будут доставлены туда, куда необходимо. Он позволяет 
    организовать повторную передачу потерянных данных, он предоставляет возможность 
    отсылки отдельных частей через разные маршрутизаторы, в случает если один 
    из них выйдет из строя, и байты будут приняты именно в том порядке, в ктором 
    они были посланы. Весь этот контроль и надежность имеет цену: в TCP высокие 
    накладные расходы.</font><br>
  </p>
</div>
<div align="left"> 
  <p><font face="Georgia">Существует второй протокол, называемый <a name="Index2098"></a><a name="Index2099"></a><a name="Index2100"></a><a name="Index2101"></a><i>User 
    Datagram Protocol</i> (UDP), который не гарантирует, что пакеты будут доставлены 
    и не гарантирует доставки в том порядке, в котором они были посланы. Он называется 
    “<a name="Index2102"></a><a name="Index2103"></a>ненадежным протоколом” 
    (TCP это <a name="Index2104"></a><a name="Index2105"></a>“надежный протокол”), 
    и это звучит не очень хорошо, однако он намного быстрее и потому может быть 
    полезным. Существуют некоторые приложения, такие как аудио сигналы, в которых 
    потеря нескольких пакетов не очень не имеет большого значения, но скорость 
    очень важна. Либо представьте сервер предоставляющий информацию о времени, 
    где действительно не имеет значени, если одно из сообщений потеряется. Также, 
    некоторые приложения могут посылать UDP сообщения на сервер, а затем, при 
    отсутствии отклика в течение некоторого времени, считать, что сообщение было 
    потеряно.</font><br>
  </p>
</div>
<div align="left">
  <p><font face="Georgia">На самом деле, Вы будете делать большинство сетевых 
    приложений с протоколом TCP, и только некоторые будут испольовать UDP. Существует 
    более полное описание UDP, включающее примеры, в первой редакции книги (доступных 
    на CD ROM вместе с книгой, либо свободно загружаемы с сайта <i>www.BruceEckel.com</i>).</font><a name="_Toc481064872"></a><br>
  </p>
</div>
<a name="Heading520"></a>
<h3 align="left"><font face="Verdana"> Использование ссылок URL внутри апплета<br>
  <a name="Index2106"></a><a name="Index2107"></a><a name="Index2108"></a></font></h3>
<div align="left">
  <p><font face="Georgia">Апплеты могут отобразить любую ссылку URL через Web 
    браузер, внутри которого запускается апплет. Вы можете выполнить это с помощью 
    следующей строки:</font><br>
  </p>
</div>
<blockquote>
  <pre><font size="+1">getAppletContext().showDocument(u);</font></pre>
</blockquote>
<div align="left"> 
  <p><a name="Index2109"></a><a name="Index2110"></a>в которой <font face="Georgia"> 
    <b>u</b> - это объект <b>URL</b>. Вот простой пример, который перенаправляет 
    Вас на другую Web страничку. Хотя, Вы перенаправляетесь на HTML страничку, 
    Вы также можете перенаправить на программу CGI.</font><br>
  </p>
</div>
<blockquote>
  <pre><font color="#009900" size="+1">//: c15:ShowHTML.java</font>
<font color="#009900" size="+1">// &lt;applet code=ShowHTML width=100 height=50&gt;</font>
<font color="#009900" size="+1">// &lt;/applet&gt;</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.net.*;
<font color="#0000ff">import</font> java.io.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> ShowHTML <font color="#0000ff">extends</font> JApplet {
  JButton send = <font color="#0000ff">new</font> JButton(<font color="#004488">"Go"</font>);
  JLabel l = <font color="#0000ff">new</font> JLabel();
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    send.addActionListener(<font color="#0000ff">new</font> Al());
    cp.add(send);
    cp.add(l);
  }
  <font color="#0000ff">class</font> Al <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> actionPerformed(ActionEvent ae) {
      <font color="#0000ff">try</font> {
        <font color="#009900">// Это может быть программа CGI вместо</font></font>
        <font color="#009900" size="+1">// HTML странички.</font><font size="+1">
        URL u = <font color="#0000ff">new</font> URL(getDocumentBase(), 
          <font color="#004488">"FetcherFrame.html"</font>);
        <font color="#009900">// Отображается вывод URL используя</font></font>
        <font color="#009900" size="+1">// Web браузер, как обычную страничку:</font><font size="+1">
        getAppletContext().showDocument(u);
      } <font color="#0000ff">catch</font>(Exception e) {
        l.setText(e.toString());
      }
    }
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> ShowHTML(), 100, 50);
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<div align="left">
  <p><font face="Georgia">Красота класса <a name="Index2111"></a><a name="Index2112"></a><b>URL</b> 
    в том, насколько сильно Вас он защищает от тонкостей реализации стороны сервера. 
    Вы можете присоединиться к Web серверу практически ничего не зная, что происходит 
    у него внутри.</font><br>
  </p>
</div>
<a name="Heading521"></a>
<h4 align="left"><font face="Verdana"> Чтение файла с сервера</font></h4>
<div align="left">
  <p><font face="Georgia">Вариация приведенной выше программы читает файл, расположенный 
    на сервере. В этом случае, файл определяется клиентом:</font><br>
  </p>
</div>
<blockquote>
  <pre><font color="#009900" size="+1">//: c15:Fetcher.java</font>
<font color="#009900" size="+1">// &lt;applet code=Fetcher width=500 height=300&gt;</font>
<font color="#009900" size="+1">// &lt;/applet&gt;</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.net.*;
<font color="#0000ff">import</font> java.io.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> Fetcher <font color="#0000ff">extends</font> JApplet {
  JButton fetchIt= <font color="#0000ff">new</font> JButton(<font color="#004488">"Fetch the Data"</font>);
  JTextField f = 
    <font color="#0000ff">new</font> JTextField(<font color="#004488">"Fetcher.java"</font>, 20);
  JTextArea t = <font color="#0000ff">new</font> JTextArea(10,40);
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    fetchIt.addActionListener(<font color="#0000ff">new</font> FetchL());
    cp.add(<font color="#0000ff">new</font> JScrollPane(t));
    cp.add(f); cp.add(fetchIt);
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> FetchL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> actionPerformed(ActionEvent e) {
      <font color="#0000ff">try</font> {
        URL url = <font color="#0000ff">new</font> URL(getDocumentBase(),
          f.getText());
        t.setText(url + <font color="#004488">"\n"</font>);
        InputStream is = url.openStream();
        BufferedReader in = <font color="#0000ff">new</font> BufferedReader(
          <font color="#0000ff">new</font> InputStreamReader(is));
        String line;
        <font color="#0000ff">while</font> ((line = in.readLine()) != <font color="#0000ff">null</font>)
          t.append(line + <font color="#004488">"\n"</font>);
      } <font color="#0000ff">catch</font>(Exception ex) {
        t.append(ex.toString());
      }
    }
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Fetcher(), 500, 300);
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<div align="left">
  <p><font face="Georgia">Создание объекта <b>URL</b> сходно с пердыдущим примером 
    —<b>getDocumentBase(&nbsp;)</b> - стартовая позиция как и раньше, но 
    в это т раз имя файла читается из поля <b>JTextField</b>. Как только объект 
    <b>URL</b> создан, его строковая версия отображается в <b>JTextArea</b> так 
    что мы видим, как она выглядит. Затем создается <b>InputStream</b> из <b>URL</b>, 
    который в этом случае легко создает поток символов в файле. После конвертирования 
    в <b>Reader</b> и буферизации, читается каждая строка и добавляется в <b>JTextArea</b>. 
    Обратите внимание, что <b>JTextArea</b> было помещено внутрь <b>JScrollPane</b> 
    так что прокрутка происходит автоматически.</font><a name="_Toc481064873"></a><br>
  </p>
</div>
<a name="Heading522"></a>
<h3 align="left"><font face="Verdana"> Дальнейшее сетевое программирование</font></h3>
<div align="left">
  <p><font face="Georgia">На самом деле существует еще множество вещей, которые 
    могли бы аходиться в этом разделе. Сетевая поддержка в Java также широкую 
    поддержку URLs, включая управление протоколами для различных типов содержания. 
    Все это может быть найдено на интернет сайте. Вы можете найти полное и подробное 
    описание сетевого программирования на Java в книге <i>Java Network Programming</i> 
    by Elliotte Rusty Harold (O’Reilly, 1997).</font><br>
  </p>
</div>
<h2 align="left"> </h2>
<p> <a name="_Toc481064874"></a><a name="Heading523"></a> </p>
<h2 align="left"><font face="Verdana"> Java Database Connectivity (JDBC)</font></h2>
<p><font face="Georgia">Приблизительно было подсчитано, что половина всего программного 
  обеспечения использует клиент/серверные операции. Многообещающей возможностью 
  Java была способность строить платформонезависимые клиент/серверные прилажения 
  для работы с базами данных. Это стало возможным благодаря </font><font face="Georgia"> 
  <a name="Index2113"></a><a name="Index2114"></a><a name="Index2115"></a>Java 
  DataBase Connectivity (JDBC).</font> </p>
<p><font face="Georgia">Одна из основных проблемм при работе с базами данных - 
  это война особенностей между компаниями, разрабатывающими базы данных. Есть 
  “стандартный” язык базы данных, <a name="Index2116"></a><a name="Index2117"></a>Structured 
  Query Language (SQL-92), но вы обычно должны знать с базой данных какого производителя 
  вы работаете, несмотря на стандарт. JDBC предназначена для независимости от 
  платформы, так что вам нет необходимости заботится о том, какую базу данных 
  вы используете при программировании. Однако все еще возможно делать зависимые 
  от производителя вызовы из JDBC, так что вы не ограничены тем, что вы должны 
  делать.</font></p>
<p><font face="Georgia">В одном месте программистам может понадобиться использовать 
  SQL имена типов в SQL выражении </font><tt><font face="Courier New">TABLE CREATE</font></tt><font face="Georgia">, 
  когда они создают новую таблицу данных и определяют SQL тип для каждой колонки. 
  К сожалению существуют значительные различия между SQL типами, поддерживаемыми 
  различными продуктами баз данных. Различные базы данных, поддерживающие SQL 
  типы с одинаковой семантикой и структурой, могут иметь различные имена типов. 
  Большинство наиболее известных баз данных поддерживают типы данных SQL для больших 
  бинарных значений: в Oracle этот тип называется </font><tt><font face="Courier New">LONG 
  RAW</font></tt><font face="Georgia">, Sybase называет его </font><tt><font face="Courier New">IMAGE</font></tt><font face="Georgia">, 
  Informix называет его </font><tt><font face="Courier New">BYTE</font></tt><font face="Georgia">, 
  а DB2 называет го </font><tt><font face="Courier New">LONG VARCHAR FOR BIT DATA</font></tt><font face="Georgia">. 
  Поэтому, если переносимость между базами данных является вашей целью, вы должны 
  попробовать обойтись только основными идентификаторами SQL типов.</font></p>
<p><font face="Georgia">Переносимость - это такая возможность при написании книги, 
  при которой читатели могут проверить примеры в любом неизвестном хранилище данных. 
  Я попробовал написать такие примеры настолько переносимыми, насколько это возможно. 
  Также вы должны иметь в виду, что специфичный для базы данных код был изолирован, 
  чтобы можно было централизовать все изменения, которые вам необходимо будет 
  выполнить, чтобы примеры заработали в вашей среде.</font></p>
<p><font face="Georgia">JDBC, как и многие API в Java, предназначен для упрощения. 
  Вызовы методов, которые вы делаете, соответствует логическим операциям, которые 
  вы думаете выполнить для сбора данных из базы данных: подключиться к базе данных, 
  создать выражение и выполнить запрос, затем посмотреть результирующую выборку.</font></p>
<p><font face="Georgia">Для получения платформонезависимости, JDBC предоставляет 
  менеджер драйверов (<i>driver manager</i>) который динамически использует все 
  объекты драйверов, которые необходимы для опроса вашей базы данных. Так что 
  если у вас есть базы данных от трех производителей, к которым вы хотите подсоединиться, 
  вам нужно три различных объекта драйверов. Объекты драйверов регистрируют себя 
  с помощью менеджера драйверов вл время загрузки, а вы можете принудительно выполнить 
  загрузку, используя <b>Class.forName(&nbsp;)</b>.</font></p>
<p><font face="Georgia">Для открытия базы данных вы должны создать “<a name="Index2118"></a><a name="Index2119"></a>URL 
  базы данных”, котрый указывает:<a name="Index2120"></a></font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Что вы используете JDBC 
    с помощью “jdbc.”</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia"> “Подлежащий протокол”: 
    имя драйвера или имя механизма соединения с базой данных. Так как назначение 
    JDBC было вдохнавлено ODBC, первый доступный подлежащий протокол - это “jdbc-odbc 
    мост”, обозначаемый “odbc”.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Идентификатор базы данных. 
    Он варьируется в зависимости от используемого драйвера базы данных, но обычно 
    предоставляет логическое имя, которое отображается програмным обеспечением 
    администрирования базы данных на физический директорий, в котором расположены 
    таблицы базы данных. Для вас иденификатор базы данных имеет различные значения, 
    вы должны зарегистрировать имя, используя ваше програмное обеспечение администирования 
    базы данных. (Процесс регистрации различен для разных платформ.)</font> 
</li></ol>
<p><font face="Georgia">Вся эта информация комбинируется в одну строку: “URL 
  базы даных”. Например, для подключения черед подлежащий протокол ODBC 
  к базе данных с идентификатором “people”, URL базы данных может 
  быть:</font></p>
<blockquote> 
  <pre><font size="+1">String dbUrl = <font color="#004488">"jdbc:odbc:people"</font>;</font></pre>
</blockquote>
<p><font face="Georgia">Если вы подключаетесь по сети, URL базы данных будет содержать 
  информацию для подключения, идентифицирующую удаленную машину и может быть немного 
  пугающим. Вот пример работы с базой данных CloudScape, которую вызывает удаленных 
  клиент, использующий RMI:</font></p>
<blockquote> 
  <pre><font size="+1">jdbc:rmi:<font color="#009900">//192.168.170.27:1099/jdbc:cloudscape:db</font></font></pre>
</blockquote>
<p><font face="Georgia">Этот URL базы данных на самом деле содержит два jdbc вызова 
  в одном. Первая часть “</font><tt><font face="Courier New">jdbc:rmi://192.168.170.27:1099/</font></tt><font face="Georgia">” 
  использует RMI для создания соединения с удаленной машиной баз данных, следящей 
  за портом 1099 по IP адресу 192.168.170.27. Вторая часть URL, “</font><tt><font face="Courier New">jdbc:cloudscape:db</font></tt><font face="Georgia">” 
  передает более привычные установки, используя подлежащий протокол и имя базы 
  данных, но это произойдет только после того, как первая секция установит соединение 
  с удаленной машиной через RMI.</font></p>
<p><font face="Georgia">Когда вы готовы присоединиться к базе данных, вызовите 
  статический (<b>static</b>) метод <b>DriverManager.getConnection(&nbsp;)</b> 
  и передайте ему URL базы данных и пароль для входа в базу данных. Обратно вы 
  получите объект <b>Connection</b>, который затем вы можете использовать для 
  опроса и манипуляций с базой данных.</font></p>
<p><font face="Georgia">Следующий пример открывает контактную информацию базы 
  данных и ищет имя человека, переданное из командной строки. Он выбирает только 
  имена людей, имеющий электронные адреса, затем печатает те из них, имя которых 
  совпадает с заданным:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:jdbc:Lookup.java</font>
<font color="#009900" size="+1">// Поиск электронных адресов в</font>
<font color="#009900" size="+1">// локальной базе данных с помощью JDBC.</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> java.sql.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> Lookup {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) 
  <font color="#0000ff">throws</font> SQLException, ClassNotFoundException {
    String dbUrl = <font color="#004488">"jdbc:odbc:people"</font>;
    String user = <font color="#004488">""</font>;
    String password = <font color="#004488">""</font>;
    <font color="#009900">// Загружаем драйвер (регистрируем себя)</font>
    Class.forName(
      <font color="#004488">"sun.jdbc.odbc.JdbcOdbcDriver"</font>);
    Connection c = DriverManager.getConnection(
      dbUrl, user, password);
    Statement s = c.createStatement();
    <font color="#009900">// SQL код:</font>
    ResultSet r = 
      s.executeQuery(
        <font color="#004488">"SELECT FIRST, LAST, EMAIL "</font> +
        <font color="#004488">"FROM people.csv people "</font> +
        <font color="#004488">"WHERE "</font> +
        <font color="#004488">"(LAST='"</font> + args[0] + <font color="#004488">"') "</font> +
        <font color="#004488">" AND (EMAIL Is Not Null) "</font> +
        <font color="#004488">"ORDER BY FIRST"</font>);
    <font color="#0000ff">while</font>(r.next()) {
      <font color="#009900">// Регистр не имеет значения:</font>
      System.out.println(
        r.getString(<font color="#004488">"Last"</font>) + <font color="#004488">", "</font> 
        + r.getString(<font color="#004488">"fIRST"</font>)
        + <font color="#004488">": "</font> + r.getString(<font color="#004488">"EMAIL"</font>) );
    }
    s.close(); <font color="#009900">// Закрываем ResultSet</font>
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Вы можете увидеть создание URL базы данных, как это описано 
  выше. В этом примере нет защитного пароля для базы данных, поэтому имя пользователя 
  и пароль представлены пустыми строками.</font></p>
<p><font face="Georgia">Как только соединение установлено с помощью <b>DriverManager.getConnection(&nbsp;)</b>, 
  вы можете использовать полученный объект <b>Connection</b> для создания объекта 
  <b>Statement</b>, используя метод <a name="Index2121"></a><a name="Index2122"></a><b>createStatement(&nbsp;)</b>. 
  С помощью <a name="Index2123"></a><a name="Index2124"></a><b>Statement</b> вы 
  можете вызвать <a name="Index2125"></a><a name="Index2126"></a><b>executeQuery(&nbsp;)</b>, 
  передав в него строку, содержащую SQL выражение стандарта SQL-92. (Скоро вы 
  увидите как вы можете генерировать это выражение автоматически, так что вам 
  не нужно много знать об SQL.)</font></p>
<p><font face="Georgia">Метод <b>executeQuery(&nbsp;) </b> возвращает объект <a name="Index2127"></a><a name="Index2128"></a><b>ResultSet</b>, 
  который является итератором: метод <b>next(&nbsp;)</b> перемещает итератор на 
  следующую запись в выражении или возвращает <b>false</b>, если достигнут конец 
  результирующего множества. Вы всегда получите назад объект <b>ResultSet</b> 
  от <b>executeQuery(&nbsp;)</b>, даже если результатом запроса является пустое 
  множество (если так, исключение не возникает). Обратите внимание, чтовы должны 
  вызвать <b>next(&nbsp;)</b> прежде, чем попробовать прочесть любую запись. Если 
  результирующее множество - пустое, этот первый вызов <b>next(&nbsp;)</b> вернет 
  <b>false</b>. Для каждой записи результирующего множества вы можете выбрать 
  поля, используя (наряду с другими подходами) имя поля, как строку. Также обратите 
  внимание, что регистр в имени поля игнорируется — это не так с базой SQL 
  данных. Вы определяете тип, который получите, вызвав <a name="Index2129"></a><a name="Index2130"></a><b>getInt(&nbsp;)</b>, 
  <a name="Index2131"></a><a name="Index2132"></a><b>getString(&nbsp;)</b>, <a name="Index2133"></a><a name="Index2134"></a><b>getFloat(&nbsp;)</b> 
  и т.д. В этом месте вы получаете данные из вашей базы данных в родном формате 
  Java и можете делать с ними все, что хотите, используя обычный Java код.</font></p>
<a name="_Toc481064875"></a><a name="Heading524"></a> 
<h3 align="left"><font face="Verdana"> Получение примера для работы</font></h3>
<p><font face="Georgia">При использовании JDBC понимание кода относительно проще. 
  Самое сложное - это заставить его работать на вашей конкретной системе. Причина 
  сложности в том, что при этом от вас требуется, чтобы вы понимали как правильно 
  загрузить ваш JDBC и как установить базу данных, используя ваше программное 
  обеспечение администрирования базы данных.</font></p>
<div align="left"> 
  <p><font face="Georgia">Конечно этот процесс может радикально отличаться на 
    разных машинах, но тот алгоритм, который я применил для 32-bit Windows, может 
    дать вам ключ к решению и поможет разобраться в вашей собственной ситуации.</font></p>
</div>
<a name="Heading525"></a> 
<h4 align="left"><font face="Verdana"> Шаг 1: Поиск JDBC Драйвера</font></h4>
<p><font face="Georgia">Программа, приведенная выше, содержит инструкцию:</font></p>
<blockquote> 
  <pre><font size="+1">Class.forName(<font color="#004488">"sun.jdbc.odbc.JdbcOdbcDriver"</font>);</font></pre>
</blockquote>
<p><font face="Georgia">Это означает структуру директориев, которая вводит в заблуждение. 
  С данной конкретной установкой JDK 1.1 небыло файла, называемого <b>JdbcOdbcDriver.class</b>, 
  так что если вы, взглянув на этот пример, пошли бы искать его, вы были бы расстроены. 
  Другой опудликованный пример использует псевдо имя, такое как “myDriver.ClassName”, 
  которое помгает еще меньше. Фактически, приведенное выше выражение загрузки 
  jdbc-odbc драйвера (только того, который реально поставляется с JDK) возникает 
  только в некоторых местах онлайн документации (обычно на страницах, помеченных 
  “JDBC-ODBC Bridge Driver”). если преведенная выше инструкция не 
  работает, это значит что имя могло измениться вместе со сменой версии Java, 
  так что вы должны снова углубиться в документацию.</font></p>
<p><font face="Georgia">Если инструкция загрузки неверна, вы получите исключение 
  в этом месте. Чтобы проверить, что ваша инструкция загрузки работает правильно, 
  закоментируйте код после инструкции вплоть до выражения <b>catch. </b> Если 
  программа не выбрасывает исключений, это означает, что драйвер загружен правильно.</font></p>
<a name="Heading526"></a> 
<h4 align="left"><font face="Verdana"> Шаг 2: Конфигурирование базы данных</font></h4>
<p><font face="Georgia">Опять таки, это специфично для 32-bit Windows. Вам может 
  понадобиться выполнить определенное исследование, чтобы определить что нужно 
  для вашей конкретной платформы.</font></p>
<p><font face="Georgia">Во-первых, откройте контрольную панель. вы можете найти 
  две иконки с надписью “ODBC”. Вы должны использовать ту, на под 
  которой написано “32bit ODBC”, так как другая иконка предназначена 
  для обратной совместимости с программным обеспечением 16-bit ODBC и не дас результатов 
  для JDBC. Когда вы откроете иконку “32bit ODBC”, вы увидите диаог 
  с несколькими закладками, включая “User DSN”, “System DSN”, 
  “File DSN” и т. д. в которых “DSN” означает “Data 
  Source Name”. Это не имеет значения для JDBC-ODBC моста, важна только 
  установка вашей базы данных в “System DSN”, но вы также можете протестировать 
  вашу конфигурацию и сделать опрос, найдя то, что вам необходимо для установки 
  вашей базы данных в “File DSN”. Это можно делать с помощью инструмента 
  Microsoft Query (который поставляется вместе с Microsoft Office), чтобы найти 
  базу данных. Имейте в виду, что инструмент опроса есть и у других произвдителей.</font></p>
<p><font face="Georgia">Наиболее интересной базой данных является та, которую 
  вы уже использовали. Стандарт ODBC поддерживает нескоько различных форматов 
  файлов, включая такую почтенную рабочую лошадку, как DBase. Однако, он также 
  включает простой формат “разделения запятой ASCII”, который может 
  записывать фактически каждый инструмент рабты с данными. В моем случае я просто 
  взял базу данных “people”, которую поддерживал до этого долгие годы, 
  используя различные инсрументы управления и экспортировал ее в ASCII файл с 
  разделением запятыми (обычно такие файлы имеют расширение <b>.csv</b>). В разделе 
  “System DSN” я выбрал “Add”, выбрал текстовый дравер 
  для обработки моего ASCII файла, а затем снял пометку с “использовать 
  текущий каталог” (“use current directory”), что позволило 
  мне указать директорий, в который я экспортировал файл данных.</font></p>
<p><font face="Georgia">Вы заметите, когда сделаете это, что на самом деле вы 
  не указываете файл, а только директорий. Это происходит потому, что обычно база 
  данных представляет набор файлов в одном директории (хотя она точно так же может 
  быть представлениа и в другой форме). Каждый файл обычно содержит единственную 
  таблицу базы данных, а SQL инструкции могут производить результат, который собирается 
  из различных таблиц базы данных (это называется <a name="Index2135"></a><a name="Index2136"></a><i>объединением</i> 
  (<i>join</i>)). База данных, содержащая только одну таблицу (как моя база даных 
  “people”), обычно называется <a name="Index2137"></a><a name="Index2138"></a><a name="Index2139"></a><i>flat-file 
  database</i>. Большинство проблем, связанных с простым хранением и получением 
  данных, обычно требуют нескольких таблиц, которые для получения желаемого результата 
  должны быть связаны путем объединения, и это называется <a name="Index2140"></a><a name="Index2141"></a><a name="Index2142"></a>реляционной 
  (<i>relational</i>) базой данных.</font></p>
<a name="Heading527"></a> 
<h4 align="left"><font face="Verdana"> Шаг 3: Проверка конфигурации</font></h4>
<p><font face="Georgia">Для проверки конфигурации вам необходим способ, с помощью 
  которого вы можете определить видна ли база данных для программы, которая ее 
  опрашивает. Конечно вы можете просто запустить пример JDBC программы, приведенный 
  выше, и включить инструкцию:</font></p>
<blockquote> 
  <pre><font size="+1">Connection c = DriverManager.getConnection(
  dbUrl, user, password);</font></pre>
</blockquote>
<p><font face="Georgia">Если выброшено исключение, ваша конфигурация некорректна.</font></p>
<p><font face="Georgia">Однако в этом месте полезно причлечь инструмент генерации 
  запросов. Я использовал Microsoft Query, который поставляется с Microsoft Office, 
  но вы можете предпочесть что-то другое. Инструмент опроса должен знать где находится 
  база данных, и Microsoft Query требовал, чтобы я запустил ODBC Администратор 
  и в закладке “File DSN” добавил новый элемент, опять указав текстовый 
  драйвер и дерикторий, в котором хранится моя база данных. Вы можете задать какое 
  хотите имя элемента, но полезно использовать то же самое имя, которое задействовано 
  в “System DSN”.</font></p>
<p><font face="Georgia">Как только вы сделаете это, вы увидите, что ваша база 
  данных доступна при создании нового запроса с вашим инструментом запросов.</font></p>
<a name="Heading528"></a> 
<h4 align="left"><font face="Verdana"> Шаг 4: Генерация вашего SQL запроса</font></h4>
<p><font face="Georgia">Запрос, который я создал с помошью Microsoft Query, не 
  только показал мне, что моя база даных на месте и впорядке, но также автоматически 
  создал SQL код, который необходим мне для вставки в мою Java программу. Мне 
  нужен был запрос, который искал бы записи, имеющие в поле имени значение, совпадающее 
  с напечатанным в командной строке при запуске Java программы. Для начала я искал 
  определенное имя: “Eckel”. Я также хотел отображать только те имена, 
  которые ассоциированы с электронным адресом. Я сделал для генерации запроса 
  следующее:</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Запустите новый запрос 
    и используйте Query Wizard. Выберите базу данных “people”. (Это 
    эквивалентно открытию соединения с базой данных при использовании соответствующего 
    URL базы данных.)</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Выберите таблицу “people” 
    из базы данных. Из таблицы выберите колонки FIRST, LAST и EMAIL.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Под “Filter Data” 
    выберите LAST и выберите “equals” с аргуменом “Eckel”. 
    Нажмите радио кнопку “And”.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Выберите EMAIL и выберите 
    “Is not Null”.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Под “Sort By” 
    выберите FIRST.</font> 
</li></ol>
<p><font face="Georgia">Результат запроса покажет вам выбрали ли вы то, что хотели.</font></p>
<p><font face="Georgia">Теперь вы можете нажать кнопку SQL и, не проводя никаких 
  исследований со своей стороны, получить корректный SQL код, готовый для употребления. 
  Для этого запроса он выглядит так:</font></p>
<blockquote> 
  <pre><font size="+1">SELECT people.FIRST, people.LAST, people.EMAIL
FROM people.csv people
WHERE (people.LAST='Eckel') AND 
(people.EMAIL Is Not Null)
ORDER BY people.FIRST</font></pre>
</blockquote>
<p><font face="Georgia">При более сложных запросах легко ошибиться, но при использовании 
  инструмента построения запроса вы можете интерактивно протестировать ваш запрос 
  и автоматически сгенерировать корректный код. Трудно найти аргументы в пользу 
  построения запросов в ручную.</font></p>
<a name="Heading529"></a> 
<h4 align="left"><font face="Verdana"> Шаг 5: Изменеие и вставка в ваш запрос</font></h4>
<div align="left"> 
  <p><font face="Georgia">Вы могли заметить, что приведенный выше код отличается 
    от кода, использованного в программе. Это происходит потому, инструмент запросов 
    использует полные квалификаторы для всех имен, даже если вовлечена только 
    одна таблица. (Когда задействовано больше таблиц, квалификаторы предотвращают 
    коллизии между колонками из разных таблиц, имеющих одинаковые имена.) Так 
    как этот запрос использует только одну таблицу, вы можете по желанию удалить 
    квалификатор “people” из большинства имен, как приведено ниже:</font></p>
</div>
<blockquote> 
  <pre><font size="+1">SELECT FIRST, LAST, EMAIL
FROM people.csv people
WHERE (LAST='Eckel') AND 
(EMAIL Is Not Null)
ORDER BY FIRST</font></pre>
</blockquote>
<p><font face="Georgia">Кроме того, вам не нужна программа, ищущая только одно 
  имя. Вместо этого должны выбираться имена, заданные в командной стоке. Сделаем 
  эти изменения и включим SQL выражение в динамическую генерацию <b>String</b>:</font></p>
<blockquote> 
  <pre><font color="#004488" size="+1">"SELECT FIRST, LAST, EMAIL "</font><font size="+1"> +
<font color="#004488">"FROM people.csv people "</font> +
<font color="#004488">"WHERE "</font> +
<font color="#004488">"(LAST='"</font> + args[0] + <font color="#004488">"') "</font> +
<font color="#004488">" AND (EMAIL Is Not Null) "</font> +
<font color="#004488">"ORDER BY FIRST"</font>);</font></pre>
</blockquote>
<p><font face="Georgia">SQL имеет другой способ вставки имен в запрос, называемый 
  <a name="Index2143"></a><a name="Index2144"></a><a name="Index2145"></a><i>хранимая 
  процедура (stored procedures)</i>, которая используется для ускорения. Но для 
  боьшинства ваших экспериментов с базой данных и для вашего первого опыта, построение 
  ваших собственных запросов в Java удобно.</font></p>
<p><font face="Georgia">Из этого примера вы видите, что при использовании доступных 
  в настоящее время — обычно это инструменты построения запросов — 
  программирование с SQL и JDBC может быть достаточно простым.</font></p>
<a name="_Toc481064876"></a><a name="Heading530"></a> 
<h3 align="left"><font face="Verdana"> GUI версия программы поиска</font></h3>
<p><font face="Georgia">Более полезно оставлять программу поиска постоянно работающей 
  все время и просто переключаться на нее и впечатывать то имя, которое вы хотите 
  найти. Далее приведена программа поиска, выполненная как приложение/аппдет, 
  также в нее добавлено свойство автоматического завершения ввода имени так, что 
  вам нет необходимости набирать имя до конца:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:jdbc:VLookup.java</font>
<font color="#009900" size="+1">// GUI версия Lookup.java.</font>
<font color="#009900" size="+1">// &lt;applet code=VLookup</font>
<font color="#009900" size="+1">// width=500 height=200&gt;&lt;/applet&gt;</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.swing.*; 
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> javax.swing.event.*;
<font color="#0000ff">import</font> java.sql.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> VLookup <font color="#0000ff">extends</font> JApplet {
  String dbUrl = <font color="#004488">"jdbc:odbc:people"</font>;
  String user = <font color="#004488">""</font>;
  String password = <font color="#004488">""</font>;
  Statement s;
  JTextField searchFor = <font color="#0000ff">new</font> JTextField(20);
  JLabel completion = 
    <font color="#0000ff">new</font> JLabel(<font color="#004488">"                        "</font>);
  JTextArea results = <font color="#0000ff">new</font> JTextArea(40, 20);
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> init() {
    searchFor.getDocument().addDocumentListener(
      <font color="#0000ff">new</font> SearchL());
    JPanel p = <font color="#0000ff">new</font> JPanel();
    p.add(<font color="#0000ff">new</font> Label(<font color="#004488">"Last name to search for:"</font>));
    p.add(searchFor);
    p.add(completion);
    Container cp = getContentPane();
    cp.add(p, BorderLayout.NORTH);
    cp.add(results, BorderLayout.CENTER);
    <font color="#0000ff">try</font> {
      <font color="#009900">// Загружаем драйвер (регистрируем себя)</font>
      Class.forName(
        <font color="#004488">"sun.jdbc.odbc.JdbcOdbcDriver"</font>);
      Connection c = DriverManager.getConnection(
        dbUrl, user, password);
      s = c.createStatement();
    } <font color="#0000ff">catch</font>(Exception e) {
      results.setText(e.toString());
    }
  }
  <font color="#0000ff">class</font> SearchL <font color="#0000ff">implements</font> DocumentListener {
    <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> changedUpdate(DocumentEvent e){}
    <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> insertUpdate(DocumentEvent e){
      textValueChanged();
    }
    <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> removeUpdate(DocumentEvent e){
      textValueChanged();
    }
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> textValueChanged() {
    ResultSet r;
    <font color="#0000ff">if</font>(searchFor.getText().length() == 0) {
      completion.setText(<font color="#004488">""</font>);
      results.setText(<font color="#004488">""</font>);
      <font color="#0000ff">return</font>;
    }
    <font color="#0000ff">try</font> {
      <font color="#009900">// Завершение ввода имени:</font>
      r = s.executeQuery(
        <font color="#004488">"SELECT LAST FROM people.csv people "</font> +
        <font color="#004488">"WHERE (LAST Like '"</font> +
        searchFor.getText()  + 
        <font color="#004488">"%') ORDER BY LAST"</font>);
      <font color="#0000ff">if</font>(r.next()) 
        completion.setText(
          r.getString(<font color="#004488">"last"</font>));
      r = s.executeQuery(
        <font color="#004488">"SELECT FIRST, LAST, EMAIL "</font> +
        <font color="#004488">"FROM people.csv people "</font> +
        <font color="#004488">"WHERE (LAST='"</font> + 
        completion.getText() +
        <font color="#004488">"') AND (EMAIL Is Not Null) "</font> +
        <font color="#004488">"ORDER BY FIRST"</font>);
    } <font color="#0000ff">catch</font>(Exception e) {
      results.setText(
        searchFor.getText() + <font color="#004488">"\n"</font>);
      results.append(e.toString());
      <font color="#0000ff">return</font>; 
    }
    results.setText(<font color="#004488">""</font>);
    <font color="#0000ff">try</font> {
      <font color="#0000ff">while</font>(r.next()) {
        results.append(
          r.getString(<font color="#004488">"Last"</font>) + <font color="#004488">", "</font> 
          + r.getString(<font color="#004488">"fIRST"</font>) + 
          <font color="#004488">": "</font> + r.getString(<font color="#004488">"EMAIL"</font>) + <font color="#004488">"\n"</font>);
      }
    } <font color="#0000ff">catch</font>(Exception e) {
      results.setText(e.toString());
    }
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> VLookup(), 500, 200);
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Большая часть логики работы с базой данных осталась прежней, 
  но вы можете видеть, что добавлен <b>DocumentListener</b>, чтобы следить за 
  <b> JTextField</b> (более детально смотрите <b>javax.swing.JTextField</b> в 
  HTML документации по Java на <i>java.sun.com</i>), так что когда бы вы не напечатали 
  новый сивол, сначала выполнятся попытка завершения имени путем поиска имени 
  в базе данных по введенным первым символам. (Имя завершения помещается в <b>completion</b> 
  <b>JLabel</b> и используется как текст поиска.) Таким образом, как только вы 
  напечатаете достаточно символов, чтобы программа уникально нашала имя, которое 
  вы хотите искать, вы можете остановиться.</font><a name="_Toc481064877"></a></p>
<a name="Heading531"></a> 
<h3 align="left"><font face="Verdana"> Почему JDBC API выглядит так сложно</font></h3>
<p><font face="Georgia">Когда вы просмотрите онлайн документацию по JDBC, она 
  может испугать. В частности, интерфейс <a name="Index2146"></a><a name="Index2147"></a><b>DatabaseMetaData</b>, 
  который просто огромен, в противоположность большинству интерфейсов, вивденных 
  вами в Java. У него есть такие методы, как <b>dataDefinitionCausesTransactionCommit(&nbsp;)</b>, 
  <b>getMaxColumnNameLength(&nbsp;)</b>, <b>getMaxStatementLength(&nbsp;)</b>, 
  <b>storesMixedCaseQuotedIdentifiers(&nbsp;)</b>, <b>supportsANSI92IntermediateSQL(&nbsp;)</b>, 
  <b>supportsLimitedOuterJoins(&nbsp;)</b> и так далее. Что вы думаете об этом?</font></p>
<p><font face="Georgia">Как упоминалось ранее, базы данных от начала до конца 
  выглядят беспорядочно, в основном поэтому требуются прилажения и инструменты 
  по работе с базами данных. Только недавно появились общие соглашения по языку 
  SQL (и в общем употреблении существует множество других языков работы с базами 
  данных). Но даже при существовании “стандартного” SQL есть так много 
  вариаций этой темы, из-за чего JDBC должен предоставлять такой огромный интерфейс 
  <b>DatabaseMetaData</b>, чтобы ваш код мог обнаруживать совместимость подключенной 
  в настоящее время базы данных с определенным “стандартом” SQL. Короче 
  говоря, вы можете писать на простом, переносимом SQL, но если вы хотите оптимизировать 
  скорость, ваш код черезвычайно расширится, если вы будете исследовать совместимость 
  базы данных со свойствами определенного производителя.</font></p>
<p><font face="Georgia">Конечно, Java в этом не виноват. JDBC просто пытается 
  компенсировать расхождения между базами данных разных производителей. Но держите 
  в уме, что ваша жизнь будет проще, если вы сможете писать общие запросы и не 
  будете беспокоиться так много о производительности, или, если вы должны настраивать 
  производительность, знать платформу, для которой вы пишите, чтобы вам не нужно 
  было писать весь исследующий код.</font><a name="_Toc463665181"></a><a name="_Toc481064878"></a></p>
<a name="Heading532"></a> 
<h3 align="left"><font face="Verdana"> Более изощренный пример</font></h3>
<p><font face="Georgia">Более интересный пример </font><a name="fnB73" href="#fn73">[73]</a><font face="Georgia"> 
  задействует множественную базу данных, расположенную на сервере. Здесь в качестве 
  базы данных используется хранилище для ведения журнала обращений, чтобы позволить 
  людям регестрировать события, поэтому она называется <i>Community Interests 
  Database </i>(CID). Этот пример будет обеспечивать только просмотр базы данных 
  и ее реализации, и не предназначен быть полным руководством по разработке баз 
  данных. Есть множество книг, семинаров и пакетов программ, которые помогут вам 
  при проектировании и разработке базы данных.</font></p>
<p><font face="Georgia">Кроме того, этот пример предполагает, что проведена предварительная 
  установка SQL базы данных на сервере (хотя это может быть запущено и на локальной 
  машине), а так же опрос и обнаружение подходящего JDBC драйвера для базы данных. 
  Существуют несколько бесплатных SQL баз данных, и некоторые из них автоматически 
  устанавливаются с различными версиями Linux. Вы сами отвечаете за выбор базы 
  данных и поиск JDBC драйвера. Приведенный здесь пример основывается на SQL базе 
  данных системы, называемой “Cloudscape”.</font></p>
<p><font face="Georgia">Чтобы упростить изменения в информации о соединении, драйвер 
  базы данных, URL базы данных, имя пользователя и пароль помещены в отдельный 
  класс:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:jdbc:CIDConnect.java</font>
<font color="#009900" size="+1">// Информация для подключения к базе данных</font>
<font color="#009900" size="+1">// community interests database (CID).</font>

<font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">class</font><font size="+1"> CIDConnect {
  <font color="#009900">// Вся информация спецефична для CloudScape:</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">static</font><font size="+1"> String dbDriver = 
    <font color="#004488">"COM.cloudscape.core.JDBCDriver"</font>;
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font><font size="+1"> String dbURL =
    <font color="#004488">"jdbc:cloudscape:d:</font></font><font color="#004488" size="+1">/docs/_work/JSapienDB"</font><font size="+1">;
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font><font size="+1"> String user = <font color="#004488">""</font>;
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font><font size="+1"> String password = <font color="#004488">""</font>;
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">В этом примере нет пароля защиты базы данных, поэтому 
  имя пользователя и пароль представлены пустыми строками.</font></p>
<p><font face="Georgia">База данных состоит из множества таблиц, структура которых 
  показана ниже:</font></p>
<div align="center"><font face="Georgia"><img src="Chapter15_files/TIJ228.gif"></font><br>
  <p></p>
</div>
<p><font face="Georgia">“Members” содержит информацию о пользователе, 
  “Events” и “Locations” содержат информацию о подключении 
  и откуда оно было сделано, а “Evtmems” объединяет события и пользователей, 
  которые хотят знать о событиях. Можно видеть, что данные в одной таблице являются 
  ключами в другой таблице.</font></p>
<p><font face="Georgia">Следующий класс содержит SQL строки, которые создают эти 
  таблицы базы данных (обратитесь к руководству по SQL, чтобы узнать объяснения 
  этого кода):</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:jdbc:CIDSQL.java</font>
<font color="#009900" size="+1">// SQL строки для создания таблиц CID.</font>

<font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">class</font><font size="+1"> CIDSQL {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font><font size="+1"> String[] sql = {
    <font color="#009900">// Создание таблицы MEMBERS:</font></font>
    <font color="#004488" size="+1">"drop table MEMBERS"</font><font size="+1">,
    <font color="#004488">"create table MEMBERS "</font> +
    <font color="#004488">"(MEM_ID INTEGER primary key, "</font> +
    <font color="#004488">"MEM_UNAME VARCHAR(12) not null unique, "</font>+
    <font color="#004488">"MEM_LNAME VARCHAR(40), "</font> +
    <font color="#004488">"MEM_FNAME VARCHAR(20), "</font> +
    <font color="#004488">"ADDRESS VARCHAR(40), "</font> +
    <font color="#004488">"CITY VARCHAR(20), "</font> +
    <font color="#004488">"STATE CHAR(4), "</font> +
    <font color="#004488">"ZIP CHAR(5), "</font> +
    <font color="#004488">"PHONE CHAR(12), "</font> +
    <font color="#004488">"EMAIL VARCHAR(30))"</font>,
    <font color="#004488">"create unique index "</font> +
    <font color="#004488">"LNAME_IDX on MEMBERS(MEM_LNAME)"</font>,
    <font color="#009900">// Создание таблицы EVENTS</font></font>
    <font color="#004488" size="+1">"drop table EVENTS"</font><font size="+1">,
    <font color="#004488">"create table EVENTS "</font> +
    <font color="#004488">"(EVT_ID INTEGER primary key, "</font> +
    <font color="#004488">"EVT_TITLE VARCHAR(30) not null, "</font> +
    <font color="#004488">"EVT_TYPE VARCHAR(20), "</font> +
    <font color="#004488">"LOC_ID INTEGER, "</font> +
    <font color="#004488">"PRICE DECIMAL, "</font> +
    <font color="#004488">"DATETIME TIMESTAMP)"</font>,
    <font color="#004488">"create unique index "</font> +
    <font color="#004488">"TITLE_IDX on EVENTS(EVT_TITLE)"</font>,
    <font color="#009900">// Создание таблицы EVTMEMS</font></font>
    <font color="#004488" size="+1">"drop table EVTMEMS"</font><font size="+1">,
    <font color="#004488">"create table EVTMEMS "</font> +
    <font color="#004488">"(MEM_ID INTEGER not null, "</font> +
    <font color="#004488">"EVT_ID INTEGER not null, "</font> +
    <font color="#004488">"MEM_ORD INTEGER)"</font>,
    <font color="#004488">"create unique index "</font> +
    <font color="#004488">"EVTMEM_IDX on EVTMEMS(MEM_ID, EVT_ID)"</font>,
    <font color="#009900">// Создание таблицы LOCATIONS</font></font>
    <font color="#004488" size="+1">"drop table LOCATIONS"</font><font size="+1">,
    <font color="#004488">"create table LOCATIONS "</font> +
    <font color="#004488">"(LOC_ID INTEGER primary key, "</font> +
    <font color="#004488">"LOC_NAME VARCHAR(30) not null, "</font> +
    <font color="#004488">"CONTACT VARCHAR(50), "</font> +
    <font color="#004488">"ADDRESS VARCHAR(40), "</font> +
    <font color="#004488">"CITY VARCHAR(20), "</font> +
    <font color="#004488">"STATE VARCHAR(4), "</font> +
    <font color="#004488">"ZIP VARCHAR(5), "</font> +
    <font color="#004488">"PHONE CHAR(12), "</font> +
    <font color="#004488">"DIRECTIONS VARCHAR(4096))"</font>,
    <font color="#004488">"create unique index "</font> +
    <font color="#004488">"NAME_IDX on LOCATIONS(LOC_NAME)"</font>,
  };
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Следующая программа использует информацию <b>CIDConnect 
  </b>и <b>CIDSQL</b> для загрузки JDBC драйвера, создания соединения с базой 
  данных и создания таблиц, структура которых показана на диаграмме. Для соединения 
  с базой данных вы вызываете статический (<b>static</b>) метод <b>DriverManager.getConnection(&nbsp;)</b>, 
  передавая в него URL базы данных, имя пользователя и пароль для доступа к базе 
  данных. Назад вы получаете объект <b>Connection</b>, который вы можете использовать 
  для опроса и манипуляций с базой данных. Как только соединение создано, вы можете 
  просто поместить SQL в базу данных, в этом случае проходя по массиву <b>CIDSQL</b>. 
  Однако при первом запуске этой программы команда “drop table” завершиться 
  неудачей, что станет причиной исключения, которое будет поймано, объявлено и 
  проигнорировано. Необходимость команды “drop table” легко понять 
  из экспериментов: вы можете измнить SQL, который определяет таблицы, а затем 
  вернуться в программу. При этом возникнет необходимость заменить старые таблицы 
  новыми.</font></p>
<p><font face="Georgia">В этом примере есть смысл позволить исключениям отображаться 
  на консоли:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:jdbc:CIDCreateTables.java</font>
<font color="#009900" size="+1">// Создание таблиц базы данных для</font>
<font color="#009900" size="+1">// community interests database.</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> java.sql.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> CIDCreateTables {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) 
  <font color="#0000ff">throws</font> SQLException, ClassNotFoundException,
  IllegalAccessException {
    <font color="#009900">// Загрузка драйвера (саморегистрация)</font>
    Class.forName(CIDConnect.dbDriver);
    Connection c = DriverManager.getConnection(
      CIDConnect.dbURL, CIDConnect.user, 
      CIDConnect.password);
    Statement s = c.createStatement();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; CIDSQL.sql.length; i++) {
      System.out.println(CIDSQL.sql[i]);
      <font color="#0000ff">try</font> {
        s.executeUpdate(CIDSQL.sql[i]);
      } <font color="#0000ff">catch</font>(SQLException sqlEx) {
        System.err.println(
          <font color="#004488">"Probably a 'drop table' failed"</font>);
      }
    }
    s.close();
    c.close();
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Обратите внимание, что все изменения в базе данных могут 
  управляться путем изменения строк (<b>String</b>) в таблице <b>CIDSQL</b>, при 
  этом <b>CIDCreateTables</b> не меняется.</font></p>
<p><font face="Georgia"><b>executeUpdate(&nbsp;)</b> обычно возвращает число строк, 
  которые были получены при воздействии SQL инструкции. <b>executeUpdate(&nbsp;)</b> 
  чаще всего используется для выполнения таких инструкций, как </font><tt><font face="Courier New">INSERT</font></tt><font face="Georgia">, 
  </font><tt><font face="Courier New">UPDATE</font></tt><font face="Georgia"> 
  или </font><tt><font face="Courier New">DELETE</font></tt><font face="Georgia">, 
  чтобы изменить одну или более строк. Для таких инструкций, как </font><tt><font face="Courier New">CREATE 
  TABLE</font></tt><font face="Georgia">, </font><tt><font face="Courier New">DROP 
  TABLE</font></tt><font face="Georgia"> и </font><tt><font face="Courier New">CREATE 
  INDEX</font></tt><font face="Georgia">, <b>executeUpdate(&nbsp;)</b> всегда 
  возвращает ноль.</font></p>
<p><font face="Georgia">Для проверки базы данных она загружается некоторыми простыми 
  данными. Это требует нескольких </font><tt><font face="Courier New">INSERT</font></tt><font face="Georgia">'ов, 
  за которыми следует </font><tt><font face="Courier New">SELECT</font></tt><font face="Georgia"> 
  для получения результирующего множества. Чтобы облегчить проверку добавления 
  и изменения данных, тестовые данные представлены в виде двумерного массива типа 
  <b>Object</b>, а метод <b>executeInsert(&nbsp;)</b> затем может использовать 
  информацию из одной строки для создания соответствующей SQL команды.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:jdbc:LoadDB.java</font>
<font color="#009900" size="+1">// Loads and tests the database.</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> java.sql.*;

<font color="#0000ff">class</font> TestSet {
  Object[][] data = {
    { <font color="#004488">"MEMBERS"</font>, <font color="#0000ff">new</font> Integer(1),
      <font color="#004488">"dbartlett"</font>, <font color="#004488">"Bartlett"</font>, <font color="#004488">"David"</font>,
      <font color="#004488">"123 Mockingbird Lane"</font>,
      <font color="#004488">"Gettysburg"</font>, <font color="#004488">"PA"</font>, <font color="#004488">"19312"</font>,
      <font color="#004488">"123.456.7890"</font>,  <font color="#004488">"bart@you.net"</font> },
    { <font color="#004488">"MEMBERS"</font>, <font color="#0000ff">new</font> Integer(2),
      <font color="#004488">"beckel"</font>, <font color="#004488">"Eckel"</font>, <font color="#004488">"Bruce"</font>,
      <font color="#004488">"123 Over Rainbow Lane"</font>,
      <font color="#004488">"Crested Butte"</font>, <font color="#004488">"CO"</font>, <font color="#004488">"81224"</font>,
      <font color="#004488">"123.456.7890"</font>, <font color="#004488">"beckel@you.net"</font> },
    { <font color="#004488">"MEMBERS"</font>, <font color="#0000ff">new</font> Integer(3),
      <font color="#004488">"rcastaneda"</font>, <font color="#004488">"Castaneda"</font>, <font color="#004488">"Robert"</font>,
      <font color="#004488">"123 Downunder Lane"</font>,
      <font color="#004488">"Sydney"</font>, <font color="#004488">"NSW"</font>, <font color="#004488">"12345"</font>,
      <font color="#004488">"123.456.7890"</font>, <font color="#004488">"rcastaneda@you.net"</font> },
    { <font color="#004488">"LOCATIONS"</font>, <font color="#0000ff">new</font> Integer(1),
      <font color="#004488">"Center for Arts"</font>,
      <font color="#004488">"Betty Wright"</font>, <font color="#004488">"123 Elk Ave."</font>,
      <font color="#004488">"Crested Butte"</font>, <font color="#004488">"CO"</font>, <font color="#004488">"81224"</font>,
      <font color="#004488">"123.456.7890"</font>,
      <font color="#004488">"Go this way then that."</font> },
    { <font color="#004488">"LOCATIONS"</font>, <font color="#0000ff">new</font> Integer(2),
      <font color="#004488">"Witts End Conference Center"</font>,
      <font color="#004488">"John Wittig"</font>, <font color="#004488">"123 Music Drive"</font>,
      <font color="#004488">"Zoneville"</font>, <font color="#004488">"PA"</font>, <font color="#004488">"19123"</font>,
      <font color="#004488">"123.456.7890"</font>,
      <font color="#004488">"Go that way then this."</font> },
    { <font color="#004488">"EVENTS"</font>, <font color="#0000ff">new</font> Integer(1),
      <font color="#004488">"Project Management Myths"</font>,
      <font color="#004488">"Software Development"</font>,
      <font color="#0000ff">new</font> Integer(1), <font color="#0000ff">new</font> Float(2.50),
      <font color="#004488">"2000-07-17 19:30:00"</font> },
    { <font color="#004488">"EVENTS"</font>, <font color="#0000ff">new</font> Integer(2),
      <font color="#004488">"Life of the Crested Dog"</font>,
      <font color="#004488">"Archeology"</font>,
      <font color="#0000ff">new</font> Integer(2), <font color="#0000ff">new</font> Float(0.00),
      <font color="#004488">"2000-07-19 19:00:00"</font> },
    <font color="#009900">// Сопоставление людей и событий</font>
    {  <font color="#004488">"EVTMEMS"</font>, 
      <font color="#0000ff">new</font> Integer(1),  <font color="#009900">// Dave is going to</font></font>
      <font color="#0000ff" size="+1">new</font><font size="+1"> Integer(1),  <font color="#009900">// the Software event.</font></font>
      <font color="#0000ff" size="+1">new</font><font size="+1"> Integer(0) },
    { <font color="#004488">"EVTMEMS"</font>, 
      <font color="#0000ff">new</font> Integer(2),  <font color="#009900">// Bruce is going to</font></font>
      <font color="#0000ff" size="+1">new</font><font size="+1"> Integer(2),  <font color="#009900">// the Archeology event.</font></font>
      <font color="#0000ff" size="+1">new</font><font size="+1"> Integer(0) },
    { <font color="#004488">"EVTMEMS"</font>, 
      <font color="#0000ff">new</font> Integer(3),  <font color="#009900">// Robert is going to</font></font>
      <font color="#0000ff" size="+1">new</font><font size="+1"> Integer(1),  <font color="#009900">// the Software event.</font></font>
      <font color="#0000ff" size="+1">new</font><font size="+1"> Integer(1) },
    { <font color="#004488">"EVTMEMS"</font>, 
      <font color="#0000ff">new</font> Integer(3), <font color="#009900">// ... and </font></font>
      <font color="#0000ff" size="+1">new</font><font size="+1"> Integer(2), <font color="#009900">// the Archeology event.</font></font>
      <font color="#0000ff" size="+1">new</font><font size="+1"> Integer(1) },
  };
  <font color="#009900">// Use the default data set:</font></font>
  <font color="#0000ff" size="+1">public</font><font size="+1"> TestSet() {}
  <font color="#009900">// Use a different data set:</font></font>
  <font color="#0000ff" size="+1">public</font><font size="+1"> TestSet(Object[][] dat) { data = dat; }
}

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> LoadDB {
  Statement statement;
  Connection connection;
  TestSet tset;
  <font color="#0000ff">public</font> LoadDB(TestSet t) <font color="#0000ff">throws</font> SQLException {
    tset = t;
    <font color="#0000ff">try</font> {
      <font color="#009900">// Load the driver (registers itself)</font>
      Class.forName(CIDConnect.dbDriver);
    } <font color="#0000ff">catch</font>(java.lang.ClassNotFoundException e) {
      e.printStackTrace(System.err);
    }
    connection = DriverManager.getConnection(
      CIDConnect.dbURL, CIDConnect.user, 
      CIDConnect.password);
    statement = connection.createStatement();
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> cleanup() <font color="#0000ff">throws</font> SQLException {
    statement.close();
    connection.close();
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> executeInsert(Object[] data) {
    String sql = <font color="#004488">"insert into "</font> 
      + data[0] + <font color="#004488">" values("</font>;
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 1; i &lt; data.length; i++) {
      <font color="#0000ff">if</font>(data[i] <font color="#0000ff">instanceof</font> String)
        sql += <font color="#004488">"'"</font> + data[i] + <font color="#004488">"'"</font>;
      <font color="#0000ff">else</font>
        sql += data[i];
      <font color="#0000ff">if</font>(i &lt; data.length - 1)
        sql += <font color="#004488">", "</font>;
    }
    sql += ')';
    System.out.println(sql);
    <font color="#0000ff">try</font> {
      statement.executeUpdate(sql);
    } <font color="#0000ff">catch</font>(SQLException sqlEx) {
      System.err.println(<font color="#004488">"Insert failed."</font>);
      <font color="#0000ff">while</font> (sqlEx != <font color="#0000ff">null</font>) {
        System.err.println(sqlEx.toString());
        sqlEx = sqlEx.getNextException();
      }
    } 
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> load() {
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i&lt; tset.data.length; i++)
      executeInsert(tset.data[i]);
  }
  <font color="#009900">// Выбрасываем исключение на консоль:</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) 
  <font color="#0000ff">throws</font> SQLException {
    LoadDB db = <font color="#0000ff">new</font> LoadDB(<font color="#0000ff">new</font> TestSet());
    db.load();
    <font color="#0000ff">try</font> {
      <font color="#009900">// Получаем ResultSet из загруженной базы данных:</font>
      ResultSet rs = db.statement.executeQuery(
        <font color="#004488">"select "</font> +
        <font color="#004488">"e.EVT_TITLE, m.MEM_LNAME, m.MEM_FNAME "</font>+
        <font color="#004488">"from EVENTS e, MEMBERS m, EVTMEMS em "</font> +
        <font color="#004488">"where em.EVT_ID = 2 "</font> +
        <font color="#004488">"and e.EVT_ID = em.EVT_ID "</font> +
        <font color="#004488">"and m.MEM_ID = em.MEM_ID"</font>);
      <font color="#0000ff">while</font> (rs.next())
        System.out.println(
          rs.getString(1) + <font color="#004488">"  "</font> + 
          rs.getString(2) + <font color="#004488">", "</font> +
          rs.getString(3));
    } <font color="#0000ff">finally</font> {
      db.cleanup();
    }
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Класс <b>TestSet</b> содержит множество данных по умолчанию, 
  которое производится, если вы используете конструктор по умолчанию. Однако вы 
  можете создать объект <b>TestSet</b>, используя альтернативный набор данных 
  со вторым конструкторомo. Набор данных хранится в двумерном массиве типа <b>Object</b>, 
  поскольку он может быть любого типа, включая <b>String</b> или числовые типы. 
  Метод <b>executeInsert(&nbsp;)</b> использует RTTI того, чтобы различать данные 
  типа <b>String</b> (которые должны быть в кавычках) и данные не типа <b>String</b>, 
  так как SQL команда строится из данных. После печати этой команды на консоль 
  используется <b>executeUpdate(&nbsp;)</b> для отсылки ее в базу данных.</font></p>
<p><font face="Georgia">Конструктор для <b>LoadDB</b> создает соединение и пошагово 
  с помощью <b>load(&nbsp;)</b> проходит по данным и вызывает <b>executeInsert(&nbsp;)</b> 
  для каждой записи. <b>cleanup(&nbsp;)</b> закрывает инструкцию и соединение. 
  Чтобы гарантировать этот вызов, он помещен в предложение finally.</font></p>
<p><font face="Georgia">Как только база данных будет загружена, инструкция <b>executeQuery(&nbsp;)</b> 
  производит простое результирующее множество. Так как запрос комбинирует несколько 
  таблиц, он является примером объединения.</font></p>
<p><font face="Georgia">Более подробно о JDBC можно узнать в электронной документации, 
  которая распространяется как часть пакета Java от Sun. Кроме того, вы можете 
  найти дополнительную информацию в книге <i>JDBC Database Access with Java </i>(Hamilton, 
  Cattel, and Fisher, Addison-Wesley, 1997). Другие книги, посвященные</font><font face="Georgia"> 
  JDBC, появляются регулярно.</font></p>
<a name="_Toc481064879"></a><a name="Heading533"></a> 
<h2 align="left"><font face="Verdana"> Сервлеты<a name="_Toc463665192"></a><a name="Index2148"></a></font></h2>
<p><font face="Georgia">Доступ клиентов из Интернета или корпоративной сети бесспорно 
  является наиболее простым способом доступа многих пользователей к данным и ресурсам 
  </font><a name="fnB74" href="#fn74">[74]</a><font face="Georgia">. Этот тип 
  доступа основывается на клиентах, использующих стандарт World Wide Web или Hypertext 
  Markup Language (HTML) и Hypertext Transfer Protocol (HTTP). Servlet API устанавливает 
  общую структуру решения для удовлетворения запросам HTTP.</font></p>
<p><font face="Georgia">Традиционным способом решения такой проблемы, как изменение 
  Интернет-клиентом базы данных, было создание <a name="Index2149"></a><a name="Index2150"></a>HTML 
  страницы с текстовыми полями и кнопкой “submit”. Пользователь впечатывал 
  соответствующую инфрмацию и текстовых полях и нажимал кнопку “submit”. 
  Данные отправляются на URL, который говорит серверу что с ними делать, указывая 
  местоположение <a name="Index2151"></a><a name="Index2152"></a><a name="Index2153"></a>Common 
  Gateway Interface (CGI) программы, которую запускает сервер, обеспечивая программу 
  данными при вызове. CGI программы обычно пишутся на Perl, Python, C, C++ или 
  любом другом языке, который может читать со стандартного ввода и писать в стандартный 
  вывод. Таким образом, все, что делает Web сервер, это запуск CGI программы, 
  а для ввода и вывода используются стандартные потоки (или, иногда для ввода 
  используются переменные окружения). За все остальное отвечает CGI программа. 
  Сначала она проверяет данные и решает корректный ли у них формат. Если это не 
  так, CGI программа должна создать HTML, чтобы указать на проблему; эта страница 
  посылается Web серверу (через стандартный вывод из CGI программы), Который отсылает 
  ее пользователю. Пользователь должен вернуться к предыдущей странице и попробовать 
  вновь. Если данные корректны, CGI программа обрабатывает данные соответствующим 
  способом и, возможно, вставляет их в базу данных. Затем она должна создать соответствующую 
  HTML страницу для Web сервера, которая будет возвращена пользователю.</font></p>
<p><font face="Georgia">Это было бы идеально для перехода ан полностью Java-ориентированное 
  решение такой проблемы — апплет на стороне клиента проверяет и отсылает 
  данные, а сервлет на стороне сервера получает и обрабатывает их. К сожалению, 
  хотя апплеты и поддерживают технологию с достаточной поддержкой, их проблематично 
  использовать в Web, поскольку вы не можете рассчитывать, что определенная версия 
  Java, поддерживается на клиентском Web броузере. Фактически, вы не можете полагаться, 
  что Web броузер вообще поддерживает Java! В Интранет вы можете требовать определенный 
  уровень поддержки, который позволит создать гораздо большую гибкость в том, 
  что вы делаете, но для Web наиболее безопасным подходом является выполнение 
  всей обработки на стороне сервера и возвращение клиенту просого HTML кода. При 
  этом подходе никакой пользователь не будет отвергнут из-за того, что у него 
  нет правильно установленного программного обеспечения.</font></p>
<p><font face="Georgia">Поскольку сервлеты обеспечивают великолепное решение для 
  программирования на стороне сервера, они являются наиболее популярным объяснением 
  перехода на Java. Не только потому, что они обеспечивают рабочее пространство, 
  заменяющее CGI программирование (и снижают количество сложных CGI проблем), 
  но и весь ваш код становится переносимым между платформами при использовании 
  Java, а вы получаете доступ ко всему Java API (исключая, конечно, то, которое 
  поизводит GUI, например Swing).</font><a name="_Toc481064880"></a></p>
<a name="Heading534"></a> 
<h3 align="left"><font face="Verdana"> Основы сервлетов</font></h3>
<p><font face="Georgia">Архитектура API сервлетов состоит в том, что классический 
  сервис обеспечивается методом <b>service(&nbsp;)</b>, через который сервлету 
  посылаются все клиентские запросы, и методами жизненного цикла <b>init(&nbsp;) 
  </b>и <b>destroy(&nbsp;)</b>, которые вызываются только при загрузке и выгрузке 
  сервлета (это исключительные стуации).</font></p>
<blockquote> 
  <pre><font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">interface</font><font size="+1"> Servlet {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> init(ServletConfig config)
    <font color="#0000ff">throws</font> ServletException;
  <font color="#0000ff">public</font> ServletConfig getServletConfig();
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> service(ServletRequest req,
    ServletResponse res) 
    <font color="#0000ff">throws</font> ServletException, IOException;
  <font color="#0000ff">public</font> String getServletInfo();
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> destroy();
}</font></pre>
</blockquote>
<p><font face="Georgia">Изюминка <b>getServletConfig(&nbsp;)</b> состоит в том, 
  что он возвращает объект <b>ServletConfig</b>, который содержит параметры инициализации 
  и запуска для этого сервлета. <b>getServletInfo(&nbsp;)</b> возвращает строку, 
  содержащую информацию о сервлете, такую, как имя автора, версию и авторское 
  право.</font></p>
<p><font face="Georgia">Класс <b>GenericServlet</b> является реализацией оболочки 
  этого интерфейса и обычно не используется. Класс <b>HttpServlet</b> является 
  расширением <b>GenericServlet</b> и предназначен специально для обработки протокола 
  HTTP —<b> HttpServlet</b> один из тех классов, которые вы будете использовать 
  чаще всего.</font></p>
<p><font face="Georgia">Наиболее удобным инструментом сервлетного API является 
  внешние объекты, которые идут вместе с классом HttpServlet для его поддержки. 
  Если вы взглянете на метод <b>service(&nbsp;) </b>из интерфейса <b>Servlet</b>, 
  вы увидите, что он имеет два параметра: <b>ServletRequest</b> и <b>ServletResponse</b>. 
  У класса <b>HttpServlet</b> эти два объекта расширяются на HTTP: <b>HttpServletRequest</b> 
  и <b>HttpServletResponse</b>. Вот простой пример, который показывает использование 
  <b>HttpServletResponse</b>:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:servlets:ServletsRule.java</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.servlet.*;
<font color="#0000ff">import</font> javax.servlet.http.*;
<font color="#0000ff">import</font> java.io.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> ServletsRule <font color="#0000ff">extends</font> HttpServlet {
  <font color="#0000ff">int</font> i = 0; <font color="#009900">// Servlet "persistence"</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">void</font><font size="+1"> service(HttpServletRequest req, 
  HttpServletResponse res) <font color="#0000ff">throws</font> IOException {
    res.setContentType(<font color="#004488">"text</font></font><font color="#004488" size="+1">/html"</font><font size="+1">);
    PrintWriter out = res.getWriter();
    out.print(<font color="#004488">"&lt;HEAD&gt;&lt;TITLE&gt;"</font>);
    out.print(<font color="#004488">"A server-side strategy"</font>);
    out.print(<font color="#004488">"&lt;</font></font><font color="#004488" size="+1">/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;"</font><font size="+1">);
    out.print(<font color="#004488">"&lt;h1&gt;Servlets Rule! "</font> + i++);
    out.print(<font color="#004488">"&lt;</font></font><font color="#004488" size="+1">/h1&gt;&lt;/BODY&gt;"</font><font size="+1">);  
    out.close();    
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia"><b>ServletsRule</b> настолько прост, насколько может быть 
  прост сервлет. Сервлет инициализиуется только однажды путем вызова своего метода 
  <b>init(&nbsp;) </b>при загрузке сервлета после того, как сначала загрузиться 
  контейнер сервлетов. Когда клиент делает запрос к URL, соответствующий представленному 
  сервлету, контейнер сервлетов перехватывает этот запрос и делает вызов метода 
  <b>service(&nbsp;)</b>, затем устанавливает объекты <b>HttpServletRequest</b> 
  и <b>HttpServletResponse</b>.</font></p>
<p><font face="Georgia">Главная забота метода <b>service(&nbsp;)</b> состоит во 
  взаимодействии с HTTP запросом, посланным клиентом, и построение HTTP ответа, 
  основываясь на аттрибутах, содержащихся в запросе. <b>ServletsRule</b> манипулирует 
  объектом ответа не зависимот от того, что мог послать клиент.</font></p>
<p><font face="Georgia">После установки типа содержимого ответа (что всегда должно 
  быть сделано перед созданием <b>Writer </b>или <b>OutputStream</b>), метод <b>getWriter(&nbsp;)</b> 
  объекта ответа производит объект <b>PrintWriter</b>, который используется для 
  написания символьного ответа (другой подход: <b>getOutputStream(&nbsp;)</b> 
  производит <b>OutputStream</b>, используемы для бинарного ответа, который походит 
  только для специальных решений).</font></p>
<p><font face="Georgia">Оставшаяся часть программы просто посылает клиенту HTML 
  (тут предполагается, что вы понимаете HTML, так что эта часть не объясняется) 
  в виде последователности <b>String</b>. Однако, обратите внимание на включение 
  “счетчика посещений”, представленного переменной <b>i</b>. Здесь 
  выполняется автоматическая конвертация в <b>String</b> в инструкции <b>print(&nbsp;)</b>.</font></p>
<p><font face="Georgia">Когда вы запустите программу, вы увидите, что значение 
  <b>i</b> сохраняется между запросами к сервлету. Это важное свойство сервлетов: 
  так как только один сервлет определенного класса загружается в контейнер, и 
  он никогда не выгружается (только в случае, если контейнер сервлетов завершает 
  работу, что обычно случается, если вы перезагружаете машину), любые поля сервлета 
  этого класса загружаются в контейнер и становятся устойчивыми объектами! Это 
  означает, что вы можете без особого труда сохранять значения между запросами 
  к сервлету, а при использовании CGI вы должны записывать значения на диск, чтобы 
  сохранить его, что требует некоторое количество искусственности, а в результате 
  получаем ен кросс-платформенное решение.</font></p>
<p><font face="Georgia">Конечно иногда Web сервер и, соответственно, контейнер 
  сервлетов должен быть перегружен как часть процесса поддержки или из-за проблем 
  с питанием. Для предотвращения потери любой пристутствующей информации автоматически 
  вызываются методы сервлета <b>init(&nbsp;)</b> и <b>destroy(&nbsp;)</b> при 
  любой загрузке или выгрузке сервлета, что дает вам возможность сохранить данные 
  при выключении и восстановить их после перезагрузки. Контейнер сервлетов вызывает 
  метод <b>destroy(&nbsp;)</b>, как только он прекращает работу, так что вы всегда 
  имеете удобный случай сохранить важные данные.</font></p>
<p><font face="Georgia">Есть еще одна проблема при использовании <b>HttpServlet</b>. 
  Этот класс имеет методы <b>doGet(&nbsp;)</b> и <b>doPost(&nbsp;)</b>, которые 
  отличаются от метода “GET” CGI получения от клиента, и метода CGI 
  “POST”. GET и POST отличаются только в деталях способами, которыми 
  они передают данные, что лично я предпочитаю игнорировать. Однако чаще всего 
  публикуется информация, из того, что видел я, которая одобряет создание отдельных 
  методов <b>doGet(&nbsp;)</b> и <b>doPost(&nbsp;)</b> вместо единого общего метода 
  <b>service(&nbsp;)</b>, который обрабатывает оба случая. Это предпочтение кажется 
  достаточно общим, но я никогда не видел объяснения, которое заставило бы меня 
  поверить, что это не просто интертность мышления CGI программистов, которые 
  привыкли обращать внимание, используется ли GET или POST. Так что в духе “упрощения 
  всего насколько это возможно”</font><a name="fnB75" href="#fn75">[75]</a><font face="Georgia">, 
  я буду использовать метод <b>service(&nbsp;)</b> в этих примерах, и пусть он 
  сам заботиться о GET'ах и POST'ах. Однако держите в уме, что я что-то упустил, 
  что, возможно, является хорошей причиной в польху использования <b>doGet(&nbsp;)</b> 
  и <b>doPost(&nbsp;)</b>.</font></p>
<p><font face="Georgia">В любое время, когда форма передается сервлету, <b>HttpServletRequest</b> 
  предварительно загружает все данные формы, хранящиеся в виде пар ключ-значение. 
  Если вы знаете имена полей, вы можете просто использовать их напрямую с помощью 
  метода <b>getParameter(&nbsp;)</b> для получения значения. Вы также можете получить 
  <b>Enumeration</b> (старая форма <b>Iterator</b>) на имена полей, как показано 
  в следующем примере. Этот пример также демонстрирует как один сервлет может 
  быть использован для генерации страницы, которая содержит форму, и для ответа 
  на страницу (более удобное решение будет показано позже, при рассмотрении JSP). 
  Если <b>Enumeration</b> пустое, значит полей нет. Это значит, что никакой формы 
  не было передано. В этом случае содается форма, а кнопка посылки повторно вызывает 
  этот же сервлет. Если же поля существуют, они показываются.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:servlets:EchoForm.java</font>
<font color="#009900" size="+1">// Дамп пар имен-значений из любой формы HTML</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.servlet.*;
<font color="#0000ff">import</font> javax.servlet.http.*;
<font color="#0000ff">import</font> java.io.*;
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> EchoForm <font color="#0000ff">extends</font> HttpServlet {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> service(HttpServletRequest req, 
    HttpServletResponse res) <font color="#0000ff">throws</font> IOException {
    res.setContentType(<font color="#004488">"text</font></font><font color="#004488" size="+1">/html"</font><font size="+1">);
    PrintWriter out = res.getWriter();
    Enumeration flds = req.getParameterNames();
    <font color="#0000ff">if</font>(!flds.hasMoreElements()) {
      <font color="#009900">// Форма не передавалась - создание формы:</font>
      out.print(<font color="#004488">"&lt;html&gt;"</font>);
      out.print(<font color="#004488">"&lt;form method=\"</font>POST\<font color="#004488">""</font> + 
        <font color="#004488">" action=\"</font>EchoForm\<font color="#004488">"&gt;"</font>);
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i++)
        out.print(<font color="#004488">"&lt;b&gt;Field"</font> + i + <font color="#004488">"&lt;</font></font><font color="#004488" size="+1">/b&gt; "</font><font size="+1"> +
          <font color="#004488">"&lt;input type=\"</font>text\<font color="#004488">""</font>+
          <font color="#004488">" size=\"</font>20\<font color="#004488">" name=\"</font>Field" + i + 
          <font color="#004488">"\"</font> value=\<font color="#004488">"Value"</font> + i + <font color="#004488">"\"</font>&gt;&lt;br&gt;");
      out.print(<font color="#004488">"&lt;INPUT TYPE=submit name=submit"</font>+
      <font color="#004488">" Value=\"</font>Submit\<font color="#004488">"&gt;&lt;</font></font><font color="#004488" size="+1">/form&gt;&lt;/html&gt;"</font><font size="+1">);
    } <font color="#0000ff">else</font> {
      out.print(<font color="#004488">"&lt;h1&gt;Your form contained:&lt;</font></font><font color="#004488" size="+1">/h1&gt;"</font><font size="+1">);
      <font color="#0000ff">while</font>(flds.hasMoreElements()) {
        String field= (String)flds.nextElement();
        String value= req.getParameter(field);
        out.print(field + <font color="#004488">" = "</font> + value+ <font color="#004488">"&lt;br&gt;"</font>);
      }
    }
    out.close();    
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Здесь виден один из недостатков, заключающийся в том, 
  что Java не кажеться предназначенной для обработки строк в уме — форматирование 
  возвращаемой страницы достаточно неприятно из-за переводов строки, выделение 
  знаков кавычки и символов “+”, необходимых для построения объекта 
  <b>String</b>. С большими HTML страницами становится неразумно вносить этот 
  код прямо в Java. Одо из решений - держать страницу в виде отдельного текстового 
  файла, затем открывать и обрабатывать его на Web сервере. Если вы выполняете 
  любые подстановки в содержимом страницы, это не лучший подход, так как Java 
  плохо выполняет обработку строк. В этом случае для вас, вероятно, лучше будет 
  использовать более подходящее решение (Python может быть вашим выбором. Есть 
  версии, которые встраиваются в Java, называемые JPython) для генерации ответной 
  страницы.</font></p>
<a name="_Toc481064881"></a><a name="Heading535"></a> 
<h3 align="left"><font face="Verdana"> Сервлеты и множественные процессы<a name="Index2154"></a><a name="Index2155"></a></font></h3>
<p><font face="Georgia">Контейнер сервлетов имеет пул процессов, которые создаются 
  для обработки клиентских запросов. Это похоже на то, когда два клиента, прибывшие 
  одновременно, должны быть одновременно обработаны методом <b>service(&nbsp;)</b>. 
  Поэтому метод <b>service(&nbsp;)</b> должен быть написан безопасным способом 
  сточки зрения множественности процессов. Любой доступ к общим ресурсам (файлам, 
  базам данных) должен гарантированно использовать ключевое слово <b>synchronized</b>.</font></p>
<p><font face="Georgia">Следующий пример помещает предложение <b>synchronized 
  </b>вокруг метода процесса <b>sleep(&nbsp;)</b>. Это блокирует все другие методы 
  на заданное время (пять секунда), которое используют все. Когда будете проверять, 
  вы должны запустить несколько экземпляров окон броузера и обращаться к сервлету 
  так часто, как это возможно в каждом окне — вы увидите, что каждое окно 
  ждет, пока до него дойдет ход.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:servlets:ThreadServlet.java</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.servlet.*;
<font color="#0000ff">import</font> javax.servlet.http.*;
<font color="#0000ff">import</font> java.io.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> ThreadServlet <font color="#0000ff">extends</font> HttpServlet {
  <font color="#0000ff">int</font> i;
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> service(HttpServletRequest req, 
    HttpServletResponse res) <font color="#0000ff">throws</font> IOException {
    res.setContentType(<font color="#004488">"text</font></font><font color="#004488" size="+1">/html"</font><font size="+1">);
    PrintWriter out = res.getWriter();
    <font color="#0000ff">synchronized</font>(<font color="#0000ff">this</font>) {
      <font color="#0000ff">try</font> {
        Thread.currentThread().sleep(5000);
      } <font color="#0000ff">catch</font>(InterruptedException e) {
        System.err.println(<font color="#004488">"Interrupted"</font>);
      }
    }
    out.print(<font color="#004488">"&lt;h1&gt;Finished "</font> + i++ + <font color="#004488">"&lt;</font></font><font color="#004488" size="+1">/h1&gt;"</font><font size="+1">);
    out.close();    
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Также возможно синхронизировать весь сервлет, поместив 
  ключевое слово <b>synchronized</b> перед методом <b>service(&nbsp;)</b>. Фактически, 
  разумно использовать блок <b>synchronized</b> вместо этого, если есть критическая 
  секция при выполнении, которая может не получить управление. В этом случае вы 
  можетеизбегать синхронизации верхнего уровня, используя предложение <b>synchronized</b>. 
  В противном случае все процессы будут ожидать так или иначе, так что вы можете 
  синхронизировать (<b>synchronize</b>) весь метод.</font></p>
<p><a name="_Toc481064882"></a><a name="Heading536"></a> </p>
<h3 align="left"><font face="Verdana"> Управление сессиями с помощью сервлетов<a name="Index2156"></a><a name="Index2157"></a></font></h3>
<p><font face="Georgia">HTTP является протоколом, не использующим сессии, так 
  что вы не можете передать информацию из одного обращения к серверу в другое, 
  если один и тот же человек постоянно обращается к вашему сайту, или если это 
  совсем другой человек. Хорошим решением стало введение механизма, который позволял 
  Web разработчикам отслеживать сессии. Напимер, компании не могли заниматься 
  электронной коммерцией без отслеживания клиентов и предметов, которые они выбрали 
  в свою карзину покупок.</font></p>
<p><font face="Georgia">Есть несколько методов отслеживания сессий, но наиболее 
  общий метод связан с наличием “cookies”, что является интегрированной 
  частью стандарта Internet. Рабочая Группа HTTP из Internet Engineering Task 
  Force вписала <a name="Index2158"></a>cookies в официальный стандарт RFC 2109 
  (<i>ds.internic.net/rfc/rfc2109.txt</i> или проверьте на <i>www.cookiecentral.com</i>).</font></p>
<p><font face="Georgia">Cookie - это ничто иное, как маленький кусочек информации, 
  посылаемый Web сервером броузеру. Броузер хранит cookie на локальном диске, 
  и когда выполняется другой вызов на URL, с которым связано cookie, cookie спокойно 
  отсылается вместе с вызовом, тем самым сервер обеспечивается необходимой информацией 
  (обычно обеспечивается какой-то способ, чтобы сервер мог сказать, что это ваш 
  вызов). Однако, клиенты могут выключить возможность броузера получать cookies. 
  Если ваш сайт должен отслеживать клиентов с выключенными cookie, есть другой 
  метод отслеживания сессий (запись URL или спрятанные поля формы), которые встраиваются 
  в ручную, так как возможность отслеживания сессий встроена в API сервлетов и 
  разработана с упором на cookies.</font></p>
<a name="Heading537"></a> 
<h4 align="left"><font face="Verdana"> Класс Cookie</font></h4>
<p><font face="Georgia">API сервлетов (версии 2.0 и выше) имеет класс <b>Cookie</b>. 
  Этот класс объединяет все детали HTTP заголовка и позволяет устанавливать различные 
  аттрибуты cookie. Использование cookie просто и есть смысл добавлять его в объекты 
  ответов. Конструктор получает имя cookie в качестве первого аргумента, а значение 
  в качестве второго. Cookies добавляются в объект ответа прежде, чем вы отошлете 
  любое содержимое.</font></p>
<blockquote> 
  <pre><font size="+1">Cookie oreo = <font color="#0000ff">new</font> Cookie(<font color="#004488">"TIJava"</font>, <font color="#004488">"2000"</font>);
res.addCookie(cookie);</font></pre>
</blockquote>
<p><font face="Georgia">Cookies извлеваются путем вызова метода <b>getCookies(&nbsp;)</b> 
  объекта <b>HttpServletRequest</b>, который возвращают массив из объектов cookie.</font></p>
<blockquote> 
  <pre><font size="+1">Cookie[] cookies = req.getCookies();</font></pre>
</blockquote>
<p><font face="Georgia">Затем вы можете вызвать <b>getValue(&nbsp;)</b> для каждого 
  из cookie для получения строки (<b>String</b>) содержимого cookie. В приведенном 
  выше примере <b>getValue("TIJava") </b> вернет строку (<b>String</b>), содержащую 
  “2000”.</font></p>
<a name="Heading538"></a> 
<h4 align="left"><font face="Verdana"> Класс Session</font></h4>
<p><font face="Georgia">Сессия состоит из запроса клиентом одной или нескольких 
  страниц Web сайта за определенный период времени. Например, если вы покупаете 
  бакалею в режиме онлайн, вы хотите, чтобы сессия была подтверждена с того момента, 
  когда вы добавили первый элемент в “свою карзину покупок” до момента 
  проверки состояния карзины. При каждом добавлении в карзину покупок нового элемента 
  в результате получается новое HTTP соединение, котоое не имеет инфрмации о предыдущих 
  соединениях или элементах, уже находящихся в корзине покупок. Чтобы компенсировать 
  утечку информации механики снабдили спецификацией cookie, позволяющей вашему 
  сервлету следить за сессией.</font></p>
<p><font face="Georgia">Объект сервлета <b>Session</b> живет на стороне сервера 
  соединительного канала. Он предназначен для сбора полезной информации о клиенте, 
  его перемещении по сайту и взаимодействию с ним. Эти данные могут подходить 
  для представления сессии, так например для элементов в корзине покупок, или 
  это могут быть такие даные, как информация об авторизации, которая была введена 
  при первом входе клиента на ваш Web сайт, и которую не нужно вводить повторно 
  во время выполнения определенных обращений.</font></p>
<p><font face="Georgia">Класс <b>Session</b> из API сервлета использует класс 
  <b>Cookie</b>, чтобы сделать эту работу. Однако всем объектам <b>Session</b> 
  необходим уникальный идентификатор некоторого вида, хранимый на стороне клиента 
  и передающийся на сервер. Web сайты могут также использовать другие типы слежения 
  за сессиями, но эти механизмы более сложны для реализации, так как они не инкапсулированы 
  в API сервлетов (так что вы должны писать их руками, чтобы разрешить ситуации, 
  когда клиент отключает cookies).</font></p>
<p><font face="Georgia">Вот пример, который реализует слежение за сессиями с помощью 
  сервлетного API:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:servlets:SessionPeek.java</font>
<font color="#009900" size="+1">// Использование класса HttpSession.</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> java.io.*;
<font color="#0000ff">import</font> java.util.*;
<font color="#0000ff">import</font> javax.servlet.*;
<font color="#0000ff">import</font> javax.servlet.http.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> SessionPeek <font color="#0000ff">extends</font> HttpServlet { 
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> service(HttpServletRequest req, 
  HttpServletResponse res)
  <font color="#0000ff">throws</font> ServletException, IOException {
    <font color="#009900">// Получаем объект Session перед любой</font></font>
    <font color="#009900" size="+1">// исходящей посылкой клиенту.</font><font size="+1">
    HttpSession session = req.getSession();
    res.setContentType(<font color="#004488">"text</font></font><font color="#004488" size="+1">/html"</font><font size="+1">);
    PrintWriter out = res.getWriter();
    out.println(<font color="#004488">"&lt;HEAD&gt;&lt;TITLE&gt; SessionPeek "</font>);
    out.println(<font color="#004488">" &lt;</font></font><font color="#004488" size="+1">/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;"</font><font size="+1">);
    out.println(<font color="#004488">"&lt;h1&gt; SessionPeek &lt;</font></font><font color="#004488" size="+1">/h1&gt;"</font><font size="+1">);
    <font color="#009900">// Простой счетчик посещений для этой сессии.</font>
    Integer ival = (Integer) 
      session.getAttribute(<font color="#004488">"sesspeek.cntr"</font>);
    <font color="#0000ff">if</font>(ival==<font color="#0000ff">null</font>) 
      ival = <font color="#0000ff">new</font> Integer(1);
    <font color="#0000ff">else</font> 
      ival = <font color="#0000ff">new</font> Integer(ival.intValue() + 1);
    session.setAttribute(<font color="#004488">"sesspeek.cntr"</font>, ival);
    out.println(<font color="#004488">"You have hit this page &lt;b&gt;"</font>
      + ival + <font color="#004488">"&lt;</font></font><font color="#004488" size="+1">/b&gt; times.&lt;p&gt;"</font><font size="+1">);
    out.println(<font color="#004488">"&lt;h2&gt;"</font>);
    out.println(<font color="#004488">"Saved Session Data &lt;</font></font><font color="#004488" size="+1">/h2&gt;"</font><font size="+1">);
    <font color="#009900">// Цикл по всем данным сессии:</font>
    Enumeration sesNames = 
      session.getAttributeNames();
    <font color="#0000ff">while</font>(sesNames.hasMoreElements()) {
      String name = 
        sesNames.nextElement().toString();
      Object value = session.getAttribute(name);
      out.println(name + <font color="#004488">" = "</font> + value + <font color="#004488">"&lt;br&gt;"</font>);
    }
    out.println(<font color="#004488">"&lt;h3&gt; Session Statistics &lt;</font></font><font color="#004488" size="+1">/h3&gt;"</font><font size="+1">);
    out.println(<font color="#004488">"Session ID: "</font> 
      + session.getId() + <font color="#004488">"&lt;br&gt;"</font>);
    out.println(<font color="#004488">"New Session: "</font> + session.isNew()
      + <font color="#004488">"&lt;br&gt;"</font>);
    out.println(<font color="#004488">"Creation Time: "</font>
      + session.getCreationTime());
    out.println(<font color="#004488">"&lt;I&gt;("</font> + 
      <font color="#0000ff">new</font> Date(session.getCreationTime())
      + <font color="#004488">")&lt;</font></font><font color="#004488" size="+1">/I&gt;&lt;br&gt;"</font><font size="+1">);
    out.println(<font color="#004488">"Last Accessed Time: "</font> +
      session.getLastAccessedTime());
    out.println(<font color="#004488">"&lt;I&gt;("</font> +
      <font color="#0000ff">new</font> Date(session.getLastAccessedTime())
      + <font color="#004488">")&lt;</font></font><font color="#004488" size="+1">/I&gt;&lt;br&gt;"</font><font size="+1">);
    out.println(<font color="#004488">"Session Inactive Interval: "</font>
      + session.getMaxInactiveInterval());
    out.println(<font color="#004488">"Session ID in Request: "</font>
      + req.getRequestedSessionId() + <font color="#004488">"&lt;br&gt;"</font>);
    out.println(<font color="#004488">"Is session id from Cookie: "</font>
      + req.isRequestedSessionIdFromCookie()
      + <font color="#004488">"&lt;br&gt;"</font>);
    out.println(<font color="#004488">"Is session id from URL: "</font>
      + req.isRequestedSessionIdFromURL()
      + <font color="#004488">"&lt;br&gt;"</font>);
    out.println(<font color="#004488">"Is session id valid: "</font>
      + req.isRequestedSessionIdValid()
      + <font color="#004488">"&lt;br&gt;"</font>);
    out.println(<font color="#004488">"&lt;</font></font><font color="#004488" size="+1">/BODY&gt;"</font><font size="+1">);
    out.close();
  }
  <font color="#0000ff">public</font> String getServletInfo() {
    <font color="#0000ff">return</font></font> <font color="#004488" size="+1">"A session tracking servlet"</font><font size="+1">;
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Внутри метода <b>service(&nbsp;)</b>, <b>getSession(&nbsp;)</b> 
  вызывает ся для объекта запроса, который возвращает объект <b>Session</b>, связанный 
  с этим запросом. Объект <b>Session</b> не перемещается по сети, а вместо этого 
  он живет на сервере и ассоциируется с клиентом и его запросами.</font></p>
<p><font face="Georgia"><b>getSession(&nbsp;)</b> существует в двух версиях: без 
  параметров, как использовано здесь, и <b>getSession(boolean)</b>. <b>getSession(true)</b> 
  эквивалентно вызову <b>getSession(&nbsp;)</b>. Причина введения <b>boolean</b> 
  состоит определении, когда вы хотите создать объект сессии, если он не найден. 
  <b>getSession(true)</b> вызывается чаще всего, отсюда и взялось <b>getSession(&nbsp;)</b>.</font></p>
<p><font face="Georgia">объект <b>Session</b>, если он не новый, детально сообщает 
  нам о клиенте из предыдущих визитов. Если объект <b>Session</b> новый, то программа 
  начинает сбор информации об активности этого клиента в этом визите. Сбор информации 
  об этом клиенте выполняется методами <b>setAttribute(&nbsp;)</b> и <b>getAttribute(&nbsp;)</b> 
  объекта сессии.</font></p>
<blockquote> 
  <pre><font size="+1">java.lang.Object getAttribute(java.lang.String)
<font color="#0000ff">void</font> setAttribute(java.lang.String name,
                  java.lang.Object value)</font></pre>
</blockquote>
<p><font face="Georgia">Объект <b>Session</b> использует простые пары из имени 
  и значения для загрузки информации. Имя является объектом типа <b>String</b>, 
  а значение может быть любым объектом, унаследованным от <b>java.lang.Object</b>. 
  <b>SessionPeek</b> следит за тем, сколько раз клиент возвращался во время сессии. 
  Это сделано с помощью объекта <b>sesspeek.cntr</b> типа <b>Integer</b>. Если 
  имя не найдено, создается объект <b>Integer</b> с единичным значением, в противном 
  случае <b>Integer</b> создается с инкрементированным значением, взятым от предыдущего 
  <b>Integer</b>. Новый объект <b>Integer</b> помещается в объект <b>Session</b>. 
  Если вы используете этот же ключ в вызове <b>setAttribute(&nbsp;)</b>, то новый 
  объект запишется поверх старого. Инкрементируемый счетчик используется для отображения 
  числа визитов клиента во время этой сесии.</font></p>
<p><font face="Georgia"><b>getAttributeNames(&nbsp;) </b> относится как к <b>getAttribute(&nbsp;)</b>, 
  так и к <b>setAttribute(&nbsp;)</b>; он возвращает enumeration из имен объектов, 
  прикрепленных к объекту <b>Session</b>. Цикл <b>while</b> в <b>SessionPeek</b> 
  показывает этот метод в действии.</font></p>
<p><font face="Georgia">Вы можете быть удивлены как долго сохраняется объект <b>Session</b>. 
  Ответ зависит от используемого вами контейнера сервлетов; по умолчанию обычно 
  это длится до 30 минут(1800 секунд), это вы можете увидеть при вызове <b>getMaxInactiveInterval(&nbsp;)</b> 
  из <b>ServletPeek</b>. Тесты показывают разные результаты, в зависимости от 
  контейнера сервлетов. Иногда объект <b>Session</b> может храниться всю ночь, 
  но я никогда не видел случаю, чтобы объект <b>Session</b> исчезал раньше указанного 
  неактивного интервала времени. Вы можете попробовать установить интервал неактивномти 
  с помощью <b>setMaxInactiveInterval(&nbsp;)</b> до 5 секунд и проверить очистится 
  ли ваш объект <b>Session</b> через соответствующее время. Это может быть тот 
  аттрибут, который вы захотите исследовать при выборе контейнера сервлетов.</font></p>
<a name="_Toc481064883"></a><a name="Heading539"></a> 
<h3 align="left"><font face="Verdana"> Запуск примеров сервлетов</font></h3>
<p><font face="Georgia">Если вы раньше не работали с сервером приложений, который 
  обрабатывает сервлеты от Sun и поддерживает JSP технологию, вы можете получить 
  реализацию <a name="Index2159"></a><a name="Index2160"></a>Tomcat для Java сервлетов 
  и JSP, который является бесплатным, с открытым кодом реализации сервлетов, а 
  официальная ссылка на реализацию санкционирована Sun. Его можно найти на <i>jakarta.apache.org</i>.</font></p>
<div align="left"> 
  <p><font face="Georgia">Следуйте инструкции по инсталяции реализации Tomcat, 
    затем отредактируйте файл <b>server.xml</b>, чтобы он указывал на ваше дерево 
    директориев, в котором помещены ваши сервлеты. Как только вы запустите программу 
    Tomcat, вы сможете протестировать ваши сервлеты.</font></p>
</div>
<p><font face="Georgia">Это было только короткое введение в сервлеты. Есть много 
  книг, посвещенных этой теме. Однако, это введение должно дать вам достаточно 
  идей, чтобы позволить начать работать. Кроме того, многие из идей следующего 
  раздела снова возвращают нас к сервлетам.</font></p>
<p><a name="_Toc463665186"></a><a name="_Toc481064884"></a><a name="Heading540"></a> 
</p>
<h2 align="left"><font face="Verdana"> Java Server Pages<a name="Index2161"></a><a name="Index2162"></a></font></h2>
<p><font face="Georgia">Java Server Pages (JSP) является стандартным расширением 
  Java, который определен на основании сервлетного Расширения. Целью JSP является 
  упрощение создания и управления динамическими Web страницами.</font></p>
<p><font face="Georgia">Как упоминалось ранее, свободно распространяемое ПО Tomcat, 
  которую можно получить с <i>jakarta.apache.org</i> автоматически поддерживает 
  JSP.</font></p>
<div align="left"> 
  <p><font face="Georgia">JSP позволяет вам комбинировать HTML код Web страницы 
    с кусочками Java кода в одном и том же документе. Код Java окружатся специальными 
    ярлыками, которые говорят JSP контейнеру, что он должен использовать этот 
    код для генерации сервлета илил его части. Преимущество JSP в том, что вы 
    можете иметь единый документ, который представляет и страницу, и Java код, 
    который включается в нее. Недостатотк в том, что поддерживающий JSP страницу 
    человек должен быть опытен и в HTML и в Java (однако разработчик GUI сред 
    для JSP к этому приближается).</font></p>
</div>
<p><font face="Georgia">В первый раз JSP загружается JSP контейнером (который 
  обычно связан с Web сервером, или является его частью), код сервлета, помеченный 
  JSP ярлыками, автоматически генерируется, компилируется и загружатся и контейнер 
  сервлетов. Статическая часть HTML страницы воспроизводится путем посылки статического 
  объекта <b>String </b>в метод <b>write(&nbsp;)</b>. Динамическая часть включается 
  прямо в сервлет.</font></p>
<p><font face="Georgia">Исходя из этого, пока исходный текст JSP страницы не изменяется, 
  она ведет себя так, как будто это статическая HTML страница с ассоциированным 
  сервлетом (однако, весь HTML код на самом деле генерируется сервлетом). Если 
  вы изменяете исходный код для JSP, он автоматически перекомпилируется и перегружается 
  при следующем запросе этой страницы. Конечно, из-за всей этой динамики вы увидите 
  замедленый ответ на первый запрос этой JSP страницы. Но поскольку JSP использует 
  немного больше, чем просто изменения, обычно вы не встретите этой задержки.</font></p>
<p><font face="Georgia">Структура JSP страницы состоит из перемешивания сервлета 
  и HTML страницы. JSP ярлыки начинаются и заканчиваются угловыми скобками, так 
  же как и ярлыки HTML, но эти ярлыки также включают символ процентов, так что 
  все JSP ярлыки обозначаются</font></p>
<blockquote> 
  <pre><font size="+1">&lt;% JSP code here %&gt;</font></pre>
</blockquote>
<p><font face="Georgia">За первым знаком процента могут следовать другие символы, 
  которые означают часть JSP кода в ярлыке.</font></p>
<p><font face="Georgia">Ниже приведен очень простой пример JSP, который использует 
  стандартную вызов Java библиотеки для получения текущего времени в милисекундах, 
  затем это значение делится на 1000, для получение времени в секундах. Так как 
  используется <i>JSP выражение </i> ( <b>&lt;%=</b> ), результат вычислений конвертируется 
  в <b>String</b>, и помещается на генерируемую Web страницу:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//:! c15:jsp:ShowSeconds.jsp</font>
<font size="+1">&lt;html&gt;&lt;body&gt;
&lt;H1&gt;The time in seconds is: 
&lt;%= System.currentTimeMillis()/1000 %&gt;&lt;/H1&gt;
&lt;/body&gt;&lt;/html&gt;
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">В JSP примерах этой книги первая и последняя строки не 
  будут включаться в файл реального кода, который помещен в архив исходного кода, 
  прилагающийся к этой книге.</font></p>
<p><font face="Georgia">Когда клиент создает запрос к JSP странице, Web сервер 
  должен быть сконфигурирован, чтобы соответствовать запросам JSP контейнера, 
  который затем вызывает страницу. Как упоминалось ранее, при первом вызове страницы, 
  компоненты, указанные на странице компоненты генерируются и компилируются JSP 
  контенером в один или несколько сервлетов. В приведенном выше примере сервлет 
  будет содержать код для конфигурирования объекта <b>HttpServletResponse</b>, 
  производящего объект <b>PrintWriter</b> (который всегда называется <b>out</b>), 
  а затем происходит вычисление <b>String</b>, которая посылается в <b>out</b>. 
  Как вы можете видеть, все это выполняется с помощью очень краткой инструкции, 
  но среднестатистический HTML программист/Web дизайнер не имеют опыта в написании 
  такого кода.</font></p>
<a name="_Toc481064885"></a><a name="Heading541"></a> 
<h3 align="left"><font face="Verdana"> Неявные объекты</font></h3>
<p><font face="Georgia">Сервлеты включают классы, которые обеспечивают соответствующие 
  утилиты, такие как <b>HttpServletRequest</b>, <b>HttpServletResponse</b>, <b>Session</b> 
  и т.д. Объекты этих классов встроены в JSP спецификацию и автоматически доступны 
  для использования в вашем JSP коде без написания дополнительных строчек кода 
  Неявные объекты JSP сведены в приведенную ниже таблицу.</font></p>
<table border="1" width="100%">
  <tbody><tr valign="top"> 
    <td> 
      <p><font face="Georgia"><b>Неявная переменная</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia"><b>Тип (javax.servlet)</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia"><b>Описание</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia"><b>Границы</b></font></p>
    </td>
  </tr>
  <tr valign="top"> 
    <td> 
      <p><font face="Georgia"><b>request</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Зависящий от протокола тип, производный от <b>HttpServletRequest</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Запрос, который вызывает обращение к службе.</font></p>
    </td>
    <td> 
      <p><font face="Georgia">запрос</font></p>
    </td>
  </tr>
  <tr valign="top"> 
    <td> 
      <p><font face="Georgia"><b>response</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Зависящий от протокола тип, производный от <b>HttpServletResponse</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Ответ на запрос.</font></p>
    </td>
    <td> 
      <p><font face="Georgia">страница</font></p>
    </td>
  </tr>
  <tr valign="top"> 
    <td> 
      <p><font face="Georgia"><b>pageContext</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia"><b>jsp.PageContext</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Содержимое страницы включает зависящие от реализации 
        особенности и обеспечивает удобные методы и доступ к пространству имен 
        для JSP.</font></p>
    </td>
    <td> 
      <p><font face="Georgia">страница</font></p>
    </td>
  </tr>
  <tr valign="top"> 
    <td> 
      <p><font face="Georgia"><b>session</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Зависящий от протокола тип, производный от <b>http.HttpSession</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Объект сессии, созданный для клиентского запроса. 
        Смотрите объект Session для сервлетов.</font></p>
    </td>
    <td> 
      <p><font face="Georgia">сессия</font></p>
    </td>
  </tr>
  <tr valign="top"> 
    <td> 
      <p><font face="Georgia"><b>application</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia"><b>ServletContext</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Контекст сервлета получается из конфигурирующего 
        сервлет объекта (e.g., <b>getServletConfig()</b>, <b>getContext(&nbsp;)</b>.</font></p>
    </td>
    <td> 
      <p><font face="Georgia">приложение</font> </p>
    </td>
  </tr>
  <tr valign="top"> 
    <td> 
      <p><font face="Georgia"><b>out</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia"><b>jsp.JspWriter</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Объект, который пишет в выходной поток.</font></p>
    </td>
    <td> 
      <p><font face="Georgia">страница</font></p>
    </td>
  </tr>
  <tr valign="top"> 
    <td> 
      <p><font face="Georgia"><b>config</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia"><b>ServletConfig</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia"> <b>ServletConfig</b> для этого JSP.</font></p>
    </td>
    <td> 
      <p><font face="Georgia">страница</font></p>
    </td>
  </tr>
  <tr valign="top"> 
    <td> 
      <p><font face="Georgia"><b>page</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia"><b>java.lang.Object</b></font></p>
    </td>
    <td> 
      <p><font face="Georgia">Экземпляр класса страницы, обрабатывающей этот запрос.</font></p>
    </td>
    <td> 
      <p><font face="Georgia">страница</font></p>
    </td>
  </tr>
</tbody></table>
<p><font face="Georgia">Границы видимости каждого объекта могут значительно отличаться. 
  Например, объект <b>session</b> имеет границы видимости, которые превышают страницу, 
  так как он может отвечать за несколько клиентских запросов и страниц. Объект 
  <b>application</b> может предоставить сервис для группы JSP страниц, которые 
  совместно представляют Web приложение.</font></p>
<a name="_Toc481064886"></a><a name="Heading542"></a> 
<h3 align="left"><font face="Verdana"> Директивы JSP</font></h3>
<div align="left"> 
  <p><font face="Georgia">Директивы являются сообщениями для JSP контенера и указываются 
    символом “<b>@</b>”:</font></p>
</div>
<blockquote> 
  <pre><font size="+1">&lt;%@ directive {attr=<font color="#004488">"value"</font>}* %&gt;</font></pre>
</blockquote>
<p><font face="Georgia">Директивы ничего не посылают в поток <b>out</b>, но они 
  важны в настройке атрибутов ваших JSP страниц и взаиможействий с JSP контейнером. 
  Например строка:</font></p>
<blockquote> 
  <pre><font size="+1">&lt;%@ page language=<font color="#004488">"java"</font> %&gt;</font></pre>
</blockquote>
<p><font face="Georgia">сообщает, что на JSP странице используется язык скриптов 
  Java. На самом деле JSP спецификации <i>только</i> описывают, что семантика 
  языка скриптов аналогична “Java”. Назначение этой директивы состоит 
  в придании гибкости технологии JSP. В будующем, если вы выберите другой язык, 
  скажем Python (хороший выбор для написания скриптов), и этот язык будет иметь 
  поддержку Java Run-time Environment, с применением технологии Java объектыных 
  моделей для среды скриптов, особенно это относится к определенным выше переменным, 
  свойствам JavaBeans и публичным методам.</font></p>
<p><font face="Georgia">Наиболее важная директива - это директива страницы. Она 
  определяет номер страницы в зависимости от атрибутов и взаимодействия между 
  этими атрибутами и JSP контейнером. К таким атрибутам относятся: <b>language</b>, 
  <b>extends</b>, <b>import</b>, <b>session</b>, <b>buffer</b>, <b>autoFlush</b>, 
  <b>isThreadSafe</b>, <b>info</b> и <b>errorPage</b>. Например:</font></p>
<blockquote> 
  <pre><font size="+1">&lt;%@ page session=”<font color="#0000ff">true</font>” <font color="#0000ff">import</font>=”java.util.*” %&gt;</font></pre>
</blockquote>
<p><font face="Georgia">Эта строка указывает, что страница требует участия HTTP 
  сессии. Так как мы не установили директивы языка, JSP контейнер по умолчанию 
  использует Java и подразумеваемую переменную языка скриптов, называемую <b>session</b> 
  типа <b>javax.servlet.http.HttpSession</b>. Если бы директива была ложна, то 
  неявная переменная <b>session</b> была бы недоступна. Если переменная <b>session</b> 
  не указана, то используется значение по умолчанию “true”.</font></p>
<p><font face="Georgia">Аттрибут <b>import</b> описывает типы, которые доступны 
  в окружении скриптов. Этот атрибут используется так, как если бы он использовался 
  в языке программирования Java, т.е. это разделеный запятыми список, как и обычное 
  выражение <b>import</b>. Этот список импортируется реализацией транслированной 
  JSP страницы и доступен для среды скрипта. Опять таки, пока это определено, 
  когда значение директивы языка - “java”.</font></p>
<a name="_Toc481064887"></a><a name="Heading543"></a> 
<h3 align="left"><font face="Verdana"> Элемены JSP скриптов</font></h3>
<p><font face="Georgia">После того, как были использованы директивы для настойки 
  среды скриптов, вы можете использовать элементы языка скриптов. JSP 1.1 имеет 
  три элемента языка скриптов — <i>declarations</i>, <i>scriptlets</i>, 
  и <i>expressions</i>. Declaration декларирует элементы, Scriptlet - это фрагмент 
  инструкций, а Еxpression - это законченное выражение языка. В JSP каждый элемент 
  сценария начинается с “<b>&lt;%</b>”. Синтаксис для каждого следующий:</font></p>
<blockquote> 
  <pre><font size="+1">&lt;%! declaration %&gt;
&lt;%  scriptlet   %&gt;
&lt;%= expression  %&gt;</font></pre>
</blockquote>
<p><font face="Georgia">Пробелы полсе “&lt;%!”, “&lt;%”, 
  “&lt;%=” и перед “%&gt;” не обязательны.</font></p>
<p><font face="Georgia">Все эти ярлыки базируются на XML. Вы даже можете сказать, 
  что JSP страница может быть преобразована в XML документ. Эквивалентный XML 
  синтаксис для элементов скриптов, приведенных выше, должен быть:</font></p>
<blockquote> 
  <pre><font size="+1">&lt;jsp:declaration&gt; declaration &lt;/jsp:declaration&gt;
&lt;jsp:scriptlet&gt;   scriptlet   &lt;/jsp:scriptlet&gt;
&lt;jsp:expression&gt;  expression  &lt;/jsp:expression&gt;</font></pre>
</blockquote>
<p><font face="Georgia">Кроме того, есть два типа коментариев:</font></p>
<blockquote> 
  <pre><font size="+1">&lt;%-- jsp comment --%&gt;
&lt;!-- html comment --&gt;</font></pre>
</blockquote>
<p><font face="Georgia">Первая форма позволяет вам добавлять компоненты в исходный 
  текст JSP страницы, который не будет появляться в любой форме HTML страницы, 
  посылаемой клиенту. Конечно, вторая форма коментариев не спечефично для JSP 
  — это просто обычный коментарий HTML. Что интересно, вы можете вставить 
  JSP код внутрь HTML коментария, и коментарий будет вставлен в рузультирующую 
  страницу, включая результат работы JSP кода.</font></p>
<p><font face="Georgia">Declaration испоьзуется для объявления переменных и методов 
  в языке скриптов (пока только в Java), используемых JSP страницей. Декларация 
  должна быть завершенной инструкцией Java и не может совершать вывод в поток 
  <b>out</b>. В приведенном ниже примере <b>Hello.jsp </b>декларация переменных 
  <b>loadTime</b>, <b>loadDate</b> и <b>hitCount</b> является законченной инструкцией 
  Java, которая объявляет и инициализирует новые переменные.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//:! c15:jsp:Hello.jsp</font>
<font size="+1">&lt;%-- This JSP comment will not appear in the
generated html --%&gt;
&lt;%-- This is a JSP directive: --%&gt;
&lt;%@ page <font color="#0000ff">import</font>=<font color="#004488">"java.util.*"</font> %&gt;
&lt;%-- These are declarations: --%&gt;
&lt;%!
    <font color="#0000ff">long</font> loadTime= System.currentTimeMillis();
    Date loadDate = <font color="#0000ff">new</font> Date();
    <font color="#0000ff">int</font> hitCount = 0;
%&gt;
&lt;html&gt;&lt;body&gt;
&lt;%-- The next several lines are the result of a 
JSP expression inserted in the generated html;
the '=' indicates a JSP expression --%&gt;
&lt;H1&gt;This page was loaded at &lt;%= loadDate %&gt; &lt;/H1&gt;
&lt;H1&gt;Hello, world! It's &lt;%= <font color="#0000ff">new</font> Date() %&gt;&lt;/H1&gt;
&lt;H2&gt;Here's an object: &lt;%= <font color="#0000ff">new</font> Object() %&gt;&lt;/H2&gt;
&lt;H2&gt;This page has been up 
&lt;%= (System.currentTimeMillis()-loadTime)/1000 %&gt;
seconds&lt;/H2&gt;
&lt;H3&gt;Page has been accessed &lt;%= ++hitCount %&gt; 
times since &lt;%= loadDate %&gt;&lt;/H3&gt;
&lt;%-- A <font color="#004488">"scriptlet"</font> that writes to the server
console and to the client page. 
Note that the ';' is required: --%&gt;
&lt;%
   System.out.println(<font color="#004488">"Goodbye"</font>);
   out.println(<font color="#004488">"Cheerio"</font>);
%&gt;
&lt;/body&gt;&lt;/html&gt;
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Когда вы запустите эту программу, вы увидите, что переменные 
  <b>loadTime</b>, <b>loadDate</b> и <b>hitCount</b> сохраняют свои начения между 
  обращениями к странице, так что, конечно, они являются полями, а не локальными 
  переменными.</font></p>
<p><font face="Georgia">В конце примера скриплет пишет “Goodbye” на 
  консоле Web сервера и “Cheerio” в неявный объект <b>out</b> типа 
  <b>JspWriter</b>. Скриплеты могут содержать любой фрагмент кода, содержащий 
  правильные Java инструкции. Скриплеты выполняются во время обработки запроса. 
  Когда все фрагменты скриплетов в данном JSP скомбинированы так, как они введены 
  в JSP страницу, они должны произвести дествительное выражение, которое определено 
  в языке программирования Java. Будет или нет производиться какой-либо вывод 
  в поток <b>out</b> зависит от кода скриплета. Вы должны быть уверены, что скриплеты 
  могут производить какие-либо эффекты при изменении видимых для них объектов.</font></p>
<p><font face="Georgia">JSP выражения (expression) могут быть найдены среди HTML 
  кода в средней части <b>Hello.jsp</b>. Выражения должны быть законченными Java 
  инструкциями, которые вычисляют, приводят к <b>String</b>, и посылают в <b>out</b>. 
  Если результат выражения не может быть приведен к <b>String</b>, выбрасывается 
  <b>ClassCastException</b>.</font></p>
<a name="_Toc481064888"></a><a name="Heading544"></a> 
<h3 align="left"><font face="Verdana"> Извлечение полей и значений</font></h3>
<p><font face="Georgia">Приведенный ниже пример сож с приведенным ранее в разделе, 
  посвященном сервлетам. При первом обращении к странице он определяет, что у 
  вас нет полей и возвращает страницу, содержащую форму, используя тот же самй 
  код, что и в примере с сервлетом, но в формате JSP. Когда вы отсылаете форму 
  с заполненными полями на тот же самый JSP URL, он находит поля и отображает 
  их. Это хорошая техника, поскольку она позволяет вам иметь и страницу, содержащую 
  форму для заполнения пользователем, и код ответа на эту форму, как единый файл, 
  что облегчает создание и поддержку.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//:! c15:jsp:DisplayFormData.jsp</font>
<font size="+1">&lt;%-- Fetching the data from an HTML form. --%&gt;
&lt;%-- This JSP also generates the form. --%&gt;
&lt;%@ page <font color="#0000ff">import</font>=<font color="#004488">"java.util.*"</font> %&gt;
&lt;html&gt;&lt;body&gt;
&lt;H1&gt;DisplayFormData&lt;/H1&gt;&lt;H3&gt;
&lt;%
  Enumeration flds = request.getParameterNames();
  <font color="#0000ff">if</font>(!flds.hasMoreElements()) { <font color="#009900">// No fields %&gt;</font></font>
    <font size="+1">&lt;form method=<font color="#004488">"POST"</font> 
    action=<font color="#004488">"DisplayFormData.jsp"</font>&gt;
&lt;%  <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i++) {  %&gt;
      Field&lt;%=i%&gt;: &lt;input type=<font color="#004488">"text"</font> size=<font color="#004488">"20"</font>
      name=<font color="#004488">"Field&lt;%=i%&gt;"</font> value=<font color="#004488">"Value&lt;%=i%&gt;"</font>&gt;&lt;br&gt;
&lt;%  } %&gt;
    &lt;INPUT TYPE=submit name=submit 
    value=<font color="#004488">"Submit"</font>&gt;&lt;/form&gt;
&lt;%} <font color="#0000ff">else</font> { 
    <font color="#0000ff">while</font>(flds.hasMoreElements()) {
      String field = (String)flds.nextElement();
      String value = request.getParameter(field);
%&gt;
      &lt;li&gt;&lt;%= field %&gt; = &lt;%= value %&gt;&lt;/li&gt;
&lt;%  }
  } %&gt;
&lt;/H3&gt;&lt;/body&gt;&lt;/html&gt;
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Наиболее интересная особенность этого примера состоит 
  в том, что он демонстрирует, как код скриплета может быть смешан с HTML кодом, 
  даже в точке генерации HTML с помощью цикла <b>for</b> из Java. Это особенно 
  хорошо для построения всех видов форм, в которых присутствует повторяющийся 
  HTML код.</font></p>
<a name="_Toc481064889"></a><a name="Heading545"></a> 
<h3 align="left"><font face="Verdana"> Атрибуты JSP страницы и границы видимости<a name="AAA"></a></font></h3>
<p><font face="Georgia">Просматривая HTML документацию по сервлетам и JSP, вы 
  найдете возможность получать информацию относительно запущенного сервлета или 
  JSP. Приведенный ниже пример отображает некоторые из возможных данных.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//:! c15:jsp:PageContext.jsp</font>
<font size="+1">&lt;%--Viewing the attributes in the pageContext--%&gt;
&lt;%-- Note that you can include any amount of code
inside the scriptlet tags --%&gt;
&lt;%@ page <font color="#0000ff">import</font>=<font color="#004488">"java.util.*"</font> %&gt;
&lt;html&gt;&lt;body&gt;
Servlet Name: &lt;%= config.getServletName() %&gt;&lt;br&gt;
Servlet container supports servlet version:
&lt;% out.print(application.getMajorVersion() + <font color="#004488">"."</font>
+ application.getMinorVersion()); %&gt;&lt;br&gt;
&lt;%
  session.setAttribute(<font color="#004488">"My dog"</font>, <font color="#004488">"Ralph"</font>);
  <font color="#0000ff">for</font>(<font color="#0000ff">int</font> scope = 1; scope &lt;= 4; scope++) {  %&gt;
    &lt;H3&gt;Scope: &lt;%= scope %&gt; &lt;/H3&gt;
&lt;%  Enumeration e =
      pageContext.getAttributeNamesInScope(scope);
    <font color="#0000ff">while</font>(e.hasMoreElements()) {
      out.println(<font color="#004488">"\t&lt;li&gt;"</font> + 
        e.nextElement() + <font color="#004488">"&lt;</font></font><font color="#004488" size="+1">/li&gt;"</font><font size="+1">);
    }
  }
%&gt;
&lt;/body&gt;&lt;/html&gt;
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Этот пример также показывает использование внедрения в 
  HTML и посылку в <b>out</b> для получения результирующей HTML страницы.</font></p>
<p><font face="Georgia">Первый кусок информации выдает имя сервлета, который, 
  вероятно, будет просто “JSP”, но это зависит от вашей реализации. 
  Вы также можете обнаружить текущую версию контейнера сервлетов, используя объект 
  приложения. Наконец, после установки атрибутов сессии, отображается “attribute 
  names” в определенных пределах видимости. Чаще всего вы не используете 
  границы видимости в JSP программировании. Они просто показаны тут для придания 
  примеру увлекательности Есть четыре границы видимости атрибута. Вот они: <i>пределы 
  страницы</i> (граница 1), <i>пределы запроса</i> (граница 2), <i> пределы сессии</i> 
  (граница — здесь только один элемент доступен в пределах сессии - это 
  “My dog”, добавленный перед цыклом <b>for</b>), и <i> пределы приложения</i> 
  (граница 4), основанные на объекте <b>ServletContext</b>. Существует единственный 
  <b>ServletContext</b> для кадого “Web приложения” в каждой Java 
  Virtual Machine. (“Web приложение” - это набор сервлетов и содержимого 
  страничек, относящихся к определенному подмножеству пространства имен URL сервера, 
  таких как /каталог. Обычно это устанавливается в конфигурационном файле.) В 
  пределах приложения вы видите объекты, которые представляют путь к рабочему 
  директорию и временному директорию.</font></p>
<a name="_Toc481064890"></a><a name="Heading546"></a> 
<h3 align="left"><font face="Verdana"> Управление сессиями в JSP<a name="Index2163"></a></font></h3>
<p><font face="Georgia">Сессии были введены в предыдущем разделе о сервлетах и 
  также доступны в JSP. Следующий пример исследует объект <b>session</b> и позволяет 
  вам управлять промежутком времени после которого сессия становится недействительной.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//:! c15:jsp:SessionObject.jsp</font>
<font size="+1">&lt;%--Getting and setting session object values--%&gt;
&lt;html&gt;&lt;body&gt;
&lt;H1&gt;Session id: &lt;%= session.getId() %&gt;&lt;/H1&gt;
&lt;H3&gt;&lt;li&gt;This session was created at 
&lt;%= session.getCreationTime() %&gt;&lt;/li&gt;&lt;/H1&gt;
&lt;H3&gt;&lt;li&gt;Old MaxInactiveInterval = 
  &lt;%= session.getMaxInactiveInterval() %&gt;&lt;/li&gt;
&lt;% session.setMaxInactiveInterval(5); %&gt;
&lt;li&gt;New MaxInactiveInterval= 
  &lt;%= session.getMaxInactiveInterval() %&gt;&lt;/li&gt;
&lt;/H3&gt;
&lt;H2&gt;If the session object <font color="#004488">"My dog"</font> is 
still around, <font color="#0000ff">this</font> value will be non-<font color="#0000ff">null</font>:&lt;H2&gt;
&lt;H3&gt;&lt;li&gt;Session value <font color="#0000ff">for</font></font> <font color="#004488" size="+1">"My dog"</font><font size="+1"> =  
&lt;%= session.getAttribute(<font color="#004488">"My dog"</font>) %&gt;&lt;/li&gt;&lt;/H3&gt;
&lt;%-- Now add the session object <font color="#004488">"My dog"</font> --%&gt;
&lt;% session.setAttribute(<font color="#004488">"My dog"</font>, 
                    <font color="#0000ff">new</font> String(<font color="#004488">"Ralph"</font>)); %&gt;
&lt;H1&gt;My dog's name is 
&lt;%= session.getAttribute(<font color="#004488">"My dog"</font>) %&gt;&lt;/H1&gt;
&lt;%-- See <font color="#0000ff">if</font></font> <font color="#004488" size="+1">"My dog"</font><font size="+1"> wanders to another form --%&gt;
&lt;FORM TYPE=POST ACTION=SessionObject2.jsp&gt;
&lt;INPUT TYPE=submit name=submit 
Value=<font color="#004488">"Invalidate"</font>&gt;&lt;/FORM&gt;
&lt;FORM TYPE=POST ACTION=SessionObject3.jsp&gt;
&lt;INPUT TYPE=submit name=submit 
Value=<font color="#004488">"Keep Around"</font>&gt;&lt;/FORM&gt;
&lt;/body&gt;&lt;/html&gt;
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Объект <b>session </b>существует по умолчанию, так что 
  он доступен без написания дополнительного кода. Вызовы <b>getID(&nbsp;)</b>, 
  <b>getCreationTime(&nbsp;)</b> и <b>getMaxInactiveInterval(&nbsp;)</b> используются 
  для отображения информации об объекте сессии.</font></p>
<p><font face="Georgia">Когда вы в первый получите эту сессию, вы увидите, что 
  <b>MaxInactiveInterval</b> равен, например, 1800 секунд (30 минут). Это зависит 
  от способа конфигурации вашего контейнера JSP/сервлетов. <b>MaxInactiveInterval</b> 
  сокращается до 5 секунд, чтобы сделать предмет изучения более интересным. Если 
  вы обновите страницу до того, как закончится интервал в 5 секунд, то вы увидите:</font></p>
<blockquote> 
  <pre><font size="+1">Session value <font color="#0000ff">for</font></font> <font color="#004488" size="+1">"My dog"</font><font size="+1"> = Ralph</font></pre>
</blockquote>
<p><font face="Georgia">Но если вы промедлите, “Ralph” станет равен 
  <b>null</b>.</font></p>
<p><font face="Georgia">Чтобы посмотреть как информация о сессии может быть передана 
  на другие страницы, а также посмотреть эффект недействительности объекта сессии, 
  просто дайте ему устареть, будут созданы два других JSP. Первый из них (может 
  быть получен при нажатии кнопки “invalidate” в <b>SessionObject.jsp</b>) 
  читает информацию о сессии, а затем явно делает ее недействительной:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//:! c15:jsp:SessionObject2.jsp</font>
<font size="+1">&lt;%--The session object carries through--%&gt;
&lt;html&gt;&lt;body&gt;
&lt;H1&gt;Session id: &lt;%= session.getId() %&gt;&lt;/H1&gt;
&lt;H1&gt;Session value <font color="#0000ff">for</font></font> <font color="#004488" size="+1">"My dog"</font> 
<font size="+1">&lt;%= session.getValue(<font color="#004488">"My dog"</font>) %&gt;&lt;/H1&gt;
&lt;% session.invalidate(); %&gt;
&lt;/body&gt;&lt;/html&gt;
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Чтобы поэкспериментировать с этим, обновите <b>SessionObject.jsp</b>, 
  затем сразу нажмите на кнопку “invalidate”, чтобы посмотреть <b>SessionObject2.jsp</b>. 
  В этом случае вы все еще увидите “Ralph”, в противом случае (после 
  того, как пройдет 5-ти секундный интервал), обновите <b>SessionObject2.jsp</b>, 
  чтобы увидеть, что сессия действительно стаа недействительной, а “Ralph” 
  исчез.</font></p>
<p><font face="Georgia">Если вы вернетесь к <b>SessionObject.jsp</b>, обновите 
  страничку так, чтобы прошел 5-ти секундный интервал, затем нажмите кнопку “Keep 
  Around”, вы получите следующую страницу, <b>SessionObject3.jsp</b>, которая 
  НЕ делает сессию недействительной:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//:! c15:jsp:SessionObject3.jsp</font>
<font size="+1">&lt;%--The session object carries through--%&gt;
&lt;html&gt;&lt;body&gt;
&lt;H1&gt;Session id: &lt;%= session.getId() %&gt;&lt;/H1&gt;
&lt;H1&gt;Session value <font color="#0000ff">for</font></font> <font color="#004488" size="+1">"My dog"</font> 
<font size="+1">&lt;%= session.getValue(<font color="#004488">"My dog"</font>) %&gt;&lt;/H1&gt;
&lt;FORM TYPE=POST ACTION=SessionObject.jsp&gt;
&lt;INPUT TYPE=submit name=submit Value=<font color="#004488">"Return"</font>&gt;
&lt;/FORM&gt;
&lt;/body&gt;&lt;/html&gt;
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Поскольку эта страница не делает сессию недействительной, 
  “Ralph” будет оставаться до тех пор, пока вы будете выполнять обновления 
  до окончания 5 секундного интервала. Это похоже на “Tomagotchi” 
  — пока вы играете с “Ralph”, он будет там, в противном случае 
  он исчезнет.</font></p>
<a name="_Toc481064891"></a><a name="Heading547"></a> 
<h3 align="left"><font face="Verdana"> Создание и изменение cookies<a name="Index2164"></a></font></h3>
<p><font face="Georgia">Cookies были введены и предыдущем разделе, посвященном 
  сервлетам. Опять таки, краткость JSP делает работу с cookies очень простой, 
  чем при использовании сервлетов. Следующий пример показывает <font color="#0000ff">это</font>, 
  получая cookies, которые приходят с запросом, читают и изменяют их максимальный 
  возраст (дату устаревания) и присоединяют <font color="#0000ff">новый</font> cookie, 
  для помещения в ответ:</font></p>
<blockquote> 
  <pre><font size="+1"><font color="#009900">//:! c15:jsp:Cookies.jsp</font>
&lt;%--This program has different behaviors under
 different browsers! --%&gt;
&lt;html&gt;&lt;body&gt;
&lt;H1&gt;Session id: &lt;%= session.getId() %&gt;&lt;/H1&gt;
&lt;%
Cookie[] cookies = request.getCookies();
<font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; cookies.length; i++) { %&gt;
  Cookie name: &lt;%= cookies[i].getName() %&gt; &lt;br&gt;
  value: &lt;%= cookies[i].getValue() %&gt;&lt;br&gt;
  Old max age in seconds: 
  &lt;%= cookies[i].getMaxAge() %&gt;&lt;br&gt;
  &lt;% cookies[i].setMaxAge(5); %&gt;
  New max age in seconds: 
  &lt;%= cookies[i].getMaxAge() %&gt;&lt;br&gt;
&lt;% } %&gt;
&lt;%! <font color="#0000ff">int</font> count = 0; <font color="#0000ff">int</font> dcount = 0; %&gt;
&lt;% response.addCookie(<font color="#0000ff">new</font> Cookie(
    <font color="#004488">"Bob"</font> + count++, <font color="#004488">"Dog"</font> + dcount++)); %&gt;
&lt;/body&gt;&lt;/html&gt;
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Так как каждый броузер хранит свои cookies по-своемуin, 
  вы можете видеть разное поведение у разных броузеров (не утверждаю точно, то 
  это может быть некоторым ошибкам, которые могут быть уже устранены в от момент, 
  когда вы читаете это). Также вы можете получить различные результаты, если вы 
  закроете броузер и запустите его снова, или посетите другой сайт и вернетесь 
  к <b>Cookies.jsp</b>. Обратите, что использование объекта сессий лучший подход, 
  чем прямое использование cookies.</font></p>
<p><font face="Georgia">После отображения идентификатора сессий, отображается 
  каждый cookie из массива cookies, пришедший с объектом <b>request</b>, наряду 
  с его максимальным возростом. Максимальный возраст меняется и отображается вновь 
  для проверки нового значения, затем новый cookie добавляется в ответ. Однако 
  ваш броузер может игнорировать максимальный возраст, поигравшись с этой программой 
  и изменяя значение возраста можно увидеть поведение различных броузеров.</font></p>
<a name="_Toc481064892"></a><a name="Heading548"></a> 
<h3 align="left"><font face="Verdana"> Резюме о JSP</font></h3>
<p><font face="Georgia">Этот раздел лишь коротко рассказывается о JSP, но даже 
  с тем, что рассказано здесь (вместе с теми знаниями, которые вы получили о Java 
  в оставшейся части книги, совместо с тем, что вы сами знаете об HTML) вы можете 
  начать писать достаточно сложные Web страницы с помощью JSP. Синтаксис JSP специально 
  не спрятан глубоко и не сложен, так что если вы поняли что показано в этом разделе, 
  вы готовы к продуктивной работе с JSP. Вы можете найти более новую информацию 
  во вновь вышеших книгах по сервлетам или на <i>java.sun.com</i>.</font></p>
<p><font face="Georgia">Особенно хорошо иметь поддержку JSP даже если вашей целью 
  является разработка сервлетов. Вы обнаружите, что если у вас есть вопросы о 
  поведении сервлета в будующем, то легко и просто написать тестовую JSP программу, 
  отвечающую на этот вопрос. Часть выгоды состоит в том, что нужно писать меньше 
  кода и можно смешивать отображаемый HTML код с Java кодом, но рычаги управления 
  становятся особенно очевидными, когда JSP контейнер обрабатывает всю перекомпиляцию 
  и перезагрузку JSP вместо вас, когда бы вы не изменили исходный код.</font></p>
<p><font face="Georgia">Недостаток JSP в том, что для создания JSP требуется более 
  высокий уровень умения, чем уровень простого Java программиста или простого 
  Web мастера. Кроме того, отладка JSP страниц с ошибками не так легка, как отладка 
  Java программ, так как (в настоящее время) сообщения об ошибках слишком невразумительны. 
  Это должно измениться при улучшении среды разработки, но мы можем также найти 
  другую технологию, надстроеную над Java и Web, которая будет лучше адаптирована 
  в знаниям дизайнера Web сайтов.</font></p>
<a name="_Toc481064893"></a><a name="Heading549"></a> 
<h2 align="left"><font face="Verdana"> RMI (Удаленный вызов методов)</font></h2>
<p><font face="Georgia">Традиционный подход к выполнению кода на любой машине 
  по сети сбивал с толку , а так же был утомителен и подвержен ошибкам при реализации. 
  Лучший способ представить эту проблемму - это думать, что какой-то объект живет 
  на другой машине и что вы можете посылать сообщения удаленному объекту и получать 
  результат, будто бы этот объект живет на вашей машине. Говоря простым языком, 
  это в точности то, что позволяет делать <a name="Index2165"></a><a name="Index2166"></a><i> 
  Удаленный вызов методов (Remote Method Invocation</i> (RMI) в Java. Этот раздел 
  показывает шаги, необходимые для создания ваших собственных RMI.</font></p>
<a name="_Toc481064894"></a><a name="Heading550"></a> 
<h3 align="left"><font face="Verdana"> Удаленный интерфейс</font></h3>
<p><font face="Georgia">RMI делает тыжелым использование интерфейсов. Когда вы 
  хотите создать удаленный объект, вы помечаете, что лежащую в основе раелизацию 
  нужно передавать через интерфейс. Таким образом, когда клиент получает ссылку 
  на удаленный объект, на самом деле он получаете ссылку на интерфейс, который 
  <i>выполняет</i> соединение с определенныму местом кода,общающимся по сети. 
  Но вы не заботитесь об этом, вы просто посылаете сообщения через ссылку на интерфейс.</font></p>
<p><font face="Georgia">Когда вы создаете <a name="Index2167"></a>удаленный интерфейс, 
  вы должны следовать следующей иснтрукции:</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Удаленный интерфейс должен 
    быь публичным - <b>public</b> (он не может иметь “доступ на уровне пакета”, 
    так же он не может быть “дружественным”). В противном случае клиенты 
    будут получать ошибку при попытке загрузки объекта, реализующего удаленный 
    интерфейс.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Удаленный интерфейс должен 
    расширять интерфейс</font><font face="Georgia"> <a name="Index2168"></a><b>java.rmi.Remote</b>.</font> 
  </li><li>Каждый метод удаленного интерфейса должен объявлять <font face="Georgia"><a name="Index2169"></a><b>java.rmi.RemoteException</b> 
    в своем предложении <b>throws</b> в добавок к любым исключениям, специфичным 
    для приложения.</font> 
  </li><li><font face="Georgia">Удаленный объект, передаваемый как аргумент или возвращаемое 
    значение (либо напрямую, либо как к части локального объекта), должен быть 
    объявлен как удаленный интерфейс, а не реализация класса.</font> 
</li></ol>
<p><font face="Georgia">Ниже приведен простой удаленный интерфейс, представляющий 
  сервис точного времени:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:rmi:PerfectTimeI.java</font>
<font color="#009900" size="+1">// Удаленный интерфейс PerfectTime.</font>
<font color="#0000ff" size="+1">package</font><font size="+1"> c15.rmi;
<font color="#0000ff">import</font> java.rmi.*;

<font color="#0000ff">interface</font> PerfectTimeI <font color="#0000ff">extends</font> Remote {
  <font color="#0000ff">long</font> getPerfectTime() <font color="#0000ff">throws</font> RemoteException;
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Он выглядит как любой другой интерфейс, за исключением 
  того, что расширяет <b>Remote</b> и все его методы выбрасывают <b>RemoteException</b>. 
  Помните, что <b>interface</b> и все его методы автоматически становятся <b>public</b>.</font></p>
<a name="_Toc481064895"></a><a name="Heading551"></a> 
<h3 align="left"><font face="Verdana"> Реализация удаленного интерфейса</font></h3>
<p><font face="Georgia">Сервер должен содержать класс, который расширяет <a name="Index2170"></a><a name="Index2171"></a><b>UnicastRemoteObject</b> 
  и реализует удаленный интерфейс. Этот класс также может иметь другие методы, 
  но для клиента доступны только методы удаленного интерфейса, так как клиент 
  получает тоько ссылку на интерфейс, а не на класс, который его реализует.</font></p>
<p><font face="Georgia">Вы должны явно определить конструктор для удаленого объекта, 
  даже если вы определяете только конструктор по умолчанию, который вызывает конструктор 
  базового класса. Вы должны написать его, так как он должен выбрасывать <b>RemoteException</b>.</font></p>
<div align="left"> 
  <p><font face="Georgia">Ниже приведена реализация удаленного интерфейса <b>PerfectTimeI</b>:</font></p>
</div>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:rmi:PerfectTime.java</font>
<font color="#009900" size="+1">// Реализация удаленного объекта </font><font color="#009900" size="+1">PerfectTime.</font>
<font color="#0000ff" size="+1">package</font><font size="+1"> c15.rmi;
<font color="#0000ff">import</font> java.rmi.*;
<font color="#0000ff">import</font> java.rmi.server.*;
<font color="#0000ff">import</font> java.rmi.registry.*;
<font color="#0000ff">import</font> java.net.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> PerfectTime 
    <font color="#0000ff">extends</font> UnicastRemoteObject
    <font color="#0000ff">implements</font> PerfectTimeI {
  <font color="#009900">// Реализация интерфейса:</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">long</font><font size="+1"> getPerfectTime() 
      <font color="#0000ff">throws</font> RemoteException {
    <font color="#0000ff">return</font> System.currentTimeMillis();
  }
  <font color="#009900">// Должна быть реализация конструктора</font></font>
  <font color="#009900" size="+1">// для выбрасывания RemoteException:</font>
  <font color="#0000ff" size="+1">public</font><font size="+1"> PerfectTime() <font color="#0000ff">throws</font> RemoteException {
    <font color="#009900">// super(); // Вызывается автоматически</font>
  }
  <font color="#009900">// Регистрация для обслуживания RMI. Выбрасывает</font></font>
  <font color="#009900" size="+1">// исключения на консоль.</font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) 
  <font color="#0000ff">throws</font> Exception {
    System.setSecurityManager(
    <font color="#0000ff">new</font> RMISecurityManager());
    PerfectTime pt = <font color="#0000ff">new</font> PerfectTime();
    Naming.bind(
      <font color="#004488">"</font></font><font color="#004488" size="+1">//peppy:2005/PerfectTime"</font><font size="+1">, pt);
    System.out.println(<font color="#004488">"Ready to do time"</font>);
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">В этом примере <b>main(&nbsp;)</b> обрабатывает все детали 
  установки сервера. Когда вы обслуживаете RMI объект, в определенном месте вашей 
  программы вы должны:</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Создать и установит менеджер 
    безопасности, поддерживающий RMI. Как часть Java пакета, для RMI поддерживается 
    только </font><font face="Georgia"><b>RMISecurityManager</b>.</font> 
  </li><li> <font face="Verdana"> </font><font face="Georgia">Создать один или несколько 
    экземпляров удаленного объекта. Здесь вы видите создание объекта <b>PerfectTime</b>.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Зарегистрировать не менее 
    одного удаленного объекта </font> с помощью <font face="Georgia">RMI <a name="Index2174"></a><a name="Index2175"></a>удаленной 
    регистрации объекта с целью загрузки Один удаленный объект может иметь методы, 
    которые производят ссылки на другой удаленный объект. Это позволяет вам настроить 
    так, чтобы клиент проходил регистрацию только один раз, при получении первого 
    удаленного объекта.</font> 
</li></ol>
<a name="Heading552"></a> 
<h4 align="left"><font face="Verdana"> Регистрация</font></h4>
<p><font face="Georgia">В этом примере вы видите вызов статического метода <a name="Index2176"></a><a name="Index2177"></a><a name="Index2178"></a><b>Naming.bind(&nbsp;)</b>. 
  Однако этот вызов требует, чтобы регистрация была запущена отделным процессом 
  на вашем компьютере. Имя сервера регистрации - это <a name="Index2179"></a><a name="Index2180"></a><b>rmiregistry</b>, 
  и под 32-битной Windows вы говорите:</font></p>
<blockquote> 
  <pre><font size="+1">start rmiregistry</font></pre>
</blockquote>
<p><font face="Georgia">для запуска в фоновом режиме. Под Unix эта команда выглядит:</font></p>
<blockquote> 
  <pre><font size="+1">rmiregistry &amp;</font></pre>
</blockquote>
<p><font face="Georgia">Как и многие другие сетевые программы, <b>rmiregistry</b> 
  обращается по IP адресу машины, на которой она установлена, но она также слушает 
  порт. Если вы вызовите <b>rmiregistry</b> как показано выше, без аргументов, 
  будет использован порт по умолчанию 1099. Если вы хотите использовать другой 
  порт, вы добавляете аргумент в командную строку, указывающий порт. Следующий 
  пример устанавливает порт 2005, так что <b>rmiregistry</b> под управлением 32-битной 
  Windows должна запускаться так:</font></p>
<blockquote> 
  <pre><font size="+1">start rmiregistry 2005</font></pre>
</blockquote>
<p><font face="Georgia">а подUnix:</font></p>
<blockquote> 
  <pre><font size="+1">rmiregistry 2005 &amp;</font></pre>
</blockquote>
<p><font face="Georgia">Информаци о порте также должна передаваться в команде 
  <b>bind(&nbsp;)</b>, наряду с IP адресом машины, где располагается регистрация. 
  Но это может выявить огорчительную проблему, если вы хотите проверять RMI программы 
  локально, как проверялись все программы до этой главы. В выпуске JDK 1.1.1, 
  есть целая связка проблем:</font><a name="fnB76" href="#fn76">[76]</a></p>
<ol>
  <li><font face="Verdana"><a name="Index2181"></a><a name="Index2182"></a></font><font face="Georgia"><b>localhost 
    </b>не работает с RMI. Поэтому для экспериментов с RMI на одной машине вы 
    должны использовать имя машины. Чтобы найти имя вашей машины под управлением 
    32-битной Windows, перейдите в панель управления и выберите “Network”. 
    Выберите закладку “Identification”, и посмотрите имя вашего компьютера. 
    В моем случае я назвал свой компьютер “Peppy”. Регистр в имени 
    игнорируется.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">RMI не работает, пока 
    ваш компьютер имеет активные <a name="Index2183"></a><a name="Index2184"></a>TCP/IP 
    соединения, даже если все ваши компоненты просто общаются друг с другом на 
    локальной машине. Это значит, что вы должны соединятся с вашим провайдером 
    Internet до того, как попробуете запустить программу или будете огорчены неким 
    сообщением об ошибке.</font> 
</li></ol>
<p><font face="Georgia">Если учесть все это, команда <b>bind(&nbsp;)</b> принимает 
  вид:</font></p>
<blockquote> 
  <pre><font size="+1">Naming.bind(<font color="#004488">"</font></font><font color="#004488" size="+1">//peppy:2005/PerfectTime"</font><font size="+1">, pt);</font></pre>
</blockquote>
<p><font face="Georgia">Если вы используете порт по умолчанию 1099, вам не нужно 
  указывать порт, так что вы можете просто сказать:</font></p>
<blockquote> 
  <pre><font size="+1">Naming.bind(<font color="#004488">"</font></font><font color="#004488" size="+1">//peppy/PerfectTime"</font><font size="+1">, pt);</font></pre>
</blockquote>
<p><font face="Georgia">Вы можете выполнить локальную проверку оставив в покое 
  IP адрес, а использовать только идентификатор:</font></p>
<blockquote> 
  <pre><font size="+1">Naming.bind(<font color="#004488">"PerfectTime"</font>, pt);</font></pre>
</blockquote>
<p><font face="Georgia">Имя сервиса здесь произвольно. В данном случае PerfectTime 
  выбрано просто как имя класса, но вы можете назвать так, как захоите. Важно, 
  чтобы это было уникальное имя регистрации, чтобы клиент знал, когда будет искать 
  что производит удаленные объекты. Если имя уже зарегистрировано, вы получите 
  <a name="Index2185"></a><a name="Index2186"></a><b>AlreadyBoundException</b>. 
  Чтобы предотвратить это, вы всегда можете использовать <a name="Index2187"></a><a name="Index2188"></a><a name="Index2189"></a><b>rebind(&nbsp;)</b> 
  вместо <b>bind(&nbsp;)</b>, так как <b>rebind(&nbsp;)</b> либо добавляет новый 
  элемент, либо заменяет уже существующий.</font></p>
<p><font face="Georgia">Даже после завершения работы <b>main(&nbsp;)</b>, ваш 
  объект будет оставаться созданным и зарегистрированным, ожидая, что прийдет 
  клиент и выполнит запрос. Пока <b>rmiregistry</b> остается запущенным, и вы 
  не вызовите <b>Naming.unbind(&nbsp;)</b> <a name="Index2190"></a><a name="Index2191"></a><a name="Index2192"></a>на 
  вашей машине, объект будет оставаться там. По этой причине, когда вы разрабатываете 
  ваш код, вам необходимо выгружать <b>rmiregistry</b> и перезапускать его, когда 
  скомпилируете новую версию вашего удаленного объекта.</font></p>
<p><font face="Georgia">Вам не обязательно запускать <b>rmiregistry</b> как внешний 
  процесс. Если вы знаете, что только ваше приложение использует регистрацию, 
  вы можете загрузить ее внутри вашей программы с помощью строки:</font></p>
<blockquote> 
  <pre><font size="+1">LocateRegistry.createRegistry(2005);</font></pre>
</blockquote>
<p><font face="Georgia">Как и раньше, 2005 - это номер порта, который мы использовали 
  в этом примере. Это эквивалентно запуску <b>rmiregistry 2005</b> из командной 
  строки, но часто этот способ является более подходящим при разработке RMI кода, 
  так как это снжает число необходимых действий при запуске и остановке регистрации 
  После того, как вы выполните этот код, вы можете вызвать <b>bind(&nbsp;)</b>, 
  используя <b>Naming</b>, как и ранее.</font></p>
<a name="_Toc481064896"></a><a name="Heading553"></a> 
<h3 align="left"><font face="Verdana"> Создание якорей и скелетов</font></h3>
<p><font face="Georgia">Если вы откомпилировали и запустили <b>PerfectTime.java</b>, 
  оно не будет работать, даже если вы правильно запустили <b>rmiregistry</b>. 
  Это происходит потому, что рабочее пространство для RMI еще не создано. Вы должны 
  сначала создать <a name="Index2193"></a><a name="Index2194"></a>якоря и <a name="Index2195"></a><a name="Index2196"></a>скелеты, 
  которые обеспечат работу сетевого соединения и позволит вам делать вид, что 
  удаленный - это просто докальный объект на вашей машине.</font></p>
<p><font face="Georgia">То, что происходит за сценой - очень сложно. Любой объект, 
  который вы передаете или получаете из удаленого объекта должен реализовывать(<b>implement</b>)<b> 
  <a name="Index2197"></a><a name="Index2198"></a>Serializable</b> (если вы хотите 
  передавать удаленные ссылки вместо целых объектов, аргументы объектов могут 
  реализовывать (<b>implement</b>)<b> Remote</b>), так что вы можете представить, 
  что якоря и скелеты автоматически выполняют сериализацию и десериализацию, а 
  так же “передают по очереди” все аргументы по сети и возвращают 
  результат. К счастью, вам не нужно знать всего этого, но вы <i>должны </i>делать 
  якоря и скелеты. Это простой процесс: вы вызываете инструмент <a name="Index2199"></a><a name="Index2200"></a><b>rmic</b> 
  для вашего откомпилированного кода, а он создает необходимые файлы. Так что 
  от вас требуется включить еще один шаг в процесс компиляции.</font></p>
<p><font face="Georgia">Однако инструмент <b>rmic</b> спецефичен относительно 
  packages <a name="Index2201"></a><a name="Index2202"></a>classpath. <b>PerfectTime.java</b> 
  находится в пакете <b>c15.rmi</b>, и даже если вы вызовите <b>rmic</b> в том 
  же самом директори, в котором находится <b>PerfectTime.class</b>, <b>rmic</b> 
  не найдет файл, так как он ищет classpath. Так что вы должны указать путь к 
  классу примерно так:</font></p>
<blockquote> 
  <pre><font size="+1">rmic c15.rmi.PerfectTime</font></pre>
</blockquote>
<p><font face="Georgia">Вам не нужно быть в директории, содержащим <b>PerfectTime.class</b>, 
  когда вы исполняете эту команду, но результат будет помещен в текущий директоий.</font></p>
<p><font face="Georgia">Если запус <b>rmic</b> завершится успешно, вы найдете 
  два новых класса в дректории:</font></p>
<blockquote> 
  <pre><font size="+1">PerfectTime_Stub.<font color="#0000ff">class</font>
PerfectTime_Skel.<font color="#0000ff">class</font></font></pre>
</blockquote>
<p><font face="Georgia">соответствующих якорю и скелету. Теперь вы готовы запустить 
  общение клиента с сервером.</font></p>
<a name="_Toc481064897"></a><a name="Heading554"></a> 
<h3 align="left"><font face="Verdana"> Использование удаленных объектов</font></h3>
<p><font face="Georgia">Главная цель RMI состоит в упращении использования удаленных 
  объектов. Вы должны сделать только самую важную вещь в вашей клиентской программе: 
  это поиск и получение удаленного интерфейса с сервера. Во всем остальном - это 
  обычное программирование на Java: посылка сообщений объекту. Ниже приведена 
  программа, использующая <b>PerfectTime</b>:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:rmi:DisplayPerfectTime.java</font>
<font color="#009900" size="+1">// Испольование удаленного объекта PerfectTime.</font>
<font color="#0000ff" size="+1">package</font><font size="+1"> c15.rmi;
<font color="#0000ff">import</font> java.rmi.*;
<font color="#0000ff">import</font> java.rmi.registry.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> DisplayPerfectTime {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) 
  <font color="#0000ff">throws</font> Exception {
    System.setSecurityManager(
      <font color="#0000ff">new</font> RMISecurityManager());
    PerfectTimeI t = 
      (PerfectTimeI)Naming.lookup(
        <font color="#004488">"</font></font><font color="#004488" size="+1">//peppy:2005/PerfectTime"</font><font size="+1">);
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i++)
      System.out.println(<font color="#004488">"Perfect time = "</font> +
        t.getPerfectTime());
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Строка идентификатора такая же, как и та, что использовалась 
  при регистрации объекта с помощью <b>Naming</b>, а первая часть представляет 
  URL и номер порта. Так как вы используете URL, вы можете также указать машину 
  в Internet.</font></p>
<p><font face="Georgia">То, что возвращается из <b>Naming.lookup(&nbsp;)</b> должно 
  быть преобразовано к удаленному интерфейсу, а <i>не</i> к классу. Если вы будите 
  использовать класс, вы получите исключение.</font></p>
<p><font face="Georgia">Вы виите вызов метода</font></p>
<blockquote> 
  <pre><font size="+1">t.getPerfectTime()</font></pre>
</blockquote>
<p><font face="Georgia">так как вы имеете ссылку на удаленный объект, то с точки 
  зрения программирования, это не отличается от работы с локальным объектом (с 
  одним отличием: удаленные методы выбрасывают <a name="Index2203"></a><a name="Index2204"></a><b>RemoteException</b>).</font></p>
<a name="_Toc375545499"></a><a name="_Toc481064898"></a><a name="Heading555"></a> 
<h2 align="left"><font face="Verdana"> CORBA<a name="Index2205"></a></font></h2>
<p><font face="Georgia">В огромных распределенных приложениях вы можете быть неудовлетворены 
  изложенными выше подходами. Например, вам может понадобиться интерфейс с унаследованным 
  хранилищем данных, или вам может понадобиться услуга от сервера объектов не 
  зависимо от его физического расположения. Такие ситуации требуют некоторого 
  рода Процедуры Удаленного Вызова (RPC), и, возможно, независимости от языка. 
  Здесь может помочь CORBA.</font></p>
<p><font face="Georgia">CORBA - это не особенность языка, это технология интеграции. 
  Это спецификация, которой могут следовать производители для реализации CORBA-совместимых 
  интегрированных продуктов. CORBA - это одна из попыток OMG определить рабочее 
  пространство для распределенных, независящих от языка способностей объекта.</font></p>
<p><font face="Georgia">CORBA предлагает возможность создания процедуры удаленного 
  вызова Java объектов и не Java объектов для взаимодействия с системой наследования 
  независящим от расположения способом. Java добавляет поддержку сети и великолепный 
  объектно-оиентированный язык для построения графических и не графических приложений. 
  Модельные карты объектов Java и <a name="Index2206"></a>OMG дополняют друг друга, 
  например, и Java, и CORBA реализуют концепцию интерфейсов и модель ссылок на 
  объекты.</font></p>
<a name="_Toc481064899"></a><a name="Heading556"></a> 
<h3 align="left"><font face="Verdana"> Принципы CORBA</font></h3>
<p><font face="Georgia">Спецификация взаимодействия объектов, разработанная OMG, 
  часто называется, как Object Management Architecture (OMA). OMA определяет два 
  компонента: Модель Ядра Объекта (Core Object Model) и Архитектура Ссылок OMA 
  (OMA Reference Architecture). Модель Ядра Объекта устанавливает основную концепцию 
  объекта, интерфейса, операции и т.п. (CORBA является улучшением Core Object 
  Model.) Архитектура Ссылок OMA определяет лежащую в основе ифраструктуру сервисов 
  и механизма, который позволяет объектам взаиможействовать. Архитектура Ссылок 
  OMA включает Object Request Broker (ORB), Object Services (также известный, 
  как CORBA сервис), и общие средства обслуживания.</font></p>
<p><font face="Georgia"> ORB - это шина взаимодействия, с помошью которой объекты 
  могут выполнять запросы на обслуживания к другим объектам, не зависимо от их 
  физического положения. Это значит, что то, что выглядит как вызов метода в коде 
  клиента на самом деле является сложной операцией. Во-первых, должно существовать 
  соединение с объектом сервера, адля создания соединения ORB должен знать где 
  располагается код реализации сервера. После установления соединения должны передаться 
  по порядку аргументы метода, т.е. конвертироваться в бинарный поток и послаться 
  по сети. Другая информация, которая должна быть послана серверу - это имя машины, 
  процесс сервера и идентификатор серверного объекта внутри процесса. И наконец, 
  эта информация посылается с использованием протокола нижнего уровня, информация 
  декодируется на стороне сервера и выполняется вызов процедуры. ORB прячет всю 
  эту сложность от программиста и делает работу почти такой же простой, как и 
  вызов метода локального объекта.</font></p>
<p><font face="Georgia">Нет спецификации о том, как должно реализовываться ядро 
  ORB, но для обеспечения совместимости с различными производителями ORB, OMG 
  определяет набор сервисов, которые доступны через стандартные интерфейсы.</font></p>
<a name="Heading557"></a> 
<h4 align="left"><font face="Verdana"> Язык Определения Интерфейсов CORBA(CORBA 
  Interface Definition Language) - IDL<a name="Index2207"></a><a name="Index2208"></a></font></h4>
<p><font face="Georgia">CORBA предназначена для независимости от языков: объект 
  клиента может вызывать методы серверного объекта различных классов, не зависимо 
  от языка реализации этих объектов. Конечно, клиентский объект должен знать имена 
  и сигнатуру методов, прадоставляемых серверным объеком. Для этого сделан IDL. 
  CORBA IDL - это не зависимый от языков способ указания типов данных, атрибутов, 
  операций, интерфейсов и многого другого. Синтаксис IDL схож с синтаксисом C++ 
  или Java. Следующая таблица показывает соответствия между некоторыми общими 
  концепциями этих трех языков, которые можно указать в CORBA IDL:</font></p>
<div align="center"> 
  <table border="1">
    <tbody><tr valign="top"> 
      <td> 
        <p><font face="Georgia"><b>CORBA IDL</b></font> </p>
      </td>
      <td> 
        <p align="center"><font face="Georgia"><b>Java</b></font></p>
      </td>
      <td> 
        <p align="center"><font face="Georgia"><b>C++</b></font></p>
      </td>
    </tr>
    <tr valign="top"> 
      <td> 
        <p><font face="Georgia">Module</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Package</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Namespace</font></p>
      </td>
    </tr>
    <tr valign="top"> 
      <td> 
        <p><font face="Georgia">Interface</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Interface</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Pure abstract class</font></p>
      </td>
    </tr>
    <tr valign="top"> 
      <td> 
        <p><font face="Georgia">Method</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Method</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Member function</font></p>
      </td>
    </tr>
  </tbody></table>
</div>
<p align="center"></p>
<p><font face="Georgia">Концепция наследования поддерживается так же, как испоьзование 
  оператора двоеточие в C++. Прогаммист создает IDL описание атрибутов, методов 
  и интерфейсов, которые реализуются и используются сервером и клиентом. Затем 
  IDL компилируется предоставляемым производителем IDL/Java компилятором, читающим 
  исходный IDL код и генерирующим Java код.</font></p>
<p><font face="Georgia">IDL компилятор очень полезный инструмент: он не просто 
  генерирует Java код, эквивалентный IDL, он также генерирует код, который будет 
  использоваться при передаче аргументов методов и при произведении удаленных 
  вызовов. Эот код, называемый кодом якорей и скелетов, разбит на несколько файлов 
  Java программы, и обычно является частью одного Java пакета.</font></p>
<a name="Heading558"></a> 
<h4 align="left"><font face="Verdana"> Служба Указания Имен</font></h4>
<p><font face="Georgia">Служба указания имен является одной из фундаментальных 
  служб CORBA. Объекты CORBA ассоциируются по ссылке, эта часть информации ничего 
  не значит для человека. Но ссылкам можно назначать определенные программой строковые 
  имена. Эта операция известа как <i>именование ссылок</i> (<i>stringifying the 
  reference</i>) и один из OMA компонент, Служба Указания Имен (Naming Service), 
  предназначена для выполнения преобразования строки в объект и объекта в строку. 
  Так как Служба Указания Имен действует как телефонная книга, в которой и клиент 
  и сервер могут получит консултацию, она работает как отдельный процесс. Создание 
  преобразования объекта в строку называется <i>привязыванием объекта</i> (<i>binding 
  an object</i>), а удаления преобразования называется отвязыванием (<i>unbinding</i>). 
  Получение ссылки на объект по переданной строке называется <i>разрешением имени</i> 
  (<i>resolving the name</i>).</font></p>
<p><font face="Georgia">Например, при запуске сервер приложений должен создать 
  серверный объект, связать объект с именем сервиса, а затем подождать пока клиент 
  выполнит запрос. Клиент сначала получает ссылку на серверный объект, разрешает 
  строковое имя, а затем может выполнить обращение к серверу, используя ссылку.</font></p>
<p><font face="Georgia">Спецификация Сервиса Указания Имен является частью CORBA, 
  но приложения, которые реализуют его обеспечиваются производителем ORB. Способ 
  получения доступа к Сервису Указания Имен функционально может различаться в 
  зависимости от производителя.</font></p>
<a name="_Toc481064900"></a><a name="Heading559"></a> 
<h3 align="left"><font face="Verdana"> Пример</font></h3>
<p><font face="Georgia">Приведенные здесь код не продуман до конца, потому что 
  различные ORB имеют различные способы доступа к сервису CORBA, так что примеры 
  специфичны для производителя. (Приводимые ниже примеры используют JavaIDL - 
  это бесплатный продукт от Sun, поставляемый с облегченной версией ORB, службой 
  укaхзания имен и компилятором IDL-to-Java.) Кроме того, так как Java еще очень 
  молод и продолжает развиваться, не все особенности CORBA представлены в различных 
  Java/CORBA продуктах.</font></p>
<p><font face="Georgia">Мы хотим реализовать сервер, работающий на той же машине, 
  у которого можно опросить точное время. Мы так же хотим реализовать клиента, 
  опрашивающего точное время. В этом случае мы будем реализовывать обе программы 
  на Java, но мы также можем использовать два разных языка (что чаще всего случается 
  в реальных ситуациях).</font></p>
<a name="Heading560"></a> 
<h4 align="left"><font face="Verdana"> Написание исходного кода IDL</font></h4>
<p><font face="Georgia">Первый шаг состоит в написании IDL описания разрабатываемого 
  сервиса. Это обычно делает программист сервера, который после этого свободен 
  реализовывать сервер на любом языке, для которго существует CORBA IDL компилятор. 
  IDL файл передается программисту клиентской стороны и становится мостом между 
  языками.</font></p>
<p><font face="Georgia">Приведенный ниже пример показывает IDL описание для нашего 
  сервера <b>ExactTime</b>:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:corba:ExactTime.idl</font>
<font color="#009900" size="+1">//# Вы должны установить idltojava.exe с</font>
<font color="#009900" size="+1">//# java.sun.com и отрегулировать установки для</font>
<font color="#009900" size="+1">//# использования вашего локального C препроцессора</font>
<font color="#009900" size="+1">//# чтобы откомпилировать этот.
//# Смотрите докуметацию на java.sun.com.</font><font size="+1">
module remotetime {
   <font color="#0000ff">interface</font> ExactTime {
      string getTime();
   };
}; <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Это декларация интерфейса <b>ExactTime</b> внутри просранства 
  имен <b>remotetime</b>. Интерфейс состоит из единственного метода, который возвращает 
  текущее время в формате <b>string</b>.</font></p>
<a name="Heading561"></a> 
<h4 align="left"><font face="Verdana"> Создание якорей и скелетов</font></h4>
<p><font face="Georgia">Второй шаг состоит в компиляции IDL для создания кода 
  якорей и скелетов Java, который будет использоваться для реализации клиента 
  и сервера. Инструмент, поставляемый с JavaIDL нащывается <a name="Index2209"></a><b>idltojava</b>:</font></p>
<blockquote> 
  <pre><font size="+1">idltojava remotetime.idl</font></pre>
</blockquote>
<p><font face="Georgia">Это автоматически сгенерирует код и для якорей и для скелетов. 
  <b>Idltojava</b> сгенерирует Java <b>package</b> с названием IDL модуля: <b>remotetime</b>, 
  и сгенерирует Java файлы, поместив их в поддиректорий <b>remotetime</b>. <b>_ExactTimeImplBase.java 
  </b>- это скелет, который мы будем использовать для реализации объекта сервера, 
  а <b>_ExactTimeStub.java</b> будет использован для клиента. Существует Java 
  представление IDL интерфейса в <b>ExactTime.java</b> и набор других файлов поддержки, 
  например, для облегчения доступа к операции сервиса указания имен.</font></p>
<a name="Heading562"></a> 
<h4 align="left"><font face="Verdana"> Реализация сервера и клиента</font></h4>
<p><font face="Georgia">Ниже вы можете видеть код серверной стороны. Реализация 
  серверного объекта выполнена в классе <b>ExactTimeServer</b>. <b>RemoteTimeServer</b> 
  является приложением, которое создает объект сервера, регистрирует его с помошью 
  ORB, дает имя ссылке на объект, а затем мирно ожидает клиентского запроса.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:corba:RemoteTimeServer.java</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> remotetime.*;
<font color="#0000ff">import</font> org.omg.CosNaming.*;
<font color="#0000ff">import</font> org.omg.CosNaming.NamingContextPackage.*;
<font color="#0000ff">import</font> org.omg.CORBA.*;
<font color="#0000ff">import</font> java.util.*;
<font color="#0000ff">import</font> java.text.*;

<font color="#009900">// Реализация серверного объекта</font></font>
<font color="#0000ff" size="+1">class</font><font size="+1"> ExactTimeServer <font color="#0000ff">extends</font> _ExactTimeImplBase {
  <font color="#0000ff">public</font> String getTime(){
    <font color="#0000ff">return</font> DateFormat.
        getTimeInstance(DateFormat.FULL).
          format(<font color="#0000ff">new</font> Date(
              System.currentTimeMillis()));
  }
}

<font color="#009900">// Реализация удаленного приложения</font></font>
<font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">class</font><font size="+1"> RemoteTimeServer {
  <font color="#009900">// Выброс исключений на консоль</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) 
  <font color="#0000ff">throws</font> Exception {
    <font color="#009900">// Создание и реализация ORB:</font>
    ORB orb = ORB.init(args, <font color="#0000ff">null</font>);
    <font color="#009900">// Создание серверного объекта и регистрция:</font>
    ExactTimeServer timeServerObjRef = 
      <font color="#0000ff">new</font> ExactTimeServer();
    orb.connect(timeServerObjRef);
    <font color="#009900">// Получение корневого контекста имен:</font>
    org.omg.CORBA.Object objRef = 
      orb.resolve_initial_references(
        <font color="#004488">"NameService"</font>);
    NamingContext ncRef = 
      NamingContextHelper.narrow(objRef);
    <font color="#009900">// Присвоение строкового имени</font></font>
    <font color="#009900" size="+1">// для ссылки на объект (связывание):</font><font size="+1">
    NameComponent nc = 
      <font color="#0000ff">new</font> NameComponent(<font color="#004488">"ExactTime"</font>, <font color="#004488">""</font>);
    NameComponent[] path = { nc };
    ncRef.rebind(path, timeServerObjRef);
    <font color="#009900">// Ожидание запроса клиента:</font>
    java.lang.Object sync =
      <font color="#0000ff">new</font> java.lang.Object();
    <font color="#0000ff">synchronized</font>(sync){
      sync.wait();
    }
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Как вы можете видеть, реализация серверного объекта достаточно 
  проста. Это обычный Java класс, унаследованный от кода скелета, сгенерированного 
  IDL компилятором. Вещи становятся много сложнее, когда происходит взаимодействие 
  с ORB и другими службами CORBA.</font></p>
<a name="Heading563"></a> 
<h4 align="left"><font face="Verdana"> Некоторые службы CORBA</font></h4>
<p><font face="Georgia">Это короткое описание того, что делает JavaIDL код (в 
  основном игнорируется часть CORBA кода, зависящая от производителя). Первая 
  строка <b>main(&nbsp;)</b> запускает ORB, это необходимо потому, что нашему 
  серверу необходимо взаимодействовать с ним. Сразу после инициализации ORB создается 
  серверный объект. На самом деле правильнее называть временный обслуживающий 
  объект (transient servant object): объект, который принимает запросы от клиентов, 
  и чье время жизни равно совпадает с временем жизни породившего процесса. Как 
  только временный бслуживающий объект создан, он регистрируется с помошь ORB, 
  что означает, что ORB знает о его наличи и теперь может перенаправлять к нему 
  запросы.</font></p>
<p><font face="Georgia">До этого момента все, что мы имели - это <b>timeServerObjRef</b> 
  - указатель на объект, который известен только внутри текущего серверного процесса. 
  Следующий шаг состоит в присвоении строкового имени эому обслуживающему объекту. 
  Клиент будет использовать имя для нахождения обслуживающего объекта. Мы совершили 
  эту операцию, используя Сервис Указания Имен. Во-первых, нам необходима ссылка 
  на Службу Указания Имен. Метод <b>resolve_initial_references(&nbsp;)</b> принимает 
  значимую ссылку на объект Службы Указания Имен, в случае JavaIDL “NameService”, 
  и возвращает ссылку на объект. Он приводит сылку к специфичному типу <b>NamingContext</b>, 
  используя метод <b>narrow(&nbsp;)</b>. Теперь мы можем использовать службу указания 
  имен.</font></p>
<p><font face="Georgia">Для связывания обслуживающих объектов со ссылками на строковые 
  объекты, мы сначала создаем объект <b>NameComponent</b>, инициализирует его 
  значением “ExactTime” - строка имени, которую мы хотим связать с 
  обслуживающим объектом. Затем, используя метод <b>rebind(&nbsp;)</b>, строковая 
  ссылка связывается со ссылкой на объект. Мы испоьзуем <b>rebind(&nbsp;)</b> 
  для присвоения ссылки, даже если она уже существует, тогда как <b>bind(&nbsp;)</b> 
  выбрасывает исключение, если ссылка уже существует. Имя состоит в CORBA из последовательности 
  NameContexts — поэтому мы используем массив для связывания имени со ссылкой 
  на объект.</font></p>
<p><font face="Georgia">Наконец, обслуживающий объект готов к использованию клиентами. 
  После этого серверный процесс входит в состояние ожидания. Опять таки, из-за 
  того, что это временное обслуживание, поэтому время жизни ограничено серверным 
  процессом. JavaIDL в настоящее время не поддерживает постояные объекты — 
  объекты, которые продолжают существовать вне породившего его процесса.</font></p>
<p><font face="Georgia">Теперь, когда мы имеем представление о том, что делает 
  серверный код, давайте взглянем на код клиента:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:corba:RemoteTimeClient.java</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> remotetime.*;
<font color="#0000ff">import</font> org.omg.CosNaming.*;
<font color="#0000ff">import</font> org.omg.CORBA.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> RemoteTimeClient {
  <font color="#009900">// Выбрасываем исключение на консоль:</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) 
  <font color="#0000ff">throws</font> Exception {
    <font color="#009900">// Создание и инициализация ORB:</font>
    ORB orb = ORB.init(args, <font color="#0000ff">null</font>);
    <font color="#009900">// Получение контекста наименования:</font>
    org.omg.CORBA.Object objRef = 
      orb.resolve_initial_references(
        <font color="#004488">"NameService"</font>);
    NamingContext ncRef = 
      NamingContextHelper.narrow(objRef);
    <font color="#009900">// Получение (разрешение) ссылки на строковый</font></font>
    <font color="#009900" size="+1">// </font><font size="+1"><font color="#009900"> объект для сервера времени</font></font><font color="#009900" size="+1">:</font><font size="+1">
    NameComponent nc = 
      <font color="#0000ff">new</font> NameComponent(<font color="#004488">"ExactTime"</font>, <font color="#004488">""</font>);
    NameComponent[] path = { nc };
    ExactTime timeObjRef = 
      ExactTimeHelper.narrow(
        ncRef.resolve(path));
    <font color="#009900">// Выполнение запроса к серверу:</font>
    String exactTime = timeObjRef.getTime();
    System.out.println(exactTime);
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Первые несколько строк делают то же, что они делали в 
  серверном процессе: инициализируют ORB и разрешают указатель на сервис указания 
  имен. Далее, нам нужна ссылка на объект для обслуживающего объекта, поэтому 
  мы передаем ссылку на строковый объект в метод <b>resolve(&nbsp;)</b>, и приводим 
  результат к ссылке на интерфейс <b>ExactTime</b>, используя метод <b>narrow(&nbsp;)</b>. 
  В конце мы вызываем <b>getTime(&nbsp;)</b>.</font></p>
<a name="Heading564"></a> 
<h4 align="left"><font face="Verdana"> Активация процесса указания имен</font></h4>
<p><font face="Georgia">Теперь м ыимеем серверное и клиентское приложения, готовые 
  к взаимодействию. Вы видели, что оба они нуждаются в службе указания имен для 
  связывания и разрешения указателя на строковый объект. Вы должны запустить процесс 
  указания имен до запуска сервера и клиента. В JavaIDL служба указания имен является 
  Java приложением, которое поставляется в пакете с продуктом, но для других продуктов 
  это может быть не так. Служба указания имен JavaIDL запускается внутри экземпляра 
  JVM и слушает по умолчанию сетевой порт 900.</font></p>
<a name="Heading565"></a> 
<h4 align="left"><font face="Verdana"> Активация сервера и клиента</font></h4>
<p><font face="Georgia">Теперь вы готовы запустить ваше серверное и клиентское 
  приложение (в этом порядке, так как наш сервер временный). Если вы все установили 
  правильно, то, что вы получите - это единственная строка вывода в клиентской 
  консоли, сообщающая вам текущее время. Конечно это не очень волнующе само по 
  себе, но вы должны принять во внимание одну вещь: даже если они располагаются 
  на одной и той де машине, клиентское и серверное приложения запускаются внутри 
  разных виртуальных машин и они могут общаться через лежащий в основе интегрирующий 
  уровень, ORB и Сервис Указания Имен.</font></p>
<p><font face="Georgia">Этот простой пример предназначен ля работы без сети, но 
  ORB обычно конфигурируется для независимости от местоположения. Когда сервер 
  и клиент находятся на разных машинах, ORB может разрешать удаленные строковые 
  ссылки, используя компонент, известный как <i>Implementation Repository</i>. 
  Хотя Implementation Repository является частью CORBA, для него нет спецификации, 
  так что он различен у разных производителей.</font></p>
<p><font face="Georgia">Как вы можете видеть, о CORBA есть много больше информации, 
  чем было рассмотрено тут, но вы должны получить основную идею. Если вы хотите 
  получить более подробную информацию относительно CORBA, начните с Web страницы 
  OMG, на <i>www.omg.org</i>. Там вы найдете документацию, белые страницы, работы 
  и ссылки на другие исходные тексты и продукты CORBA.</font></p>
<a name="Heading566"></a> 
<h3 align="left"><font face="Verdana"> Java Апплеты и CORBA</font></h3>
<div align="left"> 
  <p><font face="Georgia">Java апплеты могут выступать в роли CORBA клиентов. 
    Таким образом апплеты могут получать доступ к удаленной информации и службам, 
    существующим, как CORBA объекты. Но апплеты могут соединяться только с тем 
    сервером, с которого их загрузили, так что все CORBA объекты, с которыми взаимодействует 
    апплет, должны быть помещены на сервере. Это противоречит тому, для чего предназначен 
    CORBA: дать вам полную независимость от местоположения.</font></p>
</div>
<p><font face="Georgia">Это особенность сетевой безопасности. Если вы в Интранете, 
  одним из решений является отказ от системы безопасности броузера. Или в установки 
  firewall на соединения со внешних серверов.</font></p>
<p><font face="Georgia">Некоторые из продуктов Java ORB предлагают потенциальное 
  решение этой пролемы. Например, некоторые реализуют то, что называется тунелированием 
  HTTP Tunneling, а другие имеют свои собственные особенности для firewall.</font></p>
<p><font face="Georgia">Это слишком сложный вопрос, чтобы он был освещен в приложении, 
  но это то, в чем вы должны быть уверены.</font></p>
<a name="Heading567"></a> 
<h3 align="left"><font face="Verdana"> CORBA против RMI</font></h3>
<p><font face="Georgia">Вы видели, что одной из главных особенностей CORBA являтся 
  поддержка RPC, которая позволяет вашим локальным объектам вызывать методы удаленного 
  объекта. Конечно, есть родное свойство Java, которое делает то же самое: RMI 
  (смотрите Главу 15). При использовании RMI возможным RPC между объектами Java, 
  CORBA делает возможным RPC между объектами, реализованными на любом языке. В 
  этом огромное различие.</font></p>
<p><font face="Georgia">Однако <a name="Index2210"></a>RMI может быть использовано 
  для вызова сервисов удаленного не Java кода. Все, что вам нужно - это некоторый 
  Java объект-оболочка, включающий в себя не Java код на стороне сервера. Объект-оболочка 
  присоединяется внешним образом к Java клиенту по RMI, и внутренним образом соединяется 
  с не Java кодом, используя одну из технологий, таких как JNI или J/Direct.</font></p>
<p><font face="Georgia">Такой подход требует от вас написания некоторого рода 
  интеграционного уровня, который явно делает то, что CORBA делает за вас, но 
  в этом случае у вас нет неоходимости использовать ORB сторонних разработчиков.</font></p>
<a name="Heading568"></a> 
<h2 align="left"><font face="Verdana"> Enterprise JavaBeans</font></h2>
<p><font face="Georgia">Предположим, </font><a name="fnB77" href="#fn77">[77]</a><font face="Georgia"> 
  вам нужно разработать многоярусное приложение для просмотра и обновления записей 
  в базе данных через Web интерфейс. Вы можете написать приложение для баз данных, 
  используя JDBC, а Web интерфейс использует JSP/сервлеты, а распределенная система 
  использует CORBA/RMI. Но какие дополнительные соображения вы должны принять 
  во внимание при разработке системы распределенных объектов кроме уже известного 
  API? Вот основные соображения:</font></p>
<p><font face="Georgia"><b><i>Производительность:</i></b> Распределенные объекты, 
  которые вы создаете, должны хорошо работать, так как потенциально они должны 
  обслуживать много клиентов одновременно. Вам надо использовать оптимизационные 
  технологии, такие как кеширование и объединение таких ресурсов, как соединение 
  с базой данных. Вам также понадобится управлять продолжительностью жизни ваших 
  распределенных объектов.</font></p>
<p><font face="Georgia"><b><i>Масштабируемость</i>:</b> распределенные объекты 
  должны быть масштабируемыми. Масштабируемость в распределенных приложениях означает, 
  что число экземпляров ваших распределенных объектов может увеличиваться и они 
  могут перемещаться на дополнительные машины без изменения какого-либо кода.</font></p>
<p><font face="Georgia"><b><i>Безопасность:</i></b> Распределенный объект часто 
  должен управлять авторизацией доступа клиента. В идеале вы добавляете новых 
  пользователей и политики без перекомпиляции.</font></p>
<p><font face="Georgia"><b><i>Распределенные Транзакции:</i></b> Распределенные 
  объекты должны быть способны прозрачно ссылаться на распределенные транзакции. 
  Например, если вы работаете с двумя разными базами данных, вы должны быть способны 
  обновить их одновременно в одной трензакции и отменить изменения, если не был 
  выполнен определенный критерий.</font></p>
<p><font face="Georgia"><b><i>Повторная используемость:</i></b>Идеальный распределенный 
  объект может без усилий переносится на сервер приложений другого производителя. 
  Было бы хорошо, если бы вы могли перепродать компонент распределенного объекта 
  не делая при этом специальных изменений, или купить чей-то чужой компонент и 
  использовать его пез перекомпиляции и переписывания.</font></p>
<p><font face="Georgia"><b><i>Доступность:</i></b>Если одна из машин вашей системы 
  выключается, клиенты должны автоматически перейти к резервной копии объектов, 
  работающих на другой машине.</font></p>
<p><font face="Georgia">Эти соображения, наряду с проблемами бизнеса, которые 
  вы собираетесь решить, могут застопорить весь процесс разработки. Однако все 
  эти проблемы, исключая проблемы вашего бизнеса, излишни — решения должны 
  быть придуманы для каждого распределенного бизнес-приложения.</font></p>
<p><font face="Georgia">Sun, наряду с другими лидирующими производителями распределенных 
  объектов, определила, что рано или поздно каждая команда разработчиков найдет 
  обчные решения, поэтому она создала спецификацию Enterprise JavaBeans (EJB). 
  EJB описывает модель компонент стороны сервера, принимающую во внимание все 
  упомянутые выше соображения и стандартные подходы, которые позволят разработчикам 
  создавать бизнес-компоненты, называемые EJB, которые будут изолированы от низкоуровневого 
  “служебного” кода, а будут полностью сфокусированы на обеспечении 
  бизнесс-логики. Поскольку EJB определены стандартным способом, они могут быть 
  не зависимы от производителя.</font></p>
<a name="Heading569"></a> 
<h3 align="left"><font face="Verdana"> JavaBeans против EJB</font></h3>
<p><font face="Georgia">Из-за схожести имен часто путаются между моделью компонент 
  JavaBeans и спецификацией Enterprise JavaBeans. JavaBeans и спецификация Enterprise 
  JavaBeans разделяют одинаковые цели: продвижения повторного использования, компактность 
  Java кода при разработке и инструменты разработки с использованием стандартных 
  шаблонов, но мотивы спецификации больше подходят для решения различных проблем.</font></p>
<p><font face="Georgia">Стандарт, определенный в модели компонент JavaBeans предназначен 
  для создания повторного использования компонент, которые обычно используются 
  в интегрированной среде разработки и часто, но не всегда, являются визуальными 
  компонентами.</font></p>
<p><font face="Georgia"> Спецификация Enterprise JavaBeans определяет модель компонентов 
  для разработки Java кода стороны сервера. Поскольку EJB могут потенциально запускаться 
  на различных серверных платформах — включая центральные машины, которые 
  не имеют визуальных дисплеев — EJB не может использовать графические библиотеки, 
  типа AWT или Swing.</font><a name="_Toc466527392"></a><a name="_Toc481064905"></a></p>
<a name="Heading570"></a> 
<h3 align="left"><font face="Verdana"> Спецификация EJB</font></h3>
<p><font face="Georgia">Спецификация Enterprise JavaBeans описывает модель компонентов 
  стороны сервера. Она определяет шесть ролей, которые используются для выполнения 
  задач при разработке и развертывании, так же определяет компоненты системы. 
  Эти роли используются в разработке, развертывании и запуске распределенных систем. 
  Производители, администраторы и разработчики играют разные роли, позволяя разделять 
  технологию и область знаний. Продавец обеспечивает техническое рабочее пространство, 
  а разработчик создает специфичные для данной области компоненты, например, компонент 
  “счет”. Та же сама компания может выполнять одну или несколько ролей. 
  Роли, определенные в спецификации EJB сведены в следующую таблицу:</font></p>
<div align="center"> 
  <table border="1" width="100%">
    <tbody><tr valign="top"> 
      <th> 
        <p><font face="Georgia"><b>Роль</b></font></p>
      </th>
      <th> 
        <p><font face="Georgia"><b>Отвественность</b></font></p>
      </th>
    </tr>
    <tr valign="top"> 
      <td> 
        <p><font face="Georgia">Поставщик Enterprise Bean</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Разработчик отвечает за создание EJB компонент 
          повторного использования. Эти компоненты упакованы в специальный jar 
          файл (ejb-jar файл).</font></p>
      </td>
    </tr>
    <tr valign="top"> 
      <td> 
        <p><font face="Georgia">Сборщик приложения</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Создает и собирает приложение из набора ejb-jar 
          файлов. Это включает написание приложений, которые утилизируют набор 
          EJB (напимер, сервлетов, JSP, Swing и т.д., и т.п.).</font></p>
      </td>
    </tr>
    <tr valign="top"> 
      <td> 
        <p><font face="Georgia">Установщик</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Берет набор ejb-jar файлов от сборщика и/или Поставщика 
          Bean и разворачивает их в среде времени выплнения: один или несколько 
          EJB Контейнеров.</font></p>
      </td>
    </tr>
    <tr valign="top"> 
      <td> 
        <p><font face="Georgia">EJB Контейнер/Поставщик сервера</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Предоставляет среду времени выполнения и инструменты, 
          используемые для развертывания, администрирования и запуска EJB компонент.</font></p>
      </td>
    </tr>
    <tr valign="top"> 
      <td> 
        <p><font face="Georgia">Системный администратор</font></p>
      </td>
      <td> 
        <p><font face="Georgia">Управляет различными компонентами и службами, 
          чтобы они были сконфигурированы и правильно взаимодействовали, также 
          следит, чтобы система работала корректно.</font></p>
      </td>
    </tr>
  </tbody></table>
</div>
<p align="center"></p>
<a name="_Toc466527394"></a><a name="_Toc481064906"></a> <a name="Heading571"></a> 
<h3 align="left"><font face="Verdana">EJB компоненты</font></h3>
<p><font face="Georgia">EJB компоненты являются многократно используемыми элементами 
  бизнес-логики, которые жестко следуют стандартам и шаблонам разработки, определенным 
  в спецификации EJB. Это позволяет компонентам быть переносимыми. Это также позволяет 
  другим службам — таким как безопасность, кэширование и распределенные 
  транзакции — работать с пользо для компонент. Поставщик Enterprise Bean 
  отвечает за разработку EJB компонент.</font></p>
<a name="Heading572"></a> 
<h4 align="left"><font face="Verdana"> EJB контейнер и сервер</font></h4>
<p><font face="Georgia"> <i>EJB Контейнер </i> представляет из себя среду времени 
  выполнения, которая содержит и запускает EJB компоненты и предоставляет набор 
  стандартных служб для этих компонент. Обязанности EJB Контейнера четко определены 
  в спецификации, чтобы обеспечить нейтралитет производителя. EJB контейнер предоставляет 
  низкоуровневое “обслуживание” EJB, включая распределенные транзакции, 
  безопасность, управление циклом жизни компонента, кэширование, нити процессов 
  и управление сессиями. Поставщик EJB Конетйнера отвечает за предоставление EJB 
  Контейнера.</font></p>
<p><font face="Georgia"> <i>EJB Сервер </i>определяется как Сервер Приложений, 
  который содержит и запускает один или несколько EJB Контейнеров. Поставщик EJB 
  Сервера отвечает за предоставление EJB Сервера. Вы можете полагать, что EJB 
  Контейнер и EJB Сервер это одно и то же.</font></p>
<a name="Heading573"></a> 
<h4 align="left"><font face="Verdana"> Java Naming и Directory Interface (JNDI)</font></h4>
<div align="left"> 
  <p><font face="Georgia">Java Naming and Directory Interface (JNDI) используется 
    в Enterprise JavaBeans в качестве службы указания имен для EJB компонент в 
    сети и других службах контейнера, таких как транзакции. JNDI работает очень 
    похоже с другими стандартами, такими как CORBA CosNaming, и может на самом 
    деле быть реализован в виде надстройки над ним.</font></p>
</div>
<a name="Heading574"></a> 
<h4 align="left"><font face="Verdana"> Java Transaction API/Java Transaction Service 
  (JTA/JTS)</font></h4>
<div align="left"> 
  <p><font face="Georgia">JTA/JTS используются в Enterprise JavaBeans в качестве 
    API транзакции. Поставщик Enterprise Bean может использовать JTS для создания 
    кода транзакции, хотя EJB Контейнер чаще всего реализует транзакцию в EJB 
    на полезных EJB компонентах. Установщик может определить атрбуты транзакции 
    EJB компонента во время развертывания. EJB Контейнер отвечает за обработку 
    тразакции не зависимо от того, является ли она локальной или распределенной. 
    Спецификация JTS является Java отображением на CORBA OTS (Object Transaction 
    Service)</font>.</p>
</div>
<a name="Heading575"></a> 
<h4 align="left"><font face="Verdana"> CORBA и RMI/IIOP</font></h4>
<p><font face="Georgia">Спецификация EJB определяет взаимодействие с CORBA через 
  совместимость с CORBA протоколами. Это достигнуто путем совмещения EJB служб, 
  таких как JTS и JNDI, с соотвествующими службами CORBA и реализацией RMI поверх 
  IIOP протокола CORBA.</font></p>
<p><font face="Georgia">Использование CORBA и RMI/IIOP в Enterprise JavaBeans 
  реализовано в EJB Контейнере и за это отвечает поставщик EJB Котейнера. Использование 
  CORBA и RMI/IIOP в EJB Контейнере спрятано от самого EJB Контейнера. Это означает, 
  что Поставщик Enterprise Bean может написать свой EJB Компонент и развернуть 
  его в любом EJB Контейнере не заботясь о том, какие коммуникационные прооколы 
  он использует.</font></p>
<a name="Heading576"></a> 
<h3 align="left"><font face="Verdana"> Составные части EJB компонента</font></h3>
<p><font face="Georgia"> EJB состоит из нескольких частей, включая сам компонент, 
  реализацию некоторых интерфейсов и информационный файл. Все это пакуется вместе 
  в специальный jar файл.</font></p>
<a name="Heading577"></a> 
<h4 align="left"><font face="Verdana"> Enterprise Bean</font></h4>
<p><font face="Georgia"> Enterprise Bean является Java классом, разработанным 
  Поставщиком Enterprise Bean. Он реализует интерфейс Enterprise Bean и обеспечивает 
  реализацию бизнес-методов, которые выполняет компонент. Класс не реализует никакую 
  авторизацию, многопоточность или код транзакции.</font></p>
<a name="Heading578"></a> 
<h4 align="left"><font face="Verdana"> Домашний интерфейс</font></h4>
<p><font face="Georgia">Каждый содающийся Enterprise Bean должен иметь ассоциированный 
  домашний интерфейс. Домашний интерфейс используется как фабрика для вашего EJB. 
  Клиент использует Домашний интерфейс для нахождения экземпляра вашего EJB или 
  создания нового экземпляра вашего EJB.</font><a name="_Toc466527398"></a> </p>
<a name="Heading579"></a> 
<h4 align="left"><font face="Verdana"> Удаленный интерфейс</font></h4>
<p><font face="Georgia">Удаленный интерфейс является Java Интерфейсом, который 
  отображает через рефлексию те методы вашего Enterprise Bean, которые вы хотите 
  показывать внешнему миру. Удаленный интрфейс играет ту же роль, что и IDL интерфейс 
  в CORBA.</font></p>
<a name="Heading580"></a> 
<h4 align="left"><font face="Verdana"> Описатель развертывания</font></h4>
<p><font face="Georgia">Описатель развертываия является XML файлом, который содержит 
  информацию относительно вашего EJB. Исползование XML позволяет установщику легко 
  менять атрибуты вашего EJB. Конфигурационные атрибуты, определеные в описателе 
  развертывания, включают:</font></p>
<ul>
  <li><font face="Symbol"> </font><font face="Georgia">Имена Домашнего и Удаленного 
    интерфейса, которые требуются для вашего EJB</font> 
  </li><li><font face="Symbol"> </font><font face="Georgia">Имя для публикации в JNDI 
    для вашего Домашнего интерфейса EJB</font> 
  </li><li><font face="Symbol"> </font><font face="Georgia">Транзакционные атрибуты 
    для каждого метода вашего EJB</font> 
  </li><li><font face="Symbol"> </font><font face="Georgia">Контрольный Список Доступа 
    для авторизации</font> 
</li></ul>
<a name="Heading581"></a> 
<h4 align="left"><font face="Verdana"> EJB-Jar файл</font></h4>
<p><font face="Georgia"> EJB-Jar файл - это обычный java jar файл, который содержит 
  ваш EJB, Домашний и Удаленный интерфейсы наряду с описателем развертывания.</font><a name="_Toc466527401"></a><a name="_Toc481064908"></a><br>
</p>
<a name="Heading582"></a> 
<h3 align="left"><font face="Verdana"> EJB операции</font></h3>
<p><font face="Georgia">После того, как вы получили EJB-Jar файл, содержащий компонент, 
  Домашний и Удаленный интерфейсы и описатеь развертывания, вы можете сложить 
  все части вместе и в процессе понять, для чего нужны Домашний и Удаленный интерфейсы 
  и как EJB Контейнер использует их.</font></p>
<p><font face="Georgia"> EJB Контейнер реализует Домашний и Удаленный интерфейсы, 
  которые есть в EJB-Jar файле. Как упоминалось ранее, Домашний интерфейс обеспечивает 
  методы для создания и нахождения вашего EJB. Это означает, что EJB Контейнер 
  отвечает за уравление жизненным циклом вашего EJB. Этот уровень ненаправленности 
  позволяет учитывать происходящую оптимизацию. Например, 5 клиентов могут одновременно 
  запросить определенный EJB через Домашний интерфейс, а EJB Контейнер должен 
  ответить созданием только одого EJB и распределением его между 5 клиентами. 
  Это достигается через Удаленный интерфейс, который так же реализуется через 
  EJB Контейнер. Реализованный Удаленный объект играет роль довертельного объекта 
  для EJB.</font></p>
<p><font face="Georgia">Все вызовы EJB ‘проксирубтся(proxied)’ через 
  EJB Контейнер посредством Домашнего и Удаленного интерфейса. Этот обходной путь 
  является причиной того, что EJB контейнер может управлять безопасностью и поведением 
  транзакций.</font></p>
<a name="Heading583"></a> 
<h3 align="left"><font face="Verdana"> Типы EJB</font></h3>
<p><font face="Georgia">Спецификация Enterprise JavaBeans определяет различные 
  типы EJB, которые имеют разичные характеристики и поведение. В спецификации 
  определены две категории EJB: <i>Сессионный Компонент</i> и <i>Сущностный Компонент</i>. 
  Каждая категория имеет свои варианты.</font></p>
<a name="Heading584"></a> 
<h4 align="left"><font face="Verdana"> Сессионный компонент</font></h4>
<p><font face="Georgia">Сессионный компонент используется для представления случаев 
  использования или порядока выполняеых действий с поьзой для клиента. Они представляют 
  операции с постоянными данными, но не сами постоянные данные. Есть два типа 
  Сессионных Компонентов: <i>Без Состояния(Stateless)</i> и <i>Полного Состояния(Stateful)</i>. 
  Все Сессионные Компоненты должны реализовывать интерфейс <b>javax.ejb.SessionBean</b>. 
  EJB Контейнер управляет жизнью Сессионного Компонента.</font></p>
<div align="left"> 
  <p><font face="Georgia"><b>Сессионный Компонент Без Состояния</b> - это самый 
    простой в реализации тип EJB компонента . Он не содержит никаких значимых 
    состояний для клиента между вызовами методов, так что они легко используются 
    повторно на стороне сервера и поэтому они могут кэшироваться, они легко масштабируются 
    при необходимости. Когда используете Сессионные Компоненты Без Состояния, 
    все состояния можно хранить вне EJB.</font></p>
</div>
<p><font face="Georgia"><b>Сессионный Компонент Полного Состояния </b> содержит 
  состояние между вызовами. Они имеют логику один к одному для клиентов и могут 
  содержать состояния в себе. EJB Клнтейнер ответственен за объединение и кэширование 
  Сессионных Компонентов Полного Состояния, что достигается через Неактивность 
  и Активность. Если EJB Контейнер рушиться, данные всех EJB Сессионных Компонентов 
  Полного Состояния могут быть потеряны. Некоторые высокоуровневые EJB Контейнеры 
  обеспечивают восстановление Сессионных Компонентов Полного Состояния.</font></p>
<a name="_Toc466527405"></a> <a name="Heading585"></a> 
<h4 align="left"><font face="Verdana"> Сущностные компоненты</font></h4>
<p><font face="Georgia">Сущностные компоненты являются компонентами, представляющие 
  постоянные даные и их поведение. Сущностные компоненты могут быть разделены 
  между многоми клиентами, точно так же как могут разделяться данные в базе данных. 
  EJB Контейнер отвечает за кэширование Сущностных Объектов и за поддержкой интегрирования 
  Сущностных Компонентов. Существование Сущностных Компонентов определяется EJB 
  Контейнером, так что если EJB Контейнер рушится, Сущностные Компоненты будут 
  доступны только тогда, когда будет доступен EJB Контейнер.</font></p>
<p><font face="Georgia">Есть два типа Сущностных Компонент: существующие с Управлением 
  Контейнера (Container Managed persistence) и существующие с Управлением Компонентами 
  (Bean-Managed persistence).</font><br>
</p>
<p><font face="Georgia"><b>Container Managed Persistence (CMP)</b>. CMP Сущностные 
  Компоненты реализованы с выгодой для EJB Контейнера. Через указанные в описании 
  развертывания спецификации, EJB Контейнер связывает атрибуты Сущностных Компонент 
  с некоторым постоянным хранилищем (обычно — но не всегда — это база 
  данных). CMP снижает время разработки для EJB, так же, как и значительно снижает 
  число требуемого кода.</font></p>
<p><font face="Georgia"><b>Bean Managed Persistence (BMP)</b>. BMP Сущностные 
  Компоненты реализовываются Поставщиком Enterprise Bean. Поставщик Enterprise 
  Bean отвечает за реализацию логики, требуемой для создания новых EJB, изменения 
  некоторых атрибутов EJB, удаление EJB и нахождение EJB в постоянном хранилище. 
  Обычно для этого требуется написание JDBC кода для взаимодействия с базой данных 
  или другим постоянным хранилищем. С помощью BMP разработчик имеет полный контроль 
  над управлением существования Сущностного Объекта.</font></p>
<p><font face="Georgia">BMP также дает гибкость в тех местах, где реализация CMP 
  не может быть использована. Например, если вы хотите создать EJB, который включает 
  в себя некий код существующей главной системы, вы должны написать вашу устойчивось, 
  используя CORBA.</font><a name="_Toc476631340"></a><a name="_Toc481064910"></a></p>
<a name="Heading586"></a> 
<h3 align="left"><font face="Verdana"> Разработка EJB</font></h3>
<p><font face="Georgia">В качестве примера будет реализован EJB компонент “Perfect 
  Time” из предыдущего раздела, посвященного RMI. Пример будет выполнен 
  как Сессионный Компонент без Состояния.</font></p>
<p><font face="Georgia">Как упоминалось ранее, EJB компоненты содержат не менее 
  одного класса (EJB) и двух интерфейсов: Удаленный и Домашний интерфейсы. Когда 
  вы создаете Удаленный интерфейс для EJB, вы должны следовать следующим принципам:</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Удаленный интерфейс должен 
    быть публичным (<b>public</b>).</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Удаленный интерфейс должен 
    расширять интерфейс <b>javax.ejb.EJBObject</b>.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Каждый метод удаленного 
    интерфейса должен декларировать <b>java.rmi.RemoteException</b> в предложении 
    <b>throws</b> помимо всех исключений, спецефичных для приложения.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Лбой объект, передаваемый 
    в качестве аргумента или возвращаемого значения (встроенный, либо содержащийся 
    внутри локального объекта) должен быть действительным с точки зрения RMI-IIOP 
    типом данных (это относится и к другим EJB объектам).</font> 
</li></ol>
<p>Вот простой удаленный <font color="#0000ff">интерфейс </font>для PerfectTime 
  EJB:</p>
<blockquote> 
  <pre><font size="+1"><font color="#009900">//: c15:ejb:PerfectTime.java</font></font>
<font color="#009900" size="+1">//# Вы должны установить J2EE Java Enterprise </font>
<font color="#009900" size="+1">//# Edition с java.sun.com и добавить j2ee.jar</font>
<font color="#009900" size="+1">//# в вашу переменную CLASSPATH, чтобы скомпилировать</font>
<font color="#009900" size="+1">//# этот файл. Подробности смотрите на java.sun.com.</font>
<font color="#009900" size="+1">// Удаленный интерфейс для PerfectTimeBean</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> java.rmi.*;
<font color="#0000ff">import</font> javax.ejb.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">interface</font><font size="+1"> PerfectTime <font color="#0000ff">extends</font> EJBObject {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">long</font><font size="+1"> getPerfectTime() 
    <font color="#0000ff">throws</font> RemoteException;
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Домашний интерфейс является фабрикой для создания компонента. 
  Он может определить метод <i>create</i>, для создания экземпляра EJB, или метод 
  <i>finder</i>, который находит существующий EJB и используется олько для Сущностных 
  Компонент. Когда вы создаете Домашний интерфейс для EJB, вы должны следовать 
  следующим принципам:</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Домашний интерфейс должен 
    быть публичным (<b>public</b>).</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Домашний интерфейс должен 
    расширять интерфейс <b>javax.ejb.EJBHome</b>.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Каждый метод <i>create</i> 
    Домашнего интерфейса должен декларировать <b>java.rmi.RemoteException</b> 
    в преложении <b>throws</b> наряду с <b>javax.ejb.CreateException</b>.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Возвращаемое значение 
    метода <i>create</i> должно быть Удаленным интерфейсом.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Возвращаемое значение 
    метода <i>finder</i> (только для Сущностных Компонент) должно быть удаленным 
    интерфейсом или <b>java.util.Enumeration</b>, или <b>java.util.Collection</b>.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Любые объекты, передаваемые 
    в качесвте аргумента (либо напрямую, либо внутри локального объекта) должны 
    быть действительными с точки зрения RMI-IIOP типом данным (включая другие 
    EJB объекты)</font>. 
</li></ol>
<p><font face="Georgia">Стандартное соглашение об именах Домашних интерфейсов 
  состоит в прибавлении слова “Home” в конец имени Удаленного интерфейса. 
  Вот Домашний интерфейс для PerfectTime EJB:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:ejb:PerfectTimeHome.java</font>
<font color="#009900" size="+1">// Домашний интерфейс PerfectTimeBean.</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> java.rmi.*;
<font color="#0000ff">import</font> javax.ejb.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">interface</font><font size="+1"> PerfectTimeHome <font color="#0000ff">extends</font> EJBHome {
  <font color="#0000ff">public</font> PerfectTime create() 
    <font color="#0000ff">throws</font> CreateException, RemoteException;
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Теперь вы можете реализовать бизнес логику. Когда вы создаете 
  вышу реализацию EJB класса, вы должны следовать этим требованиям (обратите внимание, 
  что вы должны обратиться к спецификации EJB, чтобы получить полный список требований 
  при разработке Enterprise JavaBeans):</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Класс должен быть публичным 
    (<b>public</b>).</font> 
  </li><li><font face="Georgia">Класс должен реализовывать EJB интерфейс (либо <b>javax.ejb.SessionBean</b>, 
    либо <b> javax.ejb.EntityBean</b>).</font> 
  </li><li><font face="Georgia">Класс должен определять методы, которые напрямую связываются 
    с методами Удаленного интерфейса. Обратите внимание, что класс не реализует 
    Удаленный интерфейс. Он отражает методы удаленного интерфейса, но <i>не</i> 
    выбрасывает <b>java.rmi.RemoteException</b>.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Определите один или несколько 
    методов <b>ejbCreate(&nbsp;)</b> для инициализации вашего EJB.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Возвращаемое значение 
    и аргументы всех методов должны иметь действительны тип данных с точки зрения 
    RMI-IIOP.</font> 
</li></ol>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:ejb:PerfectTimeBean.java</font>
<font color="#009900" size="+1">// Простой Stateless Session Bean,</font>
<font color="#009900" size="+1">// возвращающий текущее системное время.</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> java.rmi.*;
<font color="#0000ff">import</font> javax.ejb.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> PerfectTimeBean 
  <font color="#0000ff">implements</font> SessionBean {
  <font color="#0000ff">private</font> SessionContext sessionContext;
  <font color="#009900">//возвращае текущее время</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">long</font><font size="+1"> getPerfectTime() { 
     <font color="#0000ff">return</font> System.currentTimeMillis();
  }
  <font color="#009900">// EJB методы</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">void</font><font size="+1"> ejbCreate() 
  <font color="#0000ff">throws</font> CreateException {}
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> ejbRemove() {}
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> ejbActivate() {}
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> ejbPassivate() {}
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> 
  setSessionContext(SessionContext ctx) {
    sessionContext = ctx;
  }
}<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Из-за простоты этого примера EJB методы (<b>ejbCreate(&nbsp;)</b>, 
  <b>ejbRemove(&nbsp;)</b>, <b>ejbActivate(&nbsp;)</b>, <b>ejbPassivate(&nbsp;)</b>) 
  оставлены пустыми. Этиметоды вызываются EJB Контейнером и используются для управления 
  состоянием компонента. Метод <b>setSessionContext(&nbsp;)</b> передает объект 
  <b>javax.ejb.SessionContext</b>, который содержит информацию относительно контекста 
  компонента, такую как текущая транзакция и информация безопасности.</font></p>
<p><font face="Georgia">После того, как мы создали Enterprise JavaBean, нам нужно 
  создать описатель развертывания. Описатель развертывания - это XML файл, котрый 
  описывает EJB компонент. Описатель развертывания должен хранится в файле, называемом 
  <b>ejb-jar.xml</b>.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//:! c15:ejb:ejb-jar.xml</font>
<font size="+1">&lt;?xml version=<font color="#004488">"1.0"</font> encoding=<font color="#004488">"Cp1252"</font>?&gt;
&lt;!DOCTYPE ejb-jar PUBLIC '-<font color="#009900">
//Sun Microsystems, Inc.
//DTD Enterprise JavaBeans 1.1
//EN' 'http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd'&gt;</font></font>

<font size="+1">&lt;ejb-jar&gt;
  &lt;description&gt;Example <font color="#0000ff">for</font> Chapter 15&lt;/description&gt;
  &lt;display-name&gt;&lt;/display-name&gt;
  &lt;small-icon&gt;&lt;/small-icon&gt;
  &lt;large-icon&gt;&lt;/large-icon&gt;
  &lt;enterprise-beans&gt;
    &lt;session&gt;
      &lt;ejb-name&gt;PerfectTime&lt;/ejb-name&gt;
      &lt;home&gt;PerfectTimeHome&lt;/home&gt;
      &lt;remote&gt;PerfectTime&lt;/remote&gt;
      &lt;ejb-<font color="#0000ff">class</font>&gt;PerfectTimeBean&lt;/ejb-<font color="#0000ff">class</font>&gt;
      &lt;session-type&gt;Stateless&lt;/session-type&gt;
      &lt;transaction-type&gt;Container&lt;/transaction-type&gt;
    &lt;/session&gt;
  &lt;/enterprise-beans&gt;
  &lt;ejb-client-jar&gt;&lt;/ejb-client-jar&gt;
&lt;/ejb-jar&gt;
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Вы можете видеть, что Компонент, Удаленный интерфейс и 
  Домашний интерфейс определены внури ярлыка <b>&lt;session&gt; </b> этого описателя 
  развертывания. Описатель развертывания может быть сгенерирован автоматически 
  при использовании инструментов разработки EJB.</font></p>
<p><font face="Georgia">Наряду со стандартным описателем развертывания <b>ejb-jar.xml</b>, 
  спецификация EJB устанавливает, что любые ярлыки, специфичные для производитея, 
  должны хранится в отдельном файле. Это обеспечивает высокую совместимость между 
  компонентами и EJB контейнерами различных марок.</font></p>
<p><font face="Georgia">Файлы должны быть заархивированы внутри стандартного Java 
  Archive (JAR) файла. Описатель развертывания должен помещаться внутри поддиректории 
  <b>/META-INF </b> Jar.</font></p>
<p><font face="Georgia">После того, как EJB компонент определен в описателе развертывания, 
  установщик может развернуть EJB компонент в EJB Контейнере. В то время ,когда 
  это писалось, процесс установки был достаточно “GUI визуализированным” 
  и специфичным для каждого индивидуального EJB Контейнера, так что этот обзор 
  не документирует этот процесс. Однако каждый EJB Контейнер имеет хорошую документацию 
  для равзертывания EJB.</font></p>
<p><font face="Georgia">Поскольку EJB компоненты являются распределенными компонентами, 
  процесс установки должен также создавать некотые клиентские якоря для вызова 
  EJB компонент. Эти классы должны помещаться в classpath клиентского приложения. 
  Поскольку EJB компоненты могут реализовываться поверх RMI-IIOP (CORBA) или RMI-JRMP, 
  генерируемые якоря могут различаться в зависимости от EJB Контейнера, тем не 
  менее, они являются генерируемыми классами.</font></p>
<p><font face="Georgia">Когда клиентмкая программа хочет вызвать EJB, она должна 
  найти EJB компонент внутри JNDI и получить ссылку на домашний интерфейс EJB 
  компонента. Домашний интерфейс используется для создания экземпляра EJB.</font></p>
<p><font face="Georgia">В этом примере клиентская программа - это простая Java 
  программа, но вы должны помнить, что она так же легко может быть сервлетом, 
  JSP или даже распределенным объектом CORBA или RMI.</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c15:ejb:PerfectTimeClient.java</font>
<font color="#009900" size="+1">// Клиентская программа для PerfectTimeBean</font>

<font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">class</font><font size="+1"> PerfectTimeClient {
<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) 
<font color="#0000ff">throws</font> Exception {
  <font color="#009900">// Получение контекста JNDI с помощью </font></font>
  <font color="#009900" size="+1">// JNDI службы Указания Имен:</font><font size="+1">
  javax.naming.Context context = 
    <font color="#0000ff">new</font> javax.naming.InitialContext();
  <font color="#009900">// Поиск Домашнего интерфейса в</font></font>
  <font color="#009900" size="+1">// службе JNDI Naming:</font><font size="+1">
  Object ref = context.lookup(<font color="#004488">"perfectTime"</font>);
  <font color="#009900">// Приведение удаленного объекта к домашнему итерфейсу:</font>
  PerfectTimeHome home = (PerfectTimeHome)
    javax.rmi.PortableRemoteObject.narrow(
      ref, PerfectTimeHome.<font color="#0000ff">class</font>);
  <font color="#009900">// Создание удаленного объекта из домашнего интерфейса:</font>
  PerfectTime pt = home.create();
  <font color="#009900">// Вызов getPerfectTime()</font>
  System.out.println(
    <font color="#004488">"Perfect Time EJB invoked, time is: "</font> + 
    pt.getPerfectTime() );
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Последовательность выполняемых действий поясняется комментариями. 
  Обратите внимание на использование метода <b>narrow(&nbsp;)</b> для совершения 
  приведения объекта перед выполнением Java приведения. Это очень похоже на то, 
  что происходит в CORBA. Также обратите внимание, что Домашний объект становится 
  фабрикой для объекта <b>PerfectTime</b>.</font></p>
<a name="Heading587"></a> 
<h3 align="left"><font face="Verdana"> Резюме о EJB</font></h3>
<p><font face="Georgia">Спецификация Enterprise JavaBeans это кординальный шаг 
  к стандартизации распределенных объектов и упрощению распределенных вычислений. 
  Это основной элемент платформы Java 2 Enterprise Edition (J2EE), который пинимает 
  на сбя основную поддержку общения распределенных объектов. В настоящее время 
  существуют или появятся в бижайшем будущем многие инструменты, помогающие ускорить 
  разработку EJB компонентов.</font></p>
<p><font face="Georgia">Этот обзор является только коротким туром по EJB. Более 
  поробно о спецификации EJB вы можете посмотреть на официальной странице Enterprise 
  JavaBeans по адресу <i>java.sun.com/products/ejb/</i>, где вы можете загрузиь 
  последнюю спецификацию и ссылку на реализацию J2EE. Они могут быть использованы 
  для разработки и развертывания ваших собственных EJB.</font></p>
<a name="Heading588"></a> 
<h2 align="left"><font face="Verdana"> Jini: распределенные сервисы</font></h2>
<p><font face="Georgia">Этот раздел </font><a name="fnB78" href="#fn78">[78]</a><font face="Georgia"> 
  дает вам обзор технологии Jini от Sun Microsystems. Здесь описаны некоторые 
  элементы Jini и показано как Jini архитектура помогает увеличить уровень абстракции 
  в распределенной системе программирования, эффективно включая сетевое програмирование 
  в объектно-ориентированное программирование.</font></p>
<a name="Heading589"></a> 
<h3 align="left"><font face="Verdana"> В контексте Jini</font></h3>
<p><font face="Georgia">Традиционно операционные системы были разработаны в том 
  приближении, что компьютер имеет процессор, некоторую память и диск. Когда вы 
  загружаете компьютер, первое, что он делает, это ищет диск. Если он не находит 
  диск, он не может работать, ак компьютер. Однако компьютеры все чаще и чаще 
  появляются в различном облике: как встроенные устройства с процессором, памятью, 
  сетевым соединением — но без диска. например, первое, что делает телефон 
  при поднятии трубки - это поиск телефонной сети. Если он не находит сети, он 
  не может функционировать как телефон. Таким образом происходит отклонение в 
  аппаратном устройстве от фиксации на диске к фиксации на сети, что сказывается 
  на том, как организуется програмное обеспечение — и для этого был создан 
  Jini.</font></p>
<p><font face="Georgia">Jini - это попытка перестройки компьютерной архитектуры, 
  дающая увиличение важности сети и увиличение числа процессоров в устройстве, 
  не имеющем дисковода. Таким устройствам, поставляемым многоми производителями, 
  необходимо взаимоействие по сети. Сама сеть может быть очень динамичной — 
  устройства и службы будут регулярно добавляться и удаляться. Jini обеспечивает 
  механизм, позволяющий сглаживать добавление, удаления и нахождения устройств 
  и служб в сети. Кроме того, Jini обеспечивает модель программирования, в которой 
  программистам легче заставить их устройства общаться с другими.</font></p>
<p><font face="Georgia">Построенная на Java, сериализации объектов и RMI (все 
  вместе это позволяет перемещать объекты по сети от одной виртуальной машины 
  к другой) Jini пробует расширять выгоды объектно-ориентированного программирования 
  в сети. Вместо того, чтобы требовать от производителей согласия на поддержку 
  сетевых протоколов, через которые их устройства могли бы взаиможействовать, 
  Jini позволяет устройсвтам говорить друг с другом через интерфейсы объектов.</font></p>
<a name="Heading590"></a> 
<h3 align="left"><font face="Verdana"> Что такое Jini?</font></h3>
<p><font face="Georgia">Jini - это набор API и сетевых протоколов, которые могут 
  помочь вам построить и развернуть распределенную систему, организованную, как 
  <i>федерация сервисов</i>. <i>Сервисы </i>могут быть всем, что сидит в сети 
  и готово выполнить полезную функцию. Аппаратные устройства, программы, каналы 
  связи — даже сами пользователи - люди — могут быть сервисами. Например 
  Jini-совместимые дисководы могут предлагать сервис “хранения”. Jini-совместимые 
  принтеры могут прелагать сервис “распечатки”. Таким образом, федерация 
  служб является набором сервисов, доступных в сети в данный момент, которыми 
  могут воспользываться клиенты (под клиентами подразумевается программы, службы 
  или пользователи) для достижения некоторой цели.</font></p>
<p><font face="Georgia">Для выполнения задачи клиенты привлекают на помощь сервисы. 
  Например, клиентские программы могут загружать кртинки из хранилища изображений 
  цифровой камеры, передавать картинки службе постоянного хранения, предаставляемой 
  дисководом, и посылать страницу эскизов фотографий различных размеров для распечатки 
  на цветном принтере. В этом примере клиентская программа построена, как распределенная 
  система, содержащая в себе сервис хранения изображений, сервис постоянного хранения 
  и сервис цветной печати. Клиенты и сервисы этой распределеной системы работают 
  совместно для выполнения задач: выгрузки хранимых изображений из цифровой камеры 
  и распечатка страниц эскизов.</font></p>
<p><font face="Georgia">Идея, стоящая за миром <i>федерации</i>, состоит в том, 
  что Jini просматривает сеть и не вовлекает центр управления. Поскольку не один 
  из сервисов не загружается, набор всех сервисов доступен в сети из федерации 
  — группы, состоящей из равных элементов. Вместо централной власти, инфраструктура 
  Jini времени выполнения просто обеспечивает способ для клиентов и сервисов находить 
  друг друга (через службу поиска, которая хранит справочник поддерживаемых в 
  настоящее время сервисов). После того, как услуги найдут друг друга, они становятся 
  собственными. Клиент и привлеченные им сервисы выполняют свою задачу независимо 
  от инфраструктуры Jini времени выполнения. Если служба поиска Jini потерпит 
  крушение, любая распределенная система, собранная через сервис поиска до его 
  падения, продолжит свою работу. Jini даже включает сетевой протокол, который 
  могут использовать клиенты для нахождения служб при отсутствии службы поиска.</font></p>
<a name="Heading591"></a> 
<h3 align="left"><font face="Verdana"> Как работает Jini</font></h3>
<p><font face="Georgia">Jini определяет <i>ифраструктуру времени выполнения</i>, 
  которая располагается в сети и обеспечивает механизм, позволяющий вам добавлять, 
  удалять, находить и получать доступ к сервисам. Инфраструктура времени выполнения 
  располагается в трех местах: в сервисе поиска, которая находится в сети, в поставщиках 
  услуг (таких как Jini-совместимые устройства) и в клиентах. <i>Служба поиска</i> 
  является механизмом центральной организации для систем, базирующихся на Jini. 
  Когда в сети становится доступным новый сервис, он регистрируется в службе поиска. 
  Когда клиент хочет найи службу для выполнения какой-либо работы, он консультируется 
  у службы поиска.</font></p>
<p><font face="Georgia">Инфроструктура времени выполнения использует один протокол 
  сетевого уровня, называемый <i>обнаружение</i>(<i>discovery</i>) и два протокола 
  объектного уровня, называемые <i>объединение</i>(<i>join</i>) и <i>поиск</i>(<i>lookup</i>). 
  Обнаружение позволяет клиентам и службам обнаружить службу поиска. Объединение 
  позволяет службам регистрироваться в службе поиска. Поиск позволяет клиенту 
  опрашивать сервисы, в поисках тех, которые могут помочь в достижении цели.</font></p>
<a name="Heading592"></a> 
<h3 align="left"><font face="Verdana"> Процесс обнаружения</font></h3>
<p><font face="Georgia">Обнаружение работает следующим образом: предположим у 
  вас есть Jini-совместимый дисковод, который предоставляет услугу постоянного 
  хранения. Как только вы подключите дисковод к сети, он пошлет <i>оповещение 
  присутствия </i>по средством группового пакета через хорошо знакомый порт. В 
  оповещение присутствия включается IP адрес и номер порта, через который дисковод 
  может общаться со службой поиска.</font></p>
<p><font face="Georgia">Сервис поиска следит хорошо знакомый порт в ожидании пакетов 
  оповещения присутствия. Когда служба поиска получает оповещение присутствия, 
  она открывает и инспектирует пакет. Пакет содержит информацию, которая позволяет 
  службе поиска определить должна ли она связаться с отправителем пакета. Если 
  это так, она соединяется с отправителем напрямую, создавая TCP соединение по 
  IP адресу и номеру порта, полученному из пакета. Используя RMI, сервис поиска 
  посылает к источнику пакета объект, называемый <i>регистратором</i>. Назначение 
  объекта-регистратора заключается в содействии будующему взаимодействию со службой 
  поиска. Вызывая методы этого объекта отправитель оповещающего пакета может выполнить 
  объединение и поиск службы поиска. В случае дисковода, служба поиска должна 
  создать TCP соединение с дисководом и послать ему объект-регистратор, через 
  который дисковод смог бы зарегистрировать свою службу постоянного хранения через 
  процес объединеия.</font></p>
<a name="Heading593"></a> 
<h3 align="left"><font face="Verdana"> Процесс объединения</font></h3>
<p><font face="Georgia">Как только поставщик сервиса получает объект-регистратор 
  - конечный продукт регистрации - он готов выполнить объединение — стать 
  частью федерации сервисов, зарегистрированных в службе поиска. Чтобы выполнить 
  объединение, поставщик сервиса вызывает метод <b>register(&nbsp;)</b>, принадлежащий 
  объекту-регистратору, передавая в качестве параметра объект, назваемый элемент 
  службы, являющийся пакетом объектов, описывающих службу. Метод <b>register(&nbsp;)</b> 
  посылает копию элемента службы сервису поиска, где хранится эолемент службы. 
  Когда это будет выполнено, поставщик сервиса завершает процесс объединения: 
  его служба становится зарегистрированной в службе поиска.</font></p>
<div align="left"> 
  <p><font face="Georgia">Элемент службы является контенером для нескольких объектов, 
    включая объект, называемый <i>объектом сервиса</i>, который может быть использован 
    клиентом для взаимодействия со службой. Элемент службы также может включать 
    любое число атрибутов, которые могут быть любым объектом. Некотрые из потенциальных 
    атрибутов - это иконки, классы, обеспечивающие GUI для службы и объекты, которые 
    дают более подробную информацию о службе.</font></p>
</div>
<p><font face="Georgia">Объекты службы обычно реализованы одним или несколькими 
  интерфейсами, через которые клиенты взаимодействуют со службой. Напимер, служба 
  поиска является Jini службой, а соответствующий объект службы - это объект-регистратор. 
  Метод <b>register(&nbsp;)</b>, вызываемый поставщиком службы во время объединения, 
  объявляется в интерфейсе <b>ServiceRegistrar</b> (член пакета <b>net.jini.core.lookup</b>), 
  который реализуют все объекты-регистраторы. Клиенты и поставщики услуг общаются 
  со службой поиска через объект-регистратор, вызывая методы, объявленные в интерфейсе 
  <b>ServiceRegistrar</b>. Точно так же, дисковод будет предоставлять объект службы, 
  который реализует некоторый хорошо известный интерфейс службы хранения. Клиенты 
  будут искать и взаимодействовать с дисководом посредством интерфейса службы 
  хранения.</font></p>
<a name="Heading594"></a> 
<h3 align="left"><font face="Verdana"> Процесс поиска</font></h3>
<p><font face="Georgia">После того, как служба зарегистрирована в службе поиска 
  в процессе объединения, этот процесс становится доступным для использования 
  клиентами, которые ищут такую службу. Для построения распределенной системы 
  служб, которые работают совместно для выполнения некоторой задачи, клиент должен 
  найти и привлечь в помошь определенные службы. Для нахождения служб клиент опрашивает 
  службу поиска в процессе, называеммо <i>поиском</i></font>.</p>
<p><font face="Georgia">Для выполнения поиска, клиент задействует метод <b>lookup</b>(&nbsp;) 
  объекта-регистратора. (Клиент, такой как поставщик службы, получает объект-регистратор 
  в процессе обнаружения, описанном ранее.) Клиент передает в качестве аргумента 
  метода <b>lookup(&nbsp;)</b> <i>шаблон службы</i> - объект, являющийся критерием 
  поиска при опросе. Шаблон службы может включать ссылки на массив объектов типа 
  <b>Class</b>. Эти объекты типа <b>Class</b> указывают ищущей службе тип (или 
  типы) Java объекта службы, требуемые клиенту. Шаблон службы также может включать 
  <i>ID службы</i>, который уникально идентифицирует службу и атрибуты, которые 
  точно должны соответствовать атрибутам, загружаемым поставщиком службы в элемент 
  службы. Шаблон службы также может содержать подстановки ля любого из этих полей. 
  Например, подстановки в поле ID службы будет совпадать с любым ID службы. метод 
  <b>lookup(&nbsp;) </b>посылает шаблон службы службе поиска, которая выполняет 
  опрос и посылает назад ноль любому соответствующему объекту службы. Клиент получает 
  ссылку на совпавший объект обслуживания в качестве возвращаемого значения метода 
  <b>lookup(&nbsp;)</b>.</font></p>
<p><font face="Georgia">В общем случае клиент ищет сервис по типу Java, обычно 
  это интерфейс. Например, если клиенту необходимо использовать принтер, он должен 
  сравнивать шаблон сервиса, чтобы он включал объект <b>Class </b>с хорошо знакомым 
  интерфейсом служб печати. Все службы печати должны реализовывать этот хорошо 
  знакомый интерфейс. Служба поиска должна возвращать объект службы (или объекты), 
  которые реализуют этот интерфейс. Атрибуты могут включаться в шаблон службы, 
  чтобы сузить число совпадений для поиска, основывающегося на типе. Клиент должен 
  использовать службу печати, вызывая методы хорошо знакомого интерфейса службы 
  обслуживающего объекта.</font></p>
<a name="Heading595"></a> 
<h3 align="left"><font face="Verdana"> Разделение интерфейса и реализации</font></h3>
<p><font face="Georgia">Архитиктура Jini превносит объектно-ориентированное программирование 
  в сеть, позволяя получать доступ к сетевым службам используя одно из фундаментальных 
  свойств объектов: разделение интерфейса и реализации. Например, обслуживающий 
  объект может предоставить клиенту доступ к службе многими способами. Объект 
  может на самом деле представлять целую службу, которая загружается клиентом 
  во время поиска, а затем выполняется локально. С другой стороны, обслуживающий 
  объект может лишь замещать удаленную службу. Затем, когда клиент вызывает методы 
  обслуживающего объекта, он посылает запрос по сети к серверу, который выполняет 
  реальную работу. Третий вариант - это локальный обслуживающий объект и удаленный 
  сервер, каждый из которых выполняет часть работы.</font></p>
<p><font face="Georgia">Один важный вывод архитектуры Jini состоит в том, что 
  сетевой протокол, используемый для общения между представителем обслуживающего 
  объекта и удаленной службой не должен быть известен клиенту. Как показано на 
  приведенном ниже рисунке, сетевой протокол является частью реализации службы. 
  Этот протокол вырабатывается главным образом разработчиком службы. Клиент может 
  общаться со службой по этому протоколу, поскольку служба вводит некоторый свой 
  код (в объекте службы) в клиентское адресное пространство. Введенный обслуживающий 
  объект должен связываться со службой через RMI, CORBA, DCOM, некоторый смешанный 
  протокол, построенный на сокетах и потоках, или как-то еще. Клиенту просто не 
  нужно заботится о сетевом протоколе, поскольку он может общаться с хорошо знакомым 
  интерфейсом, реализованном обслуживающим объектом. Обслуживающий объект заботится 
  о всех необходимых сетевых коммуникациях.</font></p>
<div align="center"><font face="Georgia"><img src="Chapter15_files/TIJ229.gif"></font><br>
  <p></p>
</div>
<div align="center"> 
  <p><font face="Georgia"><b>Клиент общается с сервером через хорошо знакомый 
    интерфейс</b></font></p>
</div>
<font face="Georgia">Разные реализации одного и того же интерфейса службы могут 
использовать полностью различный подход и разные сетевые протоколы. Служба может 
использовать специализированные аппаратные средства для полного удовлетворения 
клиентским запросам или может делать всю работу в програмной части. Фактически, 
подход при реализации одной службы может измениться по прошествии времени. Клиент 
может быть уверен, что он имеет обслуживающий объект, который понимает текущую 
реализацию службы, поскольку клиент принимает обслуживающий объект (посредством 
службы поиска) от самого поставщика службы. С точки зрения клиента служба выглядит, 
как хорошо знакомый интерфейс, независимо от того, как эта служба реализована.</font><a name="_Toc481064920"></a><br>
<a name="Heading596"></a> 
<h3 align="left"><font face="Verdana"> Абстрагирование распределенной системы</font></h3>
<p><font face="Georgia">Jini пробует поднять уровень абстракции для программирования 
  распределенных систем с уровня сетевого протокола до уровня интерфейсов объектов. 
  При быстром распространении встроенных устройств, подсоединенных к сети, многие 
  части распределенной систмы могут поставляться различными производителями. Jini 
  делает необязательным для поставщиков приходить к соглашению на уровне сетевого 
  протокола, который позволяет устройствам взаимодействовать. Вместо этого производители 
  должны принять интерфейсы Java, через которые их устройство смоет взаимодействовать. 
  Процесс обнаружения, присоединения и поиска обеспечивается инфраструктурой Jini 
  времени выполнения, позволяющей устройствам находить друг друга в сети. Как 
  только они найдут друг друга, устройсвта могут общаться друг с другом посредствам 
  Java интерфейсов.</font></p>
<a name="Heading597"></a> 
<h2 align="left"><font face="Verdana"> Резюме</font></h2>
<p><font face="Georgia">Наряду с Jini <font color="#0000ff">для</font> локальных 
  сетевых устройств, <font color="#0000ff">эта</font> глава ввела некоторые, но 
  не все, компоненты, которые Sun называет J2EE: Java 2 Enterprise Edition. Целью 
  J2EE является построение множества инструментов, которые позволят Java разработчикам 
  строить приложения, основывающиеся на сервере, много быстрее и делать их платформонезависимыми. 
  Строить такие приложения не только сложно и долго, но особенно сложно строить 
  их так, чтобы они легко переносились на другие платформы, а также сохранить 
  бизнес-логику, отделив ее от лежащих в основе деталей реализации. J2EE обеспечивает 
  рабочее пространство, помогающее в создании приложений, работающих с сервером, 
  такие приложения теперь в моде, и потребность в них будет возрастать.</font><a name="_Toc375545500"></a><a name="_Toc481064922"></a></p>
<p><a name="Heading598"></a> </p>
<h2 align="left"><font face="Verdana"> Упражнения</font></h2>
<div align="left"> 
  <p><font face="Georgia" size="2">Решения для выбранных управжнений могут быть 
    найдены в электронной документации <i>The Thinking in Java Annotated Solution 
    Guide</i>, доступной за малую плату на <i>www.BruceEckel.com</i>.</font></p>
</div>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Скомпилируйте и запустите 
    программы <b>JabberServer</b> и <b>JabberClient</b> из этой главы. Теперь 
    измените файлы, удалив всю буфферизацию ввода и вывода, затем скомпилируйте 
    и запустите программу снова, чтобы увидеть результат.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте сервер, который 
    спрашивает пароль, а затем открывает файл и посылает его содержимое по сети. 
    Создайте клиента, который соединяется с сервером, выдает соответствующий пароль, 
    затем получает и записывает файл. Проверьте пару программ на вашей машине, 
    используя <b>localhost</b> (IP адрес заглушки <b>127.0.0.1</b> производится 
    вызовом <b>InetAddress.getByName(null)</b>).</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените сервер из Упражнения 
    2 так, чтобы он использовал множественные потоки для обслуживания множественных 
    клиентов.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените <b>JabberClient.java</b> 
    так, чтобы не происходил сброс буфера и пронаблюдайте эффект.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените <b>MultiJabberServer</b> 
    так, чтобы он использовал <i>накопление нитей</i> вместо выбрасывания нити 
    при каждом отключении клиента, нити должны помещать себя в “доступный 
    пул” нитей. Когда новый клиент хочет подключится, сервер должен искать 
    в доступном пуле нить для обработки запроса, и если нить не найдена, создавать 
    новую. Таким образом число необходимых нитей на самом деле будет больше необходимого 
    количества. Число накопленных нитей такое, что не требуется изишнего создания 
    и разрушения нити для каждого нового клиента.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Начав с <b>ShowHTML.java</b>, 
    создайте апплет, который является защищенным паролем шлюзом к определенной 
    части вашего Web сайта.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените <b>CIDCreateTables.java</b> 
    так, чтобы он читал SQL строки из текстового файла вместо <b>CIDSQL</b>.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Сконфигурируйте вашу систему 
    так, чтобы вы могли полностью удовлетворить <b>CIDCreateTables.java</b> и 
    <b>LoadDB.java</b>.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените <b>ServletsRule.java</b>, 
    переписав метод <b>destroy(&nbsp;)</b>, чтобы он записывал значение <b>i</b> 
    в файл, и метод <b>init(&nbsp;)</b>, чтобы он восстанавливал значение. Продемонстрируйте, 
    что он работает при перезапуске контейнера сервлетов. Если у вас нет контейнера 
    сервлетов, вы можете загрузить, установить и запустить Tomcat <a name="BBB"></a><i>jakarta.apache.org</i>, 
    чтобы запускать сервлеты.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте сервлет, который 
    добавляет cookie в объект ответа, таким образом сохраняя их на стороне клиента. 
    Добавьте в сервлет код, который находит и отображает cookie. </font><font face="Georgia">Если 
    у вас нет контейнера сервлетов, вы можете загрузить, установить и запустить 
    Tomcat <a name="BBB"></a><i>jakarta.apache.org</i>, чтобы запускать сервлеты.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте сервлет, который 
    использует объект <b>Session</b> для хранения информации о сессии по вашему 
    выбору. В том же сервлете найдите и отобразите эту информацию о сессии. </font><font face="Georgia">Если 
    у вас нет контейнера сервлетов, вы можете загрузить, установить и запустить 
    Tomcat <a name="BBB"></a><i>jakarta.apache.org</i>, чтобы запускать сервлеты.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте сервлет, который 
    изменяет интервал неактивности сессии на 5 секунд, с помощью вызова <b>getMaxInactiveInterval(&nbsp;)</b>. 
    Проверьте, чтобы убедится, что сессия не продолжается после 5 секунд. </font><font face="Georgia">Если 
    у вас нет контейнера сервлетов, вы можете загрузить, установить и запустить 
    Tomcat <a name="BBB"></a><i>jakarta.apache.org</i>, чтобы запускать сервлеты.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте JSP страницу, 
    печатающую строку текста, используя ярлык &lt;H1&gt;. Установите цвет этого 
    текста случайным образом, используя код Java, встроенный в JSP страницу. Если 
    у вас нет JSP контейнера, вы можете загрузить, установить и запустить Tomcat 
    <a name="BBB"></a><i>jakarta.apache.org</i>, чтобы запускать JSP.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените значение максимального 
    возраста в <b>Cookies.jsp</b> и пронаблюдайте поведение в двух разных браузерах. 
    Также обратите внимание на разницу между повторным посещением страницы и закрытием 
    и перезапуском броузера. </font><font face="Georgia">Если у вас нет JSP контейнера, 
    вы можете загрузить, установить и запустить Tomcat <a name="BBB"></a><i>jakarta.apache.org</i>, 
    чтобы запускать JSP.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте JSP с полями, 
    которая позволит пользователю вводить время действительности сессии, а второе 
    поле, которое содержит данные, хранимые в сессии. Кнопка отсылки обновляет 
    страницу и показывает текущее время истечения и данные сессии, затем помещает 
    их в качестве значений по умолчанию вышеупомянутых полей. </font><font face="Georgia">Если 
    у вас нет JSP контейнера, вы можете загрузить, установить и запустить Tomcat 
    <a name="BBB"></a><i>jakarta.apache.org</i>, чтобы запускать JSP.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">(Повышенной сложности) 
    Возьмите программу <b>VLookup.java</b> и изменте ее так, чтобы когда вы щелкали 
    на результирующее имя, она автоматически брала имя и копировала его в буфер 
    обмена (чтобы вы могли просто вставить его в ваш электронный адрес). Вам нужно 
    вновь обратиться к <a href=" Chapter13.html">Главе 13</a>, чтобы вспомнить 
    как использовать буфер обмена в JFC.<a name="Chapter_13"></a></font> 
</li></ol>
<hr>
<p><a name="fn72">[72]</a><font face="Georgia" size="2"> Это означает более четырех 
  миллиардов чисел, которые появляются повторно. Новый стандарт IP адресов будет 
  использовать 128-битовый номер, который должен производить достаточно уникальных 
  IP адресов в обозримом будующем.</font></p>
<p><a name="fn73">[73]</a><font face="Georgia" size="2"> Создано Dave Bartlett.</font></p>
<p><a name="fn74">[74]</a><font face="Georgia" size="2"> Dave Bartlett помогал в 
  разработке этого материала, а также раздела JSP.</font></p>
<p><a name="fn75">[75]</a><font face="Georgia" size="2"> Главная догма Эксремального 
  Программирования (Extreme Programming (XP)). Смотрите <i>www.xprogramming.com.</i></font></p>
<p><a name="fn76">[76]</a><font face="Georgia" size="2"> Многие клетки мозга умирают 
  в агонии при обнаружении этой информации.</font></p>
<p><a name="fn77">[77]</a><font face="Georgia" size="2"> Этот раздел вышел при содействии 
  Robert Castaneda с помошью Dave Bartlett.</font></p>
<p><a name="fn78">[78]</a><font face="Georgia" size="2"> Этот раздел вышел при содействии 
  Bill Venners (www.artima.com).</font></p>
<div align="center"><font face="Verdana" size="-1"> [ <a href=" Chapter14.html">Предыдущая 
  глава </a> ] [ <a href=" SimpleContents.html">Оглавление</a> ] [ <a href=" Contents.html">Содержание</a> 
  ] [ <a href=" DocIndex.html">Индекс</a> ] [ <a href=" AppendixA.html">Следующая 
  глава </a> ]</font> </div>
</body></html>