<html><head><!-- by.ru advertising --><script language="JavaScript" src="AppendixA_files/upper.js"></script><title>Thinking in Java, 2nd ed. Revision 11 - Приложение А.</title>

<meta http-equiv="description" content="Thinking in Java, 2nd edition. Приложение А. Копирование, передача, работа с объектами.">
<meta http-equiv="keywords" content="clone,string,метод,public,объект,java,new,int,x,object,system,объектов,класса,println,метода,class,объекта,out,класс,v,его,клонирования,return,ссылки,f,cloneable,копирования,который,super,o,является,arraylist,объекты,void,поскольку,образом,private,таким,main,можете,immutable2,классов,будет,клонирование,ли,этом,лишь,качестве,clonenotsupportedexception,том,tostring,ссылок,операции,tomato,char,ссылка,этот,приложение,a,stringbuffer,fruit,интерфейс,integer,вызов,новый,того,изменения,args,си,параметра,ordinary,0,всех,fruitqualities,копирование,for,y,за,их,myobject,возвращает">
<meta http-equiv="Content-type" content="text/html; charset=Windows-1251"></head>



<body bgcolor="#fcfcfc">
<p> <br>
</p><h1>Приложение А Передача и возврат объектов.</h1>
<hr>
<p><b>Как вы уже знаете, "передавая" объект в качестве параметра на самом деле 
вы оперируете лишь ссылками на этот объект.</b></p>
<p class="pad">Практически все языки программирования предоставляют набор "стандартных" 
средств для операций с объектами и в большинстве случаев они прекрасно работают. 
Однако всегда существует граница, когда эти средства перестают работать и работа 
существенно усложняется (или, в случае с Си++, предельно усложняется). Java в 
этом плане также не является исключением, поэтому очень важно чтобы вы четко 
представляли себе возможные последствия своих манипуляций с объектами, и 
"Приложение А" поможет Вам в этом.</p>
<p class="pad">Если у Вас есть опыт работы с другими языками программирования, то тему этого 
Приложения можно сформулировать как: "Есть ли в языке Java указатели?". Многие 
разработчики считают использование указателей чересчур сложным и опасным. 
Поскольку Java - самый совершенный язык программирования, созданный дабы 
избавить вас от рутины, в нем не должно быть подобных сомнительных элементов. 
Тем не менее, правильнее все же будет сказать что указатели в Java есть. 
Действительно, все идентификаторы объектов в Java (кроме примитивов) по 
сути&nbsp; являются указателями, но использование таких указателей ограничено и 
защищено, причем не только на этапе трансляции, но и на этапе исполнения. Иными 
словами, в Java есть указатели но отсутствуют арифметические операции над ними. 
В дальнейшем я буду называть их "ссылками", а вы можете думать о них как о 
"безопасных указателях". Они очень напоминают безопасные ножницы, применяемых на 
уроках труда в начальной школе - у них затупленные концы, которыми практически 
невозможно пораниться, но из-за этого работа с ними продвигается медленно и 
чрезвычайно утомительна.</p>
<h3><a name="Heading600"></a>Манипуляции с ссылками</h3>
<p class="pad">Передавая ссылку другому методу в качестве параметра, новая ссылка 
будет&nbsp; продолжать указывать на тот же самый объект. Следующий простейший 
пример наглядно это демонстрирует:</p>
<pre><font size="2"><font color="#009900">//: Приложение а:PassReferences.java</font>
<font color="#009900">// Передача ссылок.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> PassReferences {
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> f(PassReferences h) {
    System.out.println(<font color="#004488">"h внутри f(): "</font> + h);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    PassReferences p = <font color="#0000ff">new</font> PassReferences();
    System.out.println(<font color="#004488">"p внутри main(): "</font> + p);
    f(p);
  }
} <font color="#009900">///:~</font></font></pre>
<p class="pad">В этом примере при выводе результатов 
на экран автоматически вызывается метод <b>toString()</b>, а 
<b>PassReferences</b> наследуется непосредственно из класса <b>Object</b>, без 
переопределения метода <b>toString()</b>. Таким образом, при распечатке названия 
класса объекта и его адреса (не ссылки, а физического адреса по которому 
размещается объект) используется метод <b>toString()</b> класса <b>Object</b>. 
Результат работы примера: </p>
<pre><font size="2">  p внутри main(): PassReferences@1653748
  h внутри f(): PassReferences@1653748</font>
</pre>
<p class="pad">Как вы видете, <b>p</b> и <b>h</b> ссылаются на один и тот же объект. Это 
более эффективно чем дублирование самого объекта <b>PassReferences</b> лишь для 
передачи параметра методу, но в то же время сопряжено с серьезными 
проблемами.</p>
<h3><a name="Heading601"></a>Дублирующие ссылки (aliacing)</h3>
<p class="pad">Термин "дублирующие ссылки" означает что с одним и тем же объектом связана 
более чем одна ссылка. Проблема с дублирующими ссылками возникают при попытке 
<i>изменения данных</i> в объекте. Если владельцы других ссылок не ожидают что 
объект изменился, такой поворот судьбы может преподнести им неприятный сюрприз. 
Приведем пример:</p>
<pre><font size="2"><font color="#009900">//: Приложение А:Alias1.java</font>
<font color="#009900">// Две дублирующие ссылки на один и тот же объект.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Alias1 {
  <font color="#0000ff">int</font> i;
  Alias1(<font color="#0000ff">int</font> ii) { i = ii; }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Alias1 x = <font color="#0000ff">new</font> Alias1(7);
    Alias1 y = x; <font color="#009900">// Дублирующая ссылка</font>
    System.out.println(<font color="#004488">"x: "</font> + x.i);
    System.out.println(<font color="#004488">"y: "</font> + y.i);
    System.out.println(<font color="#004488">"Увеличиваем x"</font>);
    x.i++;
    System.out.println(<font color="#004488">"x: "</font> + x.i);
    System.out.println(<font color="#004488">"y: "</font> + y.i);
  }
} <font color="#009900">///:~</font></font></pre>
<p>В строке:</p>
<pre><font size="2">Alias1 y = x; <font color="#009900">// Дублирующая ссылка</font></font></pre>
<p class="pad">создается новая ссылка <b>Alias1</b>, но вместо того чтобы указывать на 
созданный с использованием команды <b>new</b> новый объект, ей присваивается 
значение уже существующей ссылки. Следовательно, содержимое ссылки <b>x</b> (то 
есть адрес расположения объекта,&nbsp;на который указывает эта ссылка) 
присваивается ссылке <b>y</b>. Таким образом обе ссылки <b>x</b> и <b>y</b> 
связаны с одним и тем же объектом и увеличение значения <b>x.i</b> в 
выражении:</p>
<pre><font size="2">x.i++;</font></pre>
<p>также повлечет за собой изменение значения <b>y.i</b>, что и наблюдается в 
результате выполнения примера:</p>
<pre><font size="2">x: 7
y: 7
Увеличиваем x
x: 8
y: 8</font></pre>
<p class="pad">Единственный способ избежать подобных ситуаций - отказ от использования 
дублирующих ссылок. Постарайтесь в своих программах не допускать одновременного 
существования более одной ссылки на один и тот же объект. Это сделает код ваших 
программ более удобочитаемым и простым в отладке. Однако, при передаче сслыки 
другому методу в качестве параметра (Java позволяет такие операции) эта ссылка 
автоматически дублируется и операции совершаемые с ней в методе могут влиять на 
состояние "внешнего" объекта (т.е. на объект, созданный вне данного метода). 
Например:</p>
<pre><font color="#009900" size="2">//: Приложение А:Alias2.java</font><font size="2">
<font color="#009900">// Вызванный метод изменяет внешний объект</font>
<font color="#009900">// используя передаваемую в качестве параметра ссылку.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Alias2 {
  <font color="#0000ff">int</font> i;
  Alias2(<font color="#0000ff">int</font> ii) { i = ii; }
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> f(Alias2 reference) {
    reference.i++;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Alias2 x = <font color="#0000ff">new</font> Alias2(7);
    System.out.println(<font color="#004488">"x: "</font> + x.i);
    System.out.println(<font color="#004488">"Вызов метода f(x)"</font>);
    f(x);
    System.out.println(<font color="#004488">"x: "</font> + x.i);
  }
} <font color="#009900">///:~</font></font></pre>
<p>Результатом будет:</p>
<pre><font size="2">x: 7
Вызов метода f(x)
x: 8</font></pre>
<p class="pad">Метод используя ссылку, передаваемую ему в качестве параметра, изменяет 
внешний объект. В подобных случаях вам следует предусмотреть все возможные 
негативные последствия, чтобы эти изменения не оказались неожиданностью для 
пользователя и не привели к сбоям в работе программы.</p>
<p class="pad">То есть, создавая метод, изменяющий внешние объекты, вы должны четко 
проинформировать пользователя о результатах его выполнения. Но, во избежание 
"волчьих ям", лучше воздерживаться от изменения внешних объектов.</p>
<p class="pad">Если вам все же необходимо внести изменения в объект, переданный в качестве 
параметра, но при этом вы не хотите изменять внешний объект (т.е. изменения 
будут внесены лишь на время выполнения данного метода), тогда вам следует 
предварительно скопировать его в вашем методе. Тому как это лучше сделать и 
будет посвящена большая часть этого Приложения.</p>
<h3><a name="Heading602"></a>Создание локальных копий объектов</h3>
<p class="pad">Итак, подведем итог вышеизложенному. В Java при передаче параметров методам 
используются ссылки, поэтому на самом деле "передавая объект" другому методу, на 
самом деле передается лишь ссылка на этот объект, а сам объект находится за 
пределами данного метода и все операции, совершаемые с этой ссылкой влекут за 
собой изменения во внешнем объекте. И еще:</p>
<ul>
  
<li>При передаче параметров методу автоматически создаются дублирующие ссылки. 

  
</li><li>Не бывает локальных объектов, бывают только локальные ссылки. 
  
</li><li>У ссылок есть "границы видимости", а у объектов их нет. 
  
</li><li>В Java программист не может управлять временем жизни объектов. 
  
</li><li>В Java нет средств (таких, как константы) для защиты объекта от изменений 
  (например для защиты от негативных последствий использования дублирующих 
  ссылок). </li>
</ul>
<p class="pad">Если вы используете объект только для чтения, можете смело передавать ссылку 
на объект. Однако, иногда возникает необходимость работы с объектом на 
"локальном уровне" таким образом, чтобы все вносимые в объект изменения 
распространялись только на его локальную копию и не изменяли внешний объект. Во 
многих языках программирования существуют механизмы автоматического создания 
локальных копий внешнего объекта при работе с методом [<a href="file:///C:/out/AppendixA1.htm#%5B79%5D">79</a>]. В Java таких механизмов нет, 
но зато есть все необходимые для этого средства.</p>
<h4><a name="Heading603"></a>Передача параметров "по значению"</h4>
<p class="pad">Тут необходимо внести ясность в 
понимание термина "передача параметров по значению" и то как он реализуется в 
программе. Суть метода заключается в использовании локальных копий параметров, 
передаваемых вашему методу. Камнем преткновения является различное отношение к 
передаваемым параметрам. Существуют два наиболее распространенных взгляда на 
параметры:</p>
<ol>
  
<li>В Java все параметры передаются по 
  значению. Передавая методу примитивы, вы получаете локальную копию примитивов, 
  передавая методу ссылку, вы получаете локальную копию ссылки. Итак, все 
  передается по значениям. Разумеется, при таком подходе требуется постоянно 
  помнить о том, что вы работаете лишь с ссылками. Однако Java разработан таким 
  образом, что (в большинстве случаев) позволяет вам забыть о том что вы 
  работаете лишь с ссылками и думать о ссылках как об "объектах", но лишь до тех 
  пор, пока вы не попытаетесь вызвать какой-нибудь метод. 
  
</li><li>Примитивы в Java передаются по 
  значению, а объекты передаются как ссылки. Это общепринятый взгляд на ссылки. 
  При таком подходе вам <i>не надо</i> думать о параметрах как о ссылках. В 
  таком случае вы можете утверждать: "Я передаю объект". Поскольку при передаче 
  объекта в метод вы не создаете его локальную копию, нельзя сказать что объекты 
  передаются по значению. Возможно в будущем компания Sun предложит какое-нибудь 
  решение этой проблемы. В Java зарезервировано, но пока не использовано 
  ключевое слово <b>byvalue</b> (по значению), но на сегодняшний день нет 
  никакой официальной информации о том, будет ли вообще когда-нибудь 
  использовано это ключевое слово. </li>
</ol>
<p class="pad">Итак, рассмотрев обе точки зрения, я 
скажу так: "Все это зависит лишь от вашего представления о ссылках." Теперь 
вернемся к нашей проблеме. В конце концов, это <i>не так важно</i>, гораздо 
важнее понимание того, что передача ссылок в качестве параметров может привести 
к неожиданным изменениям внешних объектов.</p>
<h4><a name="Heading604"></a>Клонирование объектов</h4>
<p class="pad">Наиболее часто клонирование применяется в тех случаях, когда в процессе 
работы метода необходимо внести изменения в объект, не изменяя при этом внешний 
объект. Для создания локальной копии объекта надо воспользоваться методом 
<b>clone()</b>. Это защищенный (<b>protected</b>) метод базового класса 
<b>Object</b> и все что от вас требуется, это переопределить его как 
<b>public</b> во всех классах, которые вы собираетесь клонировать. Например, 
переопределим метод <b>clone()</b> для класса стандартной библиотеки 
<b>ArrayList</b>, для дальнейшего использования <b>clone()</b> применительно к 
<b>ArrayList</b>:</p>
<pre><font size="2"><font color="#009900">//: Приложение А:Cloning.java</font>
<font color="#009900">// Операция clone() работает только для</font>
<font color="#009900">// нескольких элементов стандартной библиотеки Java.</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">class</font> Int {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> i;
  <font color="#0000ff">public</font> Int(<font color="#0000ff">int</font> ii) { i = ii; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> increment() { i++; }
  <font color="#0000ff">public</font> String toString() { 
    <font color="#0000ff">return</font> Integer.toString(i); 
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Cloning {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    ArrayList v = <font color="#0000ff">new</font> ArrayList();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i++ )
      v.add(<font color="#0000ff">new</font> Int(i));
    System.out.println(<font color="#004488">"v: "</font> + v);
    ArrayList v2 = (ArrayList)v.clone();
    <font color="#009900">// Увеличение всех элементов v2:</font>
    <font color="#0000ff">for</font>(Iterator e = v2.iterator();
        e.hasNext(); )
      ((Int)e.next()).increment();
    <font color="#009900">// Проверка изменения элементов v:</font>
    System.out.println(<font color="#004488">"v: "</font> + v);
  }
} <font color="#009900">///:~</font></font></pre>
<p class="pad">Метод <b>clone()</b> создает объект типа <b>Object</b>, который затем должен 
быть преобразован в объект нужного типа. Из примера видно что метод 
<b>clone()</b> объекта <b>ArrayList</b> <i>не выполняет</i> автоматическое 
клонирование всех объектов, которые содержатся в <b>ArrayList</b> - старый 
<b>ArrayList</b> и клонированный <b>ArrayList</b> являются дублирующими ссылками 
одного и того же объекта. Это так называемое <i>поверхностное копирование</i>, 
когда копируется только "поверхность" объекта. Сам объект содержит так 
называемую "поверхность" плюс все те объекты, на которые указывают ссылки внутри 
него, плюс все те объекты, на которые в свою очередь ссылаются <i>те</i> 
объекты, и т.д. Такое явление называется "сетью объектов", а полное копирование 
всей этой сложной структуры называется <i>глубоким копированием</i>.</p>
<p class="pad">В приведенном выше примере вы можете наблюдать результат поверхностного 
копирования, при котором операции, совершаемые с <b>v2</b> отражаются на 
состоянии <b>v</b>:</p>
<p>v: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&nbsp;<br>
v: [1, 2, 3, 4, 5, 6, 7, 8, 9, 
10]</p>
<p class="pad">Не следует использовать <b>clone()</b> для клонирования объектов, 
содержащихся в <b>ArrayList</b>, поскольку нет никаких гарантий что эти объекты 
будут клонируемыми (cloneable) [<a href="file:///C:/out/AppendixA1.htm#%5B80%5D">80</a>].</p>
<h4><a name="Heading605"></a>Добавление клонируемости в класс</h4>
<p class="pad">Несмотря на то что метод клонирования определен в классе <b>Object</b>, 
являющемся базовым для всех классов Java, это <i>не</i> означает что он 
автоматически может быть применен к любому классу [<a href="file:///C:/out/AppendixA1.htm#%5B81%5D">81</a>]. Казалось бы, это идет в 
разрез с принципом наследования дочерними объектами методов родительских 
классов. Действительно, в Java клонирование идет вразрез с этим принципом. 
Поэтому, если вы хотите сделать эту функцию доступной для вашего класса, вы 
должны написать соответствующий код, обеспечивающий правильную работу метода 
клонирования.</p>
<h5><a name="Heading606"></a>Использование приема с protected</h5>
<p class="pad">Для блокирования возможности клонирования во всех классах Java, в базовом 
классе <b>Object</b> метод <b>clone()</b> был описан как защищенный 
(<b>protected</b>). Это не только исключает возможность использования метода 
клонирования&nbsp;программистом, просто использующим (не расширяющим) этот 
класс, но и означает что вы не можете использовать <b>clone()</b> используя 
ссылку на базовый класс. (Хотя это может показаться полезным. Например, при 
полиморфном клонировании связок классов <b>Object</b>). Такой метод применен для 
того, чтобы на этапе компиляции информировать о том что данный объект является 
неклонируемым. Как ни странно, большинство классов стандартных библиотек Java 
неклонируемые. Поэтому, написав:</p>
<p>Integer x = <b><font color="#0000ff">new</font></b> <b>Integer(1);</b><br>
x = 
<b>x.clone();</b></p>
<p class="pad">на этапе компиляции это приведет к возникновению ошибки. Компилятор выдаст 
сообщение о том что метод <b>clone()</b> недоступен (поскольку <b>Integer</b> не 
переопределяет его и он по умолчанию является защищенным (<b>protected</b>)). 
Однако, если вы&nbsp;работаете с классом, производным от&nbsp; <b>Object</b> (а 
это все классы языка Java), то у вас есть возможность вызвать метод 
<b>Object.clone()</b>, поскольку этот метод является защищенным 
(<b>protected</b>), а ваш объект является объектом-наследником по отношению к 
классу <b>Object</b>. Метод <b>clone() </b>класса <b>Object</b> обладает 
полезными функциональными возможностями - он осуществляет поразрядное 
дублирование <i>передаваемого класса объекта</i>, что и является основной 
операцией при клонировании объекта. Тем не менее вам будет необходимо написать 
<i>собственный</i> метод клонирования и описать ее как <b>public</b>. Итак, два 
ключевых момента при реализации клонировании это:</p>
<ul>
  
<li>обязательный вызов метода <b>super.clone()</b> 
  
</li><li>написание собственного <b>public</b> метода клонирования&nbsp; </li>
</ul>
<p class="pad">В дальнейшем вам возможно понтребуется переопределить ваш метод <b>clone() 
</b>для классов-наследников, поскольку иначе при их клонировании будет 
использоваться ваш (теперь уже <b>public</b>) метод <b>clone()</b>, который 
может не выполнять своих функций для этих классов (хотя, поскольку создание 
копии самого объекта осуществляет метод <b>Object.clone()</b>, подобных проблем 
может и не быть). Такой прием с переопределением защищенного (<b>protected</b>) 
метода <b>clone()</b> может применяться только когда вы наследуете не 
клонируемый класс и хотите на его базе создать класс, поддерживающий 
клонирование. При этом для все классы, наследующие ваш класс, в свою очередь 
унаследуют и созданный вами метод <b>clone()</b>, поскольку в Java нельзя 
изменять статус наследуемых методов. Иными словами, если ваш класс является 
клонируемым, то и все наследующие его классы также будут клонируемыми, если 
только вы не примените приемы "отключения" клонируемости (они подробно 
рассмотрены далее).</p>
<h5><a name="Heading607"></a>Реализация интерфейса Cloneable</h5>
<p class="pad">Для создания клонируемых объектов вам понадобятся навыки реализации 
<b>Cloneable интерфейса</b>. Этот интерфейс примечателен уже тем, что он 
совершенно пустой!</p>
<p><font color="#0000ff">interface</font> Cloneable {}</p>
<p class="pad">Очевидно, что причины наследования пустого интерфейса никак не связаны с 
последующим использованием его методов. В данном случае интерфейс используется в 
нестандартных целях. Он служит своего рода "меткой" для типа класса. Существуют 
две причины существования интерфейса <b>Cloneable</b>. Первая заключается в том, 
что вы можете использовать ссылки на базовый тип и при этом не знать, является 
ли он клонируемым или нет. В таких случаях вы можете использовать ключевое слово 
<b>instanceof</b> (рассмотренное в главе 12) для выяснения, является ли объект с 
которым связана ссылка клнируемым:</p>
<p><font color="#0000ff">if</font>(myReference <font color="#0000ff">instanceof</font> Cloneable) <font color="#009900">// ...</font></p>
<p class="pad">Вторая причина связана с вышеупомянутой блокировкой клонирования в классах. 
Перед началом работы метод <b>Object.clone()</b> осуществляет проверку класса на 
реализацию интерфейса <b>Cloneable</b> и, если класс не реализует этот 
интерфейс, возвращает значение <b>CloneNotSupportedException</b>. Поэтому для 
поддержки клонирования вы вынуждены реализовать интерфейс <b>Cloneable</b>.</p>
<h4><a name="Heading608"></a>Успешное клонирование</h4>
<p class="pad">Теперь, когда вы познакомились с нюансами реализации метода <b>clone()</b>, 
можно приступить к созданию классов, дублируемых с созданием локальных 
копий.</p>
<pre><font size="2"><font color="#009900">//: Приложение А:LocalCopy.java</font>
<font color="#009900">// Создание локальных копий используя метод clone().</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">class</font> MyObject <font color="#0000ff">implements</font> Cloneable {
  <font color="#0000ff">int</font> i;
  MyObject(<font color="#0000ff">int</font> ii) { i = ii; }
  <font color="#0000ff">public</font> Object clone() {
    Object o = <font color="#0000ff">null</font>;
    <font color="#0000ff">try</font> {
      o = <font color="#0000ff">super</font>.clone();
    } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
      System.err.println(<font color="#004488">"MyObject не может быть клонирован"</font>);
    }
    <font color="#0000ff">return</font> o;
  }
  <font color="#0000ff">public</font> String toString() {
    <font color="#0000ff">return</font> Integer.toString(i);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> LocalCopy {
  <font color="#0000ff">static</font> MyObject g(MyObject v) {
    <font color="#009900">// Передача ссылки, которая изменяет внешний объект:</font>
    v.i++;
    <font color="#0000ff">return</font> v;
  }
  <font color="#0000ff">static</font> MyObject f(MyObject v) {
    v = (MyObject)v.clone(); <font color="#009900">// Локальная копия</font>
    v.i++;
    <font color="#0000ff">return</font> v;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    MyObject a = <font color="#0000ff">new</font> MyObject(11);
    MyObject b = g(a);
    <font color="#009900">// Проверка ссылок (не объектов) на равенство</font>
    <font color="#0000ff">if</font>(a == b) 
      System.out.println(<font color="#004488">"a == b"</font>);
    <font color="#0000ff">else</font> 
      System.out.println(<font color="#004488">"a != b"</font>);
    System.out.println(<font color="#004488">"a = "</font> + a);
    System.out.println(<font color="#004488">"b = "</font> + b);
    MyObject c = <font color="#0000ff">new</font> MyObject(47);
    MyObject d = f(c);
    <font color="#0000ff">if</font>(c == d) 
      System.out.println(<font color="#004488">"c == d"</font>);
    <font color="#0000ff">else</font> 
      System.out.println(<font color="#004488">"c != d"</font>);
    System.out.println(<font color="#004488">"c = "</font> + c);
    System.out.println(<font color="#004488">"d = "</font> + d);
  }
} <font color="#009900">///:~</font></font></pre>
<p class="pad">Прежде всего, метод <b>clone()</b> должен быть общедоступным, т.е. должен 
быть переопределен как <b>public</b>. Во-вторых, в первых строках вашего метода 
<b>clone()</b> должен находиться вызов базового метода <b>clone()</b>. 
Вызываемый таким образом метод <b>clone()</b> принадлежит классу <b>Object</b>, 
и вы имеете возможность его вызова, поскольку он определен как <b>protected</b> 
и потому доступен для дочерних классов.</p>
<p class="pad">Метод <b>Object.clone()</b> определяет размер объекта, выделяет необходимое 
количество свободной памяти для создания копии и осуществляет побитное 
копирование. Эта процедура называется <i>поразрядным копированием</i> и является 
сутью клонирования. Но перед выполнением этих операций <b>Object.clone()</b> 
выполняет проверку, является ли копируемый объект клонируемым - то есть, 
реализует ли он интерфейс <b>Cloneable</b>. Если нет - <b>Object.clone()</b> 
возвращает исключительную ситуацию <b><font color="#000000">CloneNotSupportedException</font></b>, сигнализирующую о том, что 
данный объект не может быть клонирован. Таким образом вы должны поместить вызов 
метода <b><font color="#000000">super.clone( )</font></b> в блок операторов 
<b>try</b>-<b>catch</b>, чтобы перехватывать и обрабатывать подобные ситуации, 
которые не должны возникнуть (поскольку вы реализуете интерфейс 
<b>Clonable</b>).</p>
<p class="pad">В приведенном выше примере методы <b>g()</b> и <b>f()</b> класса 
<b>LocalCopy</b> демонстрируют различие между двумя способами передачи 
параметра. <b>g()</b>&nbsp;демонстрирует передачу по ссылке, которую он изменяет 
вне объекта, а затем возвращается ссылка на этот внешний объект. <b>f()</b> 
клонирует параметр, а затем отключает его, таким образом оставляя лишь 
первоначальный объект. После этого с объектом могут совершаться любые операции, 
вплоть до возвращения ссылки на него, и это никак не отразится на 
объекте-оригинале. Обратите свое внимание на любопытное выражение:</p>
<p>v = (MyObject)v.clone();</p>
<p class="pad">Именно таким образом осуществляется локальная копия. Чтобы предотвратить 
неразбериху, связанную с использованием такого выражения, хорошо запомните что 
такая довольно необычная идиома вполне типична для Java, поскольку все 
идентификаторы объектов являются ссылками. Поэтому ссылка <b>v</b> с помощью 
метода <b>clone() </b>используется для создания копии объекта, на который она 
ссылается, и в результате данной операции возвращается ссылка на базовый тип 
<b>Object</b> (поскольку он обозначен таким образом в <b>Object.clone()</b>) и 
должен затем быть приведен к соответствующему типу.</p>
<p>Выполнение <b>main()</b> позволяет наблюдать разницу между этими двумя 
методами передачи:</p>
<pre><font size="2">a == b
a = 12
b = 12
c != d
c = 47
d = 48</font></pre>
<p class="pad">Важно отметить что при проверке на равенство ссылок в Java не происходит 
сравнения самих значений переменных, содержащихся в этих объектах. Операторы == 
и != просто сравнивают сами <i>ссылки</i>. Если адреса ссылок совпадают, значит 
обе ссылки указывают на один и тот же объект и следовательно они "равны". Таким 
образом, на самом деле операторы лишь проверяют, являются ли ссылки дублирующими 
ссылками на один и тот же объект.</p>
<h3><a name="Heading609"></a>Функции метода Object.clone()</h3>
<p class="pad">Что же происходит при вызове <b>Object.clone()</b> и чем вызвана 
необходимость вызова метода <b>super.clone()</b> при переопределении метода 
<b>clone()</b> в вашем классе? Метод <b>clone()</b> базового класса отвечает за 
выделение необходимого количества памяти для хранения и поразрядного копирования 
битов из базового класса в новый объект. Но это не просто хранение и копирование 
объекта, а скорее полное воссоздание внешнего объекта.</p>
<p class="pad">Все эти операции описаны в коде метода <b>clone</b> базового класса (который 
был написан при отсутствии какой-либо информации о структуре классов, которые 
будут его наследовать), можно предположить что для определения клонируемого 
объекта использована технология RTTI. как бы там ни было, метод <b>clone()</b> 
может осуществлять операции по выделению памяти и осуществлять копирование 
классов этого типа.</p>
<p class="pad">Что бы вы ни делали, первой операцией вашего метода <b>clone()</b> должен 
быть вызов метода <b>super.clone()</b>. Эта операция является основой операции 
клонирования и обеспечивает создание точного дубликата. Далее могут следовать 
другие операции, необходимые для завершения клонирования.</p>
<p class="pad">Для того, чтобы определиться в этой операции вы должны четко представлять 
себе что выполняет <b>Object.clone()</b>. В частности, осуществляет ли он 
автоматическое копирование объектов, на которые указывают ссылки? Ответ на этот 
вопрос мы получим из следующего примера:</p>
<pre><font size="2"><font color="#009900">//: Приложение А:Snake.java</font>
<font color="#009900">// Тестирует клонирование для определения</font>
<font color="#009900">// было ли клонировано содержание ссылок на другие объекты</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Snake <font color="#0000ff">implements</font> Cloneable {
  <font color="#0000ff">private</font> Snake next;
  <font color="#0000ff">private</font> <font color="#0000ff">char</font> c;
  <font color="#009900">// Значение i == количеству сегментов</font>
  Snake(<font color="#0000ff">int</font> i, <font color="#0000ff">char</font> x) {
    c = x;
    <font color="#0000ff">if</font>(--i &gt; 0)
      next = <font color="#0000ff">new</font> Snake(i, (<font color="#0000ff">char</font>)(x + 1));
  }
  <font color="#0000ff">void</font> increment() {
    c++;
    <font color="#0000ff">if</font>(next != <font color="#0000ff">null</font>)
      next.increment();
  }
  <font color="#0000ff">public</font> String toString() {
    String s = <font color="#004488">":"</font> + c;
    <font color="#0000ff">if</font>(next != <font color="#0000ff">null</font>)
      s += next.toString();
    <font color="#0000ff">return</font> s;
  }
  <font color="#0000ff">public</font> Object clone() {
    Object o = <font color="#0000ff">null</font>;
    <font color="#0000ff">try</font> {
      o = <font color="#0000ff">super</font>.clone();
    } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
      System.err.println(<font color="#004488">"Змея не может быть клонирована"</font>);
    }
    <font color="#0000ff">return</font> o;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Snake s = <font color="#0000ff">new</font> Snake(5, 'a');
    System.out.println(<font color="#004488">"s = "</font> + s);
    Snake s2 = (Snake)s.clone();
    System.out.println(<font color="#004488">"s2 = "</font> + s2);
    s.increment();
    System.out.println(
      <font color="#004488">"after s.increment, s2 = "</font> + s2);
  }
} <font color="#009900">///:~</font></font></pre>
<p class="pad"><font size="2">&nbsp;</font>Объект <b>Snake</b> (змея) состоит из нескольких 
сегментов, каждый из которых также принадлежит типу <b>Snake</b> и по сути 
представляет собой связанный одиночными связями список. Сегменты создаются 
рекурсивно с уменьшением значения первого параметра конструктора до тех 
пор,&nbsp; пока тот не примет нулевое значение. Для того, чтобы присвоить 
каждому сегменту уникальную метку, при каждом очередном рекурсивном вызове 
конструктора значение второго параметра конструктора типа <b>char</b> 
увеличивается.</p>
<p class="pad">Метод <b>increment()</b> рекурсивно увеличивает каждую метку, а метод 
<b>toString()</b> рекурсивно печатает каждую метку:</p>
<p>s = :a:b:c:d:e<br>
s2 = :a:b:c:d:e<br>
после s.increment, s2 = :a:c:d:e:f</p>
<p class="pad">Это означает что метод <b>Object.clone()</b> создал дубликат только первого 
сегмента, то есть осуществил поверхностное копирование. Если вы хотите создать 
дубликат всей змеи (произвести глубокое копирование), вам понадобится включить 
дополнительный код в переопределенный метод clone().</p>
<p class="pad">Для этого вы, как всегда, должны вызвать метод <b>super.clone()</b>, чтобы 
быть уверенными что для любого унаследованного от клонируемого класса будут 
выполнены все необходимые операции (включая вызов метода <b>Object.clone()</b>). 
Затем требуется явный вызов метода <b>clone()</b> для всех ссылок, 
присутствующих в вашем объекте, иначе эти ссылки окажутся всего лишь 
дублирующими ссылками на исходные объекты. Это аналогично тому как 
осуществляется вызов конструктора: сначала конструктор базового класса, а затем 
конструктор его ближайшего класса-наследника. и так далее вплоть до вызова 
конструктора самого удаленного класса. Разница заключается в том, что метод 
<b>clone()</b> не является конструктором и поэтому ничто в нем не происходит 
автоматически. Вам придется реализовать эти функции самостоятельно.</p>
<h4><a name="Heading610"></a>Клонирование составных объектов</h4>
<p class="pad">Существует одна проблема, с которой вам придется столкнуться при реализации 
глубокого копирования составных объектов. Вы должны предусмотреть выполнение 
методом <b>clone()</b> глубокого копирования ссылок для составляющих его 
объектов, а затем, в свою очередь, для ссылок <i>этих</i> объектов и так далее. 
Это необходимое условие глубокого копирования. Таким образом, вы должны владеть, 
или по крайней мере, располагать достаточными знаниями о коде всех классов, 
участвующих в глубоком копировании и быть уверенными в том что их собственные 
механизмы глубокого&nbsp;копирования работают безотказно.</p>
<p class="pad">Следующий пример показывает последовательность операций для осуществления 
глубокого копирования составного объекта:</p>
<pre><font size="2"><font color="#009900">//: Приложение А:DeepCopy.java</font>
<font color="#009900">// Клонирование составных объектов</font>

<font color="#0000ff">class</font> DepthReading <font color="#0000ff">implements</font> Cloneable {
  <font color="#0000ff">private</font> <font color="#0000ff">double</font> depth;
  <font color="#0000ff">public</font> DepthReading(<font color="#0000ff">double</font> depth) { 
    <font color="#0000ff">this</font>.depth = depth;
  }
  <font color="#0000ff">public</font> Object clone() {
    Object o = <font color="#0000ff">null</font>;
    <font color="#0000ff">try</font> {
      o = <font color="#0000ff">super</font>.clone();
    } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
      e.printStackTrace(System.err);
    }
    <font color="#0000ff">return</font> o;
  }
}

<font color="#0000ff">class</font> TemperatureReading <font color="#0000ff">implements</font> Cloneable {
  <font color="#0000ff">private</font> <font color="#0000ff">long</font> time;
  <font color="#0000ff">private</font> <font color="#0000ff">double</font> temperature;
  <font color="#0000ff">public</font> TemperatureReading(<font color="#0000ff">double</font> temperature) {
    time = System.currentTimeMillis();
    <font color="#0000ff">this</font>.temperature = temperature;
  }
  <font color="#0000ff">public</font> Object clone() {
    Object o = <font color="#0000ff">null</font>;
    <font color="#0000ff">try</font> {
      o = <font color="#0000ff">super</font>.clone();
    } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
      e.printStackTrace(System.err);
    }
    <font color="#0000ff">return</font> o;
  }
}

<font color="#0000ff">class</font> OceanReading <font color="#0000ff">implements</font> Cloneable {
  <font color="#0000ff">private</font> DepthReading depth;
  <font color="#0000ff">private</font> TemperatureReading temperature;
  <font color="#0000ff">public</font> OceanReading(<font color="#0000ff">double</font> tdata, <font color="#0000ff">double</font> ddata){
    temperature = <font color="#0000ff">new</font> TemperatureReading(tdata);
    depth = <font color="#0000ff">new</font> DepthReading(ddata);
  }
  <font color="#0000ff">public</font> Object clone() {
    OceanReading o = <font color="#0000ff">null</font>;
    <font color="#0000ff">try</font> {
      o = (OceanReading)<font color="#0000ff">super</font>.clone();
    } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
      e.printStackTrace(System.err);
    }
    <font color="#009900">// Необходимо клонировать ссылку:</font>
    o.depth = (DepthReading)o.depth.clone();
    o.temperature = 
      (TemperatureReading)o.temperature.clone();
    <font color="#0000ff">return</font> o; <font color="#009900">// Передаем его в Object</font>
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> DeepCopy {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    OceanReading reading = 
      <font color="#0000ff">new</font> OceanReading(33.9, 100.5);
    <font color="#009900">// Теперь клонируем его:</font>
    OceanReading r = 
      (OceanReading)reading.clone();
  }
} <font color="#009900">///:~</font></font></pre>
<p class="pad">Классы <b>DephReading</b> (измерение глубины) и <b>TemperatureReading</b> 
(измерение температуры) очень похожи, они оба содержат только примитивы. 
Следовательно и метод <b>clone()</b> для этих классов также предельно прост: он 
вызывает <b>super.clone()</b> и возвращает результат. Заметьте что&nbsp; код для 
обоих методов <b>clone()</b> абсолютно идентичен.</p>
<p class="pad"><b>OceanReading</b> (исследование океана) состоит из объектов 
<b>DephReading</b> и <b>TemperatureReading</b> и поэтому, для выполнения 
глубокого копирования, его метод <b>clone()</b> должен клонировать все ссылки 
внутри класса <b>OceanReading</b>. Для выполнения этой задачи результат 
<b>super.clone()</b> должен возвращать ссылку на объект <b>OceanReading</b> 
(таким образом, вы получите доступ к ссылкам на объекты глубины и 
температуры).</p>
<h4><a name="Heading611"></a>Глубокое копирование при помощи ArrayList</h4>
<p class="pad">Давайте повторно рассмотрим приведенный ранее в этом приложении пример с 
<b>ArrayList</b>. Теперь класс <b>Int2</b> - клонируемый и можно произвести 
глубокое копирование <b>ArrayList</b>:</p>
<pre><font size="2"><font color="#009900">//: Приложение А: AddingClone.java</font>
<font color="#009900">// Для добавления клонирования в ваш класс</font>
<font color="#009900">// потребуется несколько циклов.</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">class</font> Int2 <font color="#0000ff">implements</font> Cloneable {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> i;
  <font color="#0000ff">public</font> Int2(<font color="#0000ff">int</font> ii) { i = ii; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> increment() { i++; }
  <font color="#0000ff">public</font> String toString() {
    <font color="#0000ff">return</font> Integer.toString(i);
  }
  <font color="#0000ff">public</font> Object clone() {
    Object o = <font color="#0000ff">null</font>;
    <font color="#0000ff">try</font> {
      o = <font color="#0000ff">super</font>.clone();
    } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
      System.err.println(<font color="#004488">"Int2 не может быть клонирован"</font>);
    }
    <font color="#0000ff">return</font> o;
  }
}

<font color="#009900">// Поскольку он клонируемый, наследование</font>
<font color="#009900">// не сделает его не клонируемым:</font>
<font color="#0000ff">class</font> Int3 <font color="#0000ff">extends</font> Int2 {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> j; <font color="#009900">// Автоматически дублируется</font>
  <font color="#0000ff">public</font> Int3(<font color="#0000ff">int</font> i) { <font color="#0000ff">super</font>(i); }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> AddingClone {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Int2 x = <font color="#0000ff">new</font> Int2(10);
    Int2 x2 = (Int2)x.clone();
    x2.increment();
    System.out.println(
      <font color="#004488">"x = "</font> + x + <font color="#004488">", x2 = "</font> + x2);
    <font color="#009900">// Все наследники также являются клонируемыми:</font>
    Int3 x3 = <font color="#0000ff">new</font> Int3(7);
    x3 = (Int3)x3.clone();

    ArrayList v = <font color="#0000ff">new</font> ArrayList();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i++ )
      v.add(<font color="#0000ff">new</font> Int2(i));
    System.out.println(<font color="#004488">"v: "</font> + v);
    ArrayList v2 = (ArrayList)v.clone();
    <font color="#009900">// Теперь клонируем каждый элемент:</font>
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; v.size(); i++)
      v2.set(i, ((Int2)v2.get(i)).clone());
    <font color="#009900">// Увеличиваемзначения всех элементов v2:</font>
    <font color="#0000ff">for</font>(Iterator e = v2.iterator();
        e.hasNext(); )
      ((Int2)e.next()).increment();
    <font color="#009900">// Смотрим, изменились ли значения элементов v:</font>
    System.out.println(<font color="#004488">"v: "</font> + v);
    System.out.println(<font color="#004488">"v2: "</font> + v2);
  }
} <font color="#009900">///:~</font></font></pre>
<p class="pad"><b>Int3</b> наследует <b>Int2</b> и добавляет новый примитив <b>int j</b>. 
Вам может показаться что снова потребуется переопределение метода <b>clone()</b> 
для обеспечения копирования <b>j</b>, но в данном случае это не так. Когда при 
вызове метода <b>clone()</b> класса <b>Int3</b> вызывается метод <b>clone()</b> 
класса <b>Int2</b>, а он в свою очередь вызывает метод <b>Object.clone()</b>, 
который определяет что работает с классом <b>Int3</b> и создает побитовый 
дубликат&nbsp; класса <b>Int3</b>. Таким образом, до тех пор, пока вы не 
используете в своем объекте ссылки, которые требуют клонирования, достаточно 
одного вызова метода <b>Object.clone()</b>, независимо от того насколько этот 
метод удален от вашего класса по иерархии объектов.</p>
<p class="pad">Как видите, для глубокого копирования <b>ArrayList</b> требуется 
последовательное выполнение операции клонирования для всех объектов, на которые 
ссылается <b>ArrayList</b>. Нечто подобное требуется и для глубокого 
клонирования <b>HashMap</b>.</p>
<p class="pad">Остальная часть примера нужна в качестве демонстрации успешного клонирования, 
показывая что изменения, вносимые в клонированные объекты, не отражаются на 
состоянии исходных объектов.</p>
<h4><a name="Heading612"></a>Глубокое копирование при помощи сериализации (serialization)</h4>
<p class="pad">Изучая преобразование в последовательную форму серийности в Java 
(рассмотренную в Главе 11), вы могли обратить внимание на то, что при серийности 
и десерйности объектов фактически выполняется операция клонирования.</p>
<p class="pad">Так почему бы не использовать серийность для глубокого копирования? Следующий 
пример сравнивает эти два метода по затратам времени:</p>
<blockquote>
<pre><font size="2"><font color="#009900">//: Приложение А:Compete.java</font>
<font color="#0000ff">import</font> java.io.*;

<font color="#0000ff">class</font> Thing1 <font color="#0000ff">implements</font> Serializable {}
<font color="#0000ff">class</font> Thing2 <font color="#0000ff">implements</font> Serializable {
  Thing1 o1 = <font color="#0000ff">new</font> Thing1();
}

<font color="#0000ff">class</font> Thing3 <font color="#0000ff">implements</font> Cloneable {
  <font color="#0000ff">public</font> Object clone() {
    Object o = <font color="#0000ff">null</font>;
    <font color="#0000ff">try</font> {
      o = <font color="#0000ff">super</font>.clone();
    } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
      System.err.println(<font color="#004488">"Thing3 не может быть клонирован"</font>);
    }
    <font color="#0000ff">return</font> o;
  }
}

<font color="#0000ff">class</font> Thing4 <font color="#0000ff">implements</font> Cloneable {
  Thing3 o3 = <font color="#0000ff">new</font> Thing3();
  <font color="#0000ff">public</font> Object clone() {
    Thing4 o = <font color="#0000ff">null</font>;
    <font color="#0000ff">try</font> {
      o = (Thing4)<font color="#0000ff">super</font>.clone();
    } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
      System.err.println(<font color="#004488">"Thing4 не может быть клонирован"</font>);
    }
    <font color="#009900">// Клонировать поле:</font>
    o.o3 = (Thing3)o3.clone();
    <font color="#0000ff">return</font> o;
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Compete {
  <font color="#0000ff">static</font> <font color="#0000ff">final</font> <font color="#0000ff">int</font> SIZE = 5000;
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) 
  <font color="#0000ff">throws</font> Exception {
    Thing2[] a = <font color="#0000ff">new</font> Thing2[SIZE];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a.length; i++)
      a[i] = <font color="#0000ff">new</font> Thing2();
    Thing4[] b = <font color="#0000ff">new</font> Thing4[SIZE];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; b.length; i++)
      b[i] = <font color="#0000ff">new</font> Thing4();
    <font color="#0000ff">long</font> t1 = System.currentTimeMillis();
    ByteArrayOutputStream buf = 
      <font color="#0000ff">new</font> ByteArrayOutputStream();
    ObjectOutputStream o =
      <font color="#0000ff">new</font> ObjectOutputStream(buf);
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; a.length; i++)
      o.writeObject(a[i]);
    <font color="#009900">// Теперь получаем копии:</font>
    ObjectInputStream in =
      <font color="#0000ff">new</font> ObjectInputStream(
        <font color="#0000ff">new</font> ByteArrayInputStream(
          buf.toByteArray()));
    Thing2[] c = <font color="#0000ff">new</font> Thing2[SIZE];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; c.length; i++)
      c[i] = (Thing2)in.readObject();
    <font color="#0000ff">long</font> t2 = System.currentTimeMillis();
    System.out.println(
      <font color="#004488">"Дублирование с применением серийности: "</font> +
      (t2 - t1) + <font color="#004488">" Миллисекунд"</font>);
    <font color="#009900">// Теперь попробуем использовать клонирование:</font>
    t1 = System.currentTimeMillis();
    Thing4[] d = <font color="#0000ff">new</font> Thing4[SIZE];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; d.length; i++)
      d[i] = (Thing4)b[i].clone();
    t2 = System.currentTimeMillis();
    System.out.println(
      <font color="#004488">"Дублирование через клонирование: "</font> +
      (t2 - t1) + <font color="#004488">" Миллисекунд"</font>);
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p class="pad"><b>Thing2</b> и <b>Thing4</b> содержат объекты, подлежащие глубокому 
копированию. Интересно отметить что хотя серийные классы легки при описании, но 
требуют хлопот при дублировании. Клонирование, наоборот, требует хлопот при 
описании класса, но операция дублирования относительно проста. Результаты работы 
примера говорят сами за себя. Вот результаты трех различных запусков 
примера:</p>
<pre><font size="2">Дублирование с применением серийности: 940 Milliseconds
Дублирование через клонирование: 50 Milliseconds

Дублирование с применением серийности: 710 Milliseconds
Дублирование через клонирование: 60 Milliseconds

Дублирование с применением серийности: 770 Milliseconds
Дублирование через клонирование: 50 Milliseconds</font></pre>
<p class="pad">Помимо значительной разницы в затратах времени, вы можете наблюдать что 
операция серийности менее стабильна чем операция клонирования.</p>
<h4><a name="Heading613"></a>Обеспечение клонируемости объектов-наследников</h4>
<p class="pad">Когда создается новый класс, ему по умолчанию передаются свойства базового 
класса <b>Object</b>, который по умолчанию является не клонируемым (об этом 
пойдет речь в следующем разделе), и остается таковым до тех пор, пока вы не 
захотите этого. Однако, после того как вы добавите возможность клонирования в 
какой-либо класс, она будет передана всем нижестоящим по иерархии классам:</p>
<pre><font color="#009900">//: Приложение А:HorrorFlick.java</font>
<font color="#009900">// Вы можете добавить клонируемость в </font>
<font color="#009900">// любой уровень иерархии наследования объектов.</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">class</font> Person {}
<font color="#0000ff">class</font> Hero <font color="#0000ff">extends</font> Person {}
<font color="#0000ff">class</font> Scientist <font color="#0000ff">extends</font> Person 
    <font color="#0000ff">implements</font> Cloneable {
  <font color="#0000ff">public</font> Object clone() {
    <font color="#0000ff">try</font> {
      <font color="#0000ff">return</font> <font color="#0000ff">super</font>.clone();
    } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
      <font color="#009900">// этого не должно произойти:</font>
      <font color="#009900">// он уже клонируемый!</font>
      <font color="#0000ff">throw</font> <font color="#0000ff">new</font> InternalError();
    }
  }
}
<font color="#0000ff">class</font> MadScientist <font color="#0000ff">extends</font> Scientist {}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> HorrorFlick {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Person p = <font color="#0000ff">new</font> Person();
    Hero h = <font color="#0000ff">new</font> Hero();
    Scientist s = <font color="#0000ff">new</font> Scientist();
    MadScientist m = <font color="#0000ff">new</font> MadScientist();

    <font color="#009900">// p = (Person)p.clone(); // Ошибка компиляции</font>
    <font color="#009900">// h = (Hero)h.clone(); // Ошибка компиляции</font>
    s = (Scientist)s.clone();
    m = (MadScientist)m.clone();
  }
} <font color="#009900">///:~</font></pre>
<p class="pad">Перед тем как добавить клонируемость, компилятор остановит вас при попытке 
клонировать предметы (things). 
Когда клонируемость будет добавлена в Scientist, Scientist и все его наследники 
станут клонируемыми.&nbsp;</p>
<h4><a name="Heading614"></a>Почему используется такая странная конструкция?</h4>
<p class="pad">Возможно такая система показалась вам странной и вы задавались вопросом 
почему в ней возникла необходимость. Что же стоит за такой реализацией?</p>
<p class="pad">Первоначально Java разрабатывался как язык для управления устройствами и не 
был предназначен для использование в Internet. Клонирование объектов является 
неотъемлемой функцией таких языков. Поэтому в базовый класс <b>Object</b> был 
помещен метод <b>clone()</b>, <i>но</i> он был описан как <b>public</b> и таким 
образом обеспечивалась возможность клонирования любых объектов. На том этапе это 
казалось наиболее оптимальным вариантом.</p>
<p class="pad">Но позже, когда Java превратился в язык, активно применяемый в Internet, все 
изменилось. Тотальная клонируемость объектов привела к возникновению проблем с 
безопасностью. Кому хочется чтобы его объекты безопасности свободно 
клонировались? Поэтому в изначально простую схему были внесены изменения и метод 
<b>clone()</b> класса <b>Object</b> стал защищенным (<b>protected</b>) и теперь 
для реализации клонирования вам приходится переопределять его, реализовывать 
интерфейс <b>Cloneable</b> и иметь дело с обработкой исключительных событиями. 
Следует отметить, что интерфейс <b>Cloneable</b> реализуется <i>только</i> в том 
случае, если вы собираетесь вызывать метод <b>clone()</b> класса <b>Object</b>, 
работа которого начинается с проверки, является ли вызвавший его класс 
клонируемым. Но, во избежание противоречий, на всякий случай следует реализовать 
этот интерфейс (тем более, если учесть что он пустой).</p>
<h3><a name="Heading615"></a>Управление клонируемостью объектов</h3>
<p class="pad">У вас возможно сложилось впечатление что для отключения клонируемости 
достаточно определить метод clone() как <b>private</b>, но это не так, поскольку 
оперируя методом базового класса вы не можете&nbsp; изменять его статус. Так что 
это не такая простая задача. И, тем не менее, необходимо уметь управлять 
клонируемостью своих объектов. Существует ряд типовых реализаций, которыми вы 
можете руководствоваться при разработке своих классов:</p>
<ol>
  
<li>Ничего не предпринимайте в связи с клонированием, тогда ваш класс не может 
  быть клонирован, но при необходимости в класс-наследник может быть добавлена 
  возможность клонирования. Такой вариант возможен лишь в том случае, если метод 
  <b>Object.clone()</b> справится с клонированием всех полей вашего класса. 
  
</li><li>Поддержка метода <b>clone()</b>. Реализуйте интерфейс <b>Cloneable</b> и 
  переопределите метод <b>clone()</b>. В переопределенном методе <b>clone()</b> 
  вы должны разместить вызов <b>super.clone()</b> и обработать возможные 
  исключительные ситуации (таким образом, переопределенный метод <b>clone()</b> 
  не будет возвращать исключительных ситуаций). 
  
</li><li>Условная поддержка клонирования. Если ваш класс содержит ссылки на другие 
  объекты и вы не можете быть уверены что все они являются клонируемыми 
  (например, контейнеры), ваш метод <b>clone()</b> может предпринять попытку 
  клонировать все объекты, на которые указывают ссылки, и если это приведет к 
  появлению исключительной ситуации, он просто передает эту исключительную 
  ситуацию далее, для последующей обработки программистом. В качестве примера 
  возьмем особый объект типа <b>ArrayList</b>, который пытается клонировать все 
  свои объекты. Создавая такой <b>ArrayList</b>, вы не знаете точно объекты 
  какого типа программист захочет разместить в вашем <b>ArrayList</b>, а значит 
  не знаете будут они клонируемыми или нет. 
  
</li><li>Метод <b>clone()</b> переопределяется как защищенный (<b>protected</b>) но 
  интерфейс <b>Cloneable</b> не реализуется. Таким образом обеспечивается 
  правильное копирование всех полей класса. Вы должны помнить что для 
  обеспечения правильного копирования ваш метод должен вызывать 
  <b>super.clone()</b>, несмотря на то что этот метод ожидает вызова от объекта, 
  реализующего интерфейс <b>Cloneable</b> (поэтому такой вызов приведет к 
  возникновению исключительной ситуации), поскольку иначе для 
  объектов-наследников вашего класса такой вызов будет невозможен.&nbsp;Метод 
  будет работать только для классов-наследников, которые могут реализовать 
  интерфейс <b>Cloneable</b>. 
  
</li><li>Попытка предотвратить клонирование не реализовав интерфейс 
  <b>Cloneable</b> и переопределив метод <b>clone()</b> для генерации 
  исключительной ситуации. Этот прием работает лишь при условии что все 
  классы-наследники при переопределении метода <b>clone()</b> вызывают 
  <b>super.clone()</b>. В противном случае вашу блокировку можно будет обойти. 
  
</li><li>Защита от клонирования путем описания класса как завершенного 
  (<b>final</b>). Такая защита будет работать лишь в том случае, если метод 
  <b>clone()</b> не был переопределен в каком-либо его родительском классе. В 
  протвном случае потребуется снова переопределить его и сгенерировать 
  исключительную ситуацию <b>CloneNotSupportException</b>. Сделать свой класс 
  завершенным (<b>final</b>) - единственная гарантированная защита от 
  клонирования. Кроме того, при работе с защищенными объектами или в других 
  ситуациях, когда требуется контроль за числом создаваемых объектов, необходимо 
  определить все конструкторы как <b>private</b> и создать один или несколько 
  специальных методов, используемых при создании объектов. Таким образом, эти 
  методы могут ограничить число создаваемых с их помощью объектов и 
  контролировать условия, в которых они создаются. (Одним из примеров таких 
  классов может служить <i>singleton</i>,&nbsp; рассмотренный в документе 
  <i>Размышления над примерами на Java (Thinking in Patterns with Java)</i>, 
  доступном по адресу <a href="http://www.bruceeckel.com/">http://www.bruceeckel.com/</a>). </li>
</ol>
<p class="pad">Ниже приведен пример, демонстрирующий различные способы при которых 
клонирование может быть наследовано или "отключено" в объектах-наследниках:</p>
<pre><font size="2"><font color="#009900">//: Приложение А:CheckCloneable.java</font>
<font color="#009900">// Проверка, может ли ссылка клонироваться.</font>

<font color="#009900">// Не может клонироваться, поскольку не переопредлен </font>
<font color="#009900">// метод clone():</font>
<font color="#0000ff">class</font> Ordinary {}

<font color="#009900">// Переопределяется clone, но не реализуется</font>
<font color="#009900">// интерфейс Cloneable:</font>
<font color="#0000ff">class</font> WrongClone <font color="#0000ff">extends</font> Ordinary {
  <font color="#0000ff">public</font> Object clone()
      <font color="#0000ff">throws</font> CloneNotSupportedException {
    <font color="#0000ff">return</font> <font color="#0000ff">super</font>.clone(); <font color="#009900">// Возвращает исключительную ситуацию</font>
  }
}

<font color="#009900">// Соблюдены все необходимые для клонирования условия:</font>
<font color="#0000ff">class</font> IsCloneable <font color="#0000ff">extends</font> Ordinary 
    <font color="#0000ff">implements</font> Cloneable {
  <font color="#0000ff">public</font> Object clone() 
      <font color="#0000ff">throws</font> CloneNotSupportedException {
    <font color="#0000ff">return</font> <font color="#0000ff">super</font>.clone();
  }
}

<font color="#009900">// Клонирование отключено с генерацией исключительного события:</font>
<font color="#0000ff">class</font> NoMore <font color="#0000ff">extends</font> IsCloneable {
  <font color="#0000ff">public</font> Object clone() 
      <font color="#0000ff">throws</font> CloneNotSupportedException {
    <font color="#0000ff">throw</font> <font color="#0000ff">new</font> CloneNotSupportedException();
  }
}

<font color="#0000ff">class</font> TryMore <font color="#0000ff">extends</font> NoMore {
  <font color="#0000ff">public</font> Object clone() 
      <font color="#0000ff">throws</font> CloneNotSupportedException {
    <font color="#009900">// Вызов NoMore.clone(), что приводит к появлению исключительного события:</font>
    <font color="#0000ff">return</font> <font color="#0000ff">super</font>.clone();
  }
}

<font color="#0000ff">class</font> BackOn <font color="#0000ff">extends</font> NoMore {
  <font color="#0000ff">private</font> BackOn duplicate(BackOn b) {
    <font color="#009900">// Создается и возвращается копия b.</font>
    <font color="#009900">// Это простейшее копирование, использованное лишь в качестве примера:</font>
    <font color="#0000ff">return</font> <font color="#0000ff">new</font> BackOn();
  }
  <font color="#0000ff">public</font> Object clone() {
    <font color="#009900">// Метод NoMore.clone() не вызывается:</font>
    <font color="#0000ff">return</font> duplicate(<font color="#0000ff">this</font>);
  }
}

<font color="#009900">// Не удается наследовать, а потому и переопределить</font>
<font color="#009900">// метод clone как это было сделано в BackOn:</font>
<font color="#0000ff">final</font> <font color="#0000ff">class</font> ReallyNoMore <font color="#0000ff">extends</font> NoMore {}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> CheckCloneable {
  <font color="#0000ff">static</font> Ordinary tryToClone(Ordinary ord) {
    String id = ord.getClass().getName();
    Ordinary x = <font color="#0000ff">null</font>;
    <font color="#0000ff">if</font>(ord <font color="#0000ff">instanceof</font> Cloneable) {
      <font color="#0000ff">try</font> {
        System.out.println(<font color="#004488">"Попытка клонирования "</font> + id);
        x = (Ordinary)((IsCloneable)ord).clone();
        System.out.println(<font color="#004488">"Клонирован "</font> + id);
      } <font color="#0000ff">catch</font>(CloneNotSupportedException e) {
        System.err.println(<font color="#004488">"Не удается клонировать "</font>+id);
      }
    }
    <font color="#0000ff">return</font> x;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#009900">// Подмена типов:</font>
    Ordinary[] ord = { 
      <font color="#0000ff">new</font> IsCloneable(),
      <font color="#0000ff">new</font> WrongClone(),
      <font color="#0000ff">new</font> NoMore(),
      <font color="#0000ff">new</font> TryMore(),
      <font color="#0000ff">new</font> BackOn(),
      <font color="#0000ff">new</font> ReallyNoMore(),
    };
    Ordinary x = <font color="#0000ff">new</font> Ordinary();
    <font color="#009900">// Это не удастся откомпилировать, пока clone()</font>
    <font color="#009900">// описан как protected в классе Object:</font>
    <font color="#009900">//! x = (Ordinary)x.clone();</font>
    <font color="#009900">// tryToClone() сначала осуществляет проверку чтобы</font>
    <font color="#009900">// определить, реализует ли данный класс интерфейс Cloneable:</font>
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; ord.length; i++)
      tryToClone(ord[i]);
  }
} <font color="#009900">///:~</font></font></pre>
<p class="pad">Первый класс, <b>Ordinary</b>, относится к группе классов, рассмотреных в 
этой книге: он не поддерживает клонирование, но при этом не имеет механизмов ее 
блокировки. Однако, если вы имеете дело с ссылкой на <b>Ordinary</b> объект, 
ставший таковым в результате подмены, вы не можете быть уверены в том, сможет ли 
он быть клонирован или нет.</p>
<p class="pad">Класс <b>WrongClone</b> иллюстрирует неправильную реализацию наследования 
клонирования. В нем метод <b>Object.clone()</b> переопределяется как 
<b>public</b>, но не реализован интерфейс <b>Cloneable</b>, поэтому вызов 
<b>super.clone()</b> (в результате которого вызывается <b>Object.clone()</b>) 
приводит к возникновению исключительной ситуации 
<b>CloneNotSupportedException</b> и клонирование не выполняется.</p>
<p class="pad">В классе <b>IsCloneable</b> клонирование реализовано правильно: метод 
<b>clone()</b> переопределяется и реализуется интерфейс <b>Cloneable</b>. 
Однако, метод clone(), а также некоторые другие методы в этом примере <i>не 
перехватывают</i> исключительную ситуацию <b>CloneNotSupportException</b>, а 
лишь возвращают ее вызвавшему методу, где должна быть предусмотрена обработка в 
блоке операторов <b>try</b>-<b>catch</b>. Вам скорее всего придется обрабатывать 
эту ситуацию <i>внутри</i> вашего метода <b>clone()</b> гораздо чаще чем просто 
передавать ее, но в качестве примера гораздо информативнее было ограничиться 
лишь передачей.</p>
<p class="pad">В классе <b>NoMore</b> предпринята попытка отключения клонирования способом, 
рекомендуемым разработчиками Java: в методе <b>clone()</b> класса-наследника 
генерируется исключительная ситуация <b>CloneNotSupportedException</b>. В методе 
<b>clone()</b> класса <b>TryMore</b> как и положено вызывается метод 
<b>super.clone()</b>, который таким образом приводит к вызову метода 
<b>NoMore.clone()</b>, который генерирует исключительную ситуацию и 
предотвращает клонирование.</p>
<p class="pad">Но что если программист не станет следовать "правильной" схеме вызова метода 
<b>super.clone()</b> в переопределенном методе <b>clone()</b>? На примере класса 
<b>BackOn</b> вы можете наблюдать пример таких действий. Этот класс использует 
специальный метод <b>duplicate()</b> для копирования текущего объекта и в 
<b>clone()</b> вызывает этот метод <i>вместо</i> вызова <b>super.clone()</b>. 
При этом исключительная ситуация не генерируется и класс может быть клонирован. 
Это пример того, что нельзя рассчитывать на генерацию исключительной ситуации 
как на защиту класса от клонирования. Единственный верный способ для этого, 
показан на примере класса <b>ReallyNoMore</b>&nbsp;где класс описан как 
завершенный (<b>final</b>), то есть как класс, который не может быть наследован. 
Это означает что если метод <b>clone()</b> генерирует исключительную ситуацию в 
<b>final</b> классе, то ее не удасться обойти при помощи наследования, что 
обеспечивает гарантированную защиту от клонирования (вы не можете явно вызвать 
<b>Object.clone() </b>из класса с произвольным уровнем наследования; можно 
вызвать лишь метод <b>super.clone()</b>, через который будет произведено 
обращение к методу базового класса). таким образом, разрабатывая объекты с 
высоким уровнем защиты, такие классы лучше описывать как <b>final</b>.</p>
<p class="pad">Первый метод класса <b>CheckCloneability</b> - <b>tryToClone()</b>, берет 
произвольный <b>Ordinary</b> объект и проверяет, является ли он клонируемым с 
помощью <b>instanceof</b>. Если да, он подменяет тип объекта на 
<b>IsCloneable</b> и вызывает для него метод <b>clone()</b>, после чего для 
результатов выполняет обратную подмену в <b>Ordinary</b>, перехватывая все 
возникающие в ходе операции исключительные ситуации. Обратите внимание на 
определение типа объекта в процессе выполнения&nbsp; метода (см. Главу 12) 
используемое для вывода на экран имени класса для идентификации событий.</p>
<p class="pad">В методе <b>main()</b>, создаются различные типы <b>Ordinary</b> объектов с 
подменой типа на <b>Ordinary</b> при определении массива. Следующие за этим две 
строки кода создают простой <b>Ordinary</b> объект и пытаются клонировать его. 
Однако этот код не удастся откомпилировать, поскольку в классе <b>Object</b> 
метод <b>clone()</b> определен как защищенный (<b>protected</b>). Остальной код 
пробегает по всему массиву и пытается клонировать каждый из его объектов, 
информируя при этом об успешности этих операций. Вы получите следующие 
результаты:</p>
<blockquote>
<pre><font size="2">Попытка клонирования IsCloneable
Клонирован IsCloneable
Попытка клонирования NoMore
Не удается клонировать NoMore
Попытка клонирования TryMore
Не удается клонировать TryMore
Попытка клонирования BackOn
Клонирован BackOn
Попытка клонирования ReallyNoMore
Не удается клонировать ReallyNoMore</font></pre>
</blockquote>
<p>В заключение, сформулируем требования, предъявляемые к клонируемым 
классам:</p>
<p>1. Реализация интерфейса Cloneable.</p>
<p>2. Переопределение метода clone()</p>
<p>3. Вызов метода super.clone() из переопределенного метода clone()</p>
<p>4. Обработка исключительных ситуаций в методе clone()</p>
<h4><a name="Heading616"></a>Конструкторы копирования</h4>
<div align="left">
<p class="pad">Возможно клонирование показалось вам сложным процессом и вам хочется найти 
ему более удобную альтернативу. Таким решением (особенно если вы владеете Си++) 
является создание специального конструктора, задачей которого будет создание 
дубликата объекта. В Си++ такие конструкторы называются <i>конструкторами 
копирования</i>. На первый взгляд они могут показаться очевидным выходом из 
положения, но применить их на практике вам не удастся. Рассмотрим 
пример:</p>
</div>
<blockquote>
<pre><font size="2"><font color="#009900">//: Приложение А:CopyConstructor.java</font>
<font color="#009900">// Конструктор для копирования объектов одинаковых типов
// как способ создания локальных копий.</font>

<font color="#0000ff">class</font> FruitQualities {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> weight;
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> color;
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> firmness;
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> ripeness;
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> smell;
  <font color="#009900">// и т.д.</font>
  FruitQualities() { <font color="#009900">// Конструктор по умолчанию</font>
    <font color="#009900">// для совершения каких-либо необходимых действий...</font>
  }
  <font color="#009900">// Прочие конструкторы:</font>
  <font color="#009900">// ...</font>
  <font color="#009900">// Конструктор копирования:</font>
  FruitQualities(FruitQualities f) {
    weight = f.weight;
    color = f.color;
    firmness = f.firmness;
    ripeness = f.ripeness;
    smell = f.smell;
    <font color="#009900">// и т.д.</font>
  }
}

<font color="#0000ff">class</font> Seed {
  <font color="#009900">// Поля...</font>
  Seed() { <font color="#009900">/* Конструктор по умолчанию */</font> }
  Seed(Seed s) { <font color="#009900">/* Конструктор копирования */</font> }
}

<font color="#0000ff">class</font> Fruit {
  <font color="#0000ff">private</font> FruitQualities fq;
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> seeds;
  <font color="#0000ff">private</font> Seed[] s;
  Fruit(FruitQualities q, <font color="#0000ff">int</font> seedCount) { 
    fq = q;
    seeds = seedCount;
    s = <font color="#0000ff">new</font> Seed[seeds];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; seeds; i++)
      s[i] = <font color="#0000ff">new</font> Seed();
  }
  <font color="#009900">// Прочие конструкторы:</font>
  <font color="#009900">// ...</font>
  <font color="#009900">// Конструктор копирования:</font>
  Fruit(Fruit f) {
    fq = <font color="#0000ff">new</font> FruitQualities(f.fq);
    seeds = f.seeds;
    <font color="#009900">// Быстрый вызов всех конструкторов копирования:</font>
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; seeds; i++)
      s[i] = <font color="#0000ff">new</font> Seed(f.s[i]);
    <font color="#009900">// Действия других конструкторов копирования...</font>
  }
  <font color="#009900">// Для обеспечения размещения полученных конструкторов (или других </font>
  <font color="#009900">// методов) в различных качествах:</font>
  <font color="#0000ff">protected</font> <font color="#0000ff">void</font> addQualities(FruitQualities q) {
    fq = q;
  }
  <font color="#0000ff">protected</font> FruitQualities getQualities() {
    <font color="#0000ff">return</font> fq;
  }
}

<font color="#0000ff">class</font> Tomato <font color="#0000ff">extends</font> Fruit {
  Tomato() {
    <font color="#0000ff">super</font>(<font color="#0000ff">new</font> FruitQualities(), 100);
  }
  Tomato(Tomato t) { <font color="#009900">// Конструктор копирования</font>
    <font color="#0000ff">super</font>(t); <font color="#009900">// Подмена для базового конструктора копирования</font>
    <font color="#009900">// Прочие операции конструктора копирования...</font>
  }
}

<font color="#0000ff">class</font> ZebraQualities <font color="#0000ff">extends</font> FruitQualities {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> stripedness;
  ZebraQualities() { <font color="#009900">// Конструктор по умолчанию</font>
    <font color="#009900">//  для совершения каких-либо необходимых действий...
</font>  }
  ZebraQualities(ZebraQualities z) {
    <font color="#0000ff">super</font>(z);
    stripedness = z.stripedness;
  }
}

<font color="#0000ff">class</font> GreenZebra <font color="#0000ff">extends</font> Tomato {
  GreenZebra() {
    addQualities(<font color="#0000ff">new</font> ZebraQualities());
  }
  GreenZebra(GreenZebra g) {
    <font color="#0000ff">super</font>(g); <font color="#009900">// Вызов Tomato(Tomato)</font>
    <font color="#009900">// Восстановление верных качеств:</font>
    addQualities(<font color="#0000ff">new</font> ZebraQualities());
  }
  <font color="#0000ff">void</font> evaluate() {
    ZebraQualities zq = 
      (ZebraQualities)getQualities();
    <font color="#009900">// Какие-нибудь операции с качествами</font>
    <font color="#009900">// ...</font>
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> CopyConstructor {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> ripen(Tomato t) {
    <font color="#009900">// Использование "конструктора копирования":</font>
    t = <font color="#0000ff">new</font> Tomato(t); 
    System.out.println(<font color="#004488">"В зрелых t это "</font> +
      t.getClass().getName());
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> slice(Fruit f) {
    f = <font color="#0000ff">new</font> Fruit(f); <font color="#009900">// Хмм... будет ли это работать?</font>
    System.out.println(<font color="#004488">"В нарезаных ломтиками f это "</font> +
      f.getClass().getName());
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Tomato tomato = <font color="#0000ff">new</font> Tomato();
    ripen(tomato); <font color="#009900">// OK</font>
    slice(tomato); <font color="#009900">// Ой!</font>
    GreenZebra g = <font color="#0000ff">new</font> GreenZebra();
    ripen(g); <font color="#009900">// Ой!</font>
    slice(g); <font color="#009900">// Ой!</font>
    g.evaluate();
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p class="pad">Сначала это кажется немного странным. Конечно, плоды обладают свойствами, но 
почему бы просто не поместить элементы данных, представляющие эти свойства 
непосредственно в классе <b>Fruit</b>? На то есть две причины. Первая 
заключается в том, что вам захочется иметь возможность с легкостью добавлять ли 
изменять эти качества. Обратите внимание что в классе <b>Fruit</b> есть 
защищенный (<b>protected</b>) метод <b>addQualities()</b>, позволяющий 
классам-наследникам производить подобные операции. (Возможно вам покажется что 
было бы логичнее создать для класса <b>Fruit</b> защищенный (<b>protected</b>) 

конструктор, которому передавался бы параметр <b>FruitQualities</b>, но 
конструкторы не наследуются, поэтому он не будет доступен для 
классов-наследников второго и выше уровней.) Поместив качества фруктов в 
различные классы вы обеспечиваете большую гибкость, включая возможность изменять 
качества по ходу существования каждого отдельного объекта <b>Fruit</b>.</p>
<p class="pad">Вторая причина размещения <b>FruitQualities</b> в отдельных объектах 
заключается в добавлении или изменении их при помощи механизмов наследования и 
полиморфизма. Заметьте что для объекта <b>GreenZebra</b> (зеленая зебра), 
который <i>на самом деле</i> происходит от типа <b>Tomato</b>. Конструктор 
вызывает метод <b>addQualities()</b> и передает их <b>ZebraQualities</b> 
объекту, который наследуется от <b>FruitQualities</b> и поэтому он может быть 
подключен к ссылке на <b>FruitQualities</b> в базовом классе. Разумеется, когда 
<b>GreenZebra</b> использует <b>FruitQualities</b>, он должен привести его к 
нужному типу (как показано в <b>evalute()</b>), но при этом всегда знает что 
работает с классом <b>ZebraQualities</b>.</p>
<p class="pad">Как вы видите, есть еще класс <b>Seed</b> (семя) и класс <b>Fruit</b> 
(который по определению содержит свои собственные семена)[<a href="file:///C:/out/AppendixA1.htm#%5B82%5D">82</a>], содержит массив из объектов 
<b>Seeds</b>.</p>
<p class="pad">И, наконец, обратите внимание на то что для обеспечения глубокого копирования 
все классы имеют конструкторы копирования, и каждый конструктор копирования 
должен позаботиться о том, чтобы вызвать конструкторы копирования для базового 
класса и объектов-членов. Конструктор копирования тестируется внутри класса 
<b>CopyConstructor</b>. Метод <b>ripen()</b> получает в качестве параметра 
<b>Tomato</b> и осуществляет создание его копии.</p>
<p>t = <font color="#0000ff">new</font> Tomato(t);</p>
<p>Тем временем <b>slice()</b> получает объект <b>Fruit</b> и также дублирует 
его:</p>
<p>f = <font color="#0000ff">new</font> Fruit(f);</p>
<p>Таким образом в <b>main()</b> тестируются различные экземпляры <b>Fruit</b>. 
Вот результаты:</p>
<pre><font size="2">В зрелых t это Tomato
В нарезаных ломтиками f это Fruit
В зрелых t это Tomato
В нарезаных ломтиками f это Fruit
</font></pre>
<p class="pad">Вот где появляются проблемы. После 
того как создается копия <b>Tomato</b> в <b>slice()</b>, в результате этой 
операции <b>Tomato</b> перестает существовать, остается только <b>Fruit</b>. Он 
теряет, так сказать, всю свою "помидорность". Затем, когда дойдет очередь до 
<b>GreenZebra</b>, <b>ripen()</b> и <b>slice()</b> также превратят его сначала в 
<b>Tomato</b>, а затем в <b>Fruit</b>. Поэтому, увы, методика конструкторов 
копирования не применима для Java, когда заходит речь о создании локальных 
копий.</p>
<h5><a name="Heading617"></a>Почему это работает в C++ и не работает в Java?</h5>
<p class="pad">Конструкторы копирования - фундаментальный элемент языка Си++, поскольку с их 
помощью автоматически создаются локальные копии объектов. Однако, как показывает 
приведенный выше пример, они не работают в Java. Почему? В Java мы можем 
манипулировать только с ссылками, тогда как в Си++ наряду с аналогами ссылок 
допускаются манипуляции непосредственно с самими объектами. Вот для чего нужны 
конструкторы копирования в Си++: они создают дубликат объекта в случаях когда 
требуется передать объект "по значению". Этот прием прекрасно работает в Си++, 
но вы должны помнить что такая конструкция не будет работать в Java и должны 
воздержаться от ее использования.</p>
<h3><a name="Heading618"></a>Классы только для чтения</h3>
<p class="pad">В то время как метод <b>clone()</b> реализует создание локальных копий 
объекта, на программиста (автора метода) ложится ответственность по 
предотвращению вредных воздействий, грозящих при использовании дублирующих 
ссылок.&nbsp;Предположим вы создаете библиотеку настолько универсальную и часто 
используемую, что вы не уверены в том, что она будет правильно клонирована? Или, 
скажем проще, что если вы <i>хотите</i> разрешить дублирующих ссылок для 
повышения эффективности (чтобы избежать излишнего дублирования объектов) но при 
этом хотите избежать негативных сторон применения дублирующих ссылок?</p>
<p class="pad">Одно из решений - создание <i>неизменных объектов</i>, относящихся к группе 
классов "только для чтения". Вы можете определить класс таким образом, что 
работа методов никак не будет отражаться на состоянии самого объекта. В таких 
классах использование дублирующих ссылок не приводит к возникновению каких-либо 
проблем, поскольку вам доступны лишь операции считывания данные из объекта, а 
параллельное считывание не вызывает никаких проблем. В качестве простого примера 
неизменных объектов может служить стандартная библиотека Java, содержащая 
"классы-ярлыки", созданные для примитивов всех типов. Возможно вы уже обнаружили 
что если вы хотите разместить <b>int</b> в классе- контейнере, таком как 
<b>ArrayList</b> (который содержит только ссылки на объекты), вы можете обернуть (wrap) ваш <b>int</b> внутри 
стандартной библиотеки класса <b>Integer</b>:</p>
<blockquote>
<pre><font size="2"><font color="#009900">//: Приложение А:ImmutableInteger.java</font>
<font color="#009900">// Класс Integer не может быть изменен .</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ImmutableInteger {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    ArrayList v = <font color="#0000ff">new</font> ArrayList();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i++) 
      v.add(<font color="#0000ff">new</font> Integer(i));
    <font color="#009900">// Но как вы изменили int</font>
    <font color="#009900">// внутри Integer?</font>
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p class="pad">Класс <b>Integer</b> ( как и другие "классы-обертки" примитивов) наследуют 
неизменность самым простым образом: просто у них нет методов, позволяющих 
изменять объект.</p>
<p class="pad">Если вам нужен объект, который содержит типы примитива, который может быть 
изменен, вы должны создать его самостоятельно. К счастью это очень просто:</p>
<pre><font size="2"><font color="#009900">//: Приложение А:MutableInteger.java</font>
<font color="#009900">// Изменяемый класс-ярлык.</font>
<font color="#0000ff">import</font> java.util.*;

<font color="#0000ff">class</font> IntValue { 
  <font color="#0000ff">int</font> n;
  IntValue(<font color="#0000ff">int</font> x) { n = x; }
  <font color="#0000ff">public</font> String toString() { 
    <font color="#0000ff">return</font> Integer.toString(n);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> MutableInteger {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    ArrayList v = <font color="#0000ff">new</font> ArrayList();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 10; i++) 
      v.add(<font color="#0000ff">new</font> IntValue(i));
    System.out.println(v);
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; v.size(); i++)
      ((IntValue)v.get(i)).n++;
    System.out.println(v);
  }
} <font color="#009900">///:~</font></font></pre>
<p>Примечание: <b>n</b> использовано для упрощения кода.</p>
<p class="pad">Класс <b>IntValue</b> может быть даже упрощен, если при инициализации по 
умолчанию допускается устанавливать значение в ноль (тогда вам не нужен 
конструктор) и если вам не надо заботиться о выводе на печать (тогда вам не 
нужен метод <b>toString()</b>):</p>
<blockquote>
<pre><font size="2"><font color="#0000ff">class</font> IntValue { <font color="#0000ff">int</font> n; }</font></pre>
</blockquote>
<p class="pad">Процедура выборки элементов и применения подмены типов выглядят несколько 
неуклюже, но это уже особенность <b>ArrayList</b> а не <b>IntValue</b>.</p>
<h4><a name="Heading619"></a>Создание классов только для чтения</h4>
<p>Вы можете создать свой собственный класс "только для чтения". Пример:</p>
<blockquote>
<pre><font size="2"><font color="#009900">//: Приложение А:Immutable1.java</font>
<font color="#009900">// Не модифицируемые объекты</font>
<font color="#009900">// обладают иммунитетом от дублирующих ссылок.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Immutable1 {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> data;
  <font color="#0000ff">public</font> Immutable1(<font color="#0000ff">int</font> initVal) {
    data = initVal;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">int</font> read() { <font color="#0000ff">return</font> data; }
  <font color="#0000ff">public</font> <font color="#0000ff">boolean</font> nonzero() { <font color="#0000ff">return</font> data != 0; }
  <font color="#0000ff">public</font> Immutable1 quadruple() {
    <font color="#0000ff">return</font> <font color="#0000ff">new</font> Immutable1(data * 4);
  }
  <font color="#0000ff">static</font> <font color="#0000ff">void</font> f(Immutable1 i1) {
    Immutable1 quad = i1.quadruple();
    System.out.println(<font color="#004488">"i1 = "</font> + i1.read());
    System.out.println(<font color="#004488">"quad = "</font> + quad.read());
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Immutable1 x = <font color="#0000ff">new</font> Immutable1(47);
    System.out.println(<font color="#004488">"x = "</font> + x.read());
    f(x);
    System.out.println(<font color="#004488">"x = "</font> + x.read());
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p class="pad">Все данные определены как <b>private</b> и, как видите, напрочь отсутствуют 
<b>public</b> методы, модифицирующие эти данные. Действительно, метод, который 
казалось бы вносит изменения в объект, <b>quadruple()</b>, на самом деле для 
своих операций создает новый объект <b>Immutable1</b> не изменяя при этом 
объект-оригинал.</p>
<p class="pad">Метод <b>f()</b> совершает различные действия с объектом <b>Immutable1</b>, а 
выводимые на экран в процедуре <b>main()</b> результаты свидетельствуют о том, 
что они никак не отразились на состоянии <b>x</b>. Таким образом, ссылки на 
объект <b>x</b> могут быть многократно дублированы без какого-либо вреда, 
поскольку неизменные классы гарантируют что этот объект не будет 
изменен.&nbsp;</p>
<h4><a name="Heading620"></a>Недостаток неизменных классов</h4>
<div align="left">
<p class="pad">Создание неизменных классов на первый взгляд является элегантным 
решением.&nbsp; Однако, всякий раз, когда вам понадобится модифицировать новый 
объект этого типа, вы должны&nbsp;терпеть неудобства, связанные с необходимостью 
создания нового объекта, а также более частым "сбором мусора". Для каких-то 
объектов это не составит труда, но для некоторых (таких, как класс 
<b>String</b>) сопряжено с множеством проблем.</p>
</div>
<div align="left">
<p class="pad">В таком случае хорошим выходом будет создание класса-компаньона, который 
<i>может</i> изменяться. Тогда, если вам требуется произвести множество 
изменений, вы можете переключаться на использование редактируемого 
класса-компаньона, а после завершения всех модификаций вновь работать с 
неизменным классом.</p>
</div>
<div align="left">
<p>Пример:</p>
</div>
<blockquote>
<pre><font size="2"><font color="#009900">//: Приложение А:Immutable2.java</font>
<font color="#009900">// Класс-компаньон для внесения изменений</font>
<font color="#009900">// в неизменный класс.</font>

<font color="#0000ff">class</font> Mutable {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> data;
  <font color="#0000ff">public</font> Mutable(<font color="#0000ff">int</font> initVal) {
    data = initVal;
  }
  <font color="#0000ff">public</font> Mutable add(<font color="#0000ff">int</font> x) { 
    data += x;
    <font color="#0000ff">return</font> <font color="#0000ff">this</font>;
  }
  <font color="#0000ff">public</font> Mutable multiply(<font color="#0000ff">int</font> x) {
    data *= x;
    <font color="#0000ff">return</font> <font color="#0000ff">this</font>;
  }
  <font color="#0000ff">public</font> Immutable2 makeImmutable2() {
    <font color="#0000ff">return</font> <font color="#0000ff">new</font> Immutable2(data);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Immutable2 {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> data;
  <font color="#0000ff">public</font> Immutable2(<font color="#0000ff">int</font> initVal) {
    data = initVal;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">int</font> read() { <font color="#0000ff">return</font> data; }
  <font color="#0000ff">public</font> <font color="#0000ff">boolean</font> nonzero() { <font color="#0000ff">return</font> data != 0; }
  <font color="#0000ff">public</font> Immutable2 add(<font color="#0000ff">int</font> x) { 
    <font color="#0000ff">return</font> <font color="#0000ff">new</font> Immutable2(data + x);
  }
  <font color="#0000ff">public</font> Immutable2 multiply(<font color="#0000ff">int</font> x) {
    <font color="#0000ff">return</font> <font color="#0000ff">new</font> Immutable2(data * x);
  }
  <font color="#0000ff">public</font> Mutable makeMutable() {
    <font color="#0000ff">return</font> <font color="#0000ff">new</font> Mutable(data);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> Immutable2 modify1(Immutable2 y){
    Immutable2 val = y.add(12);
    val = val.multiply(3);
    val = val.add(11);
    val = val.multiply(2);
    <font color="#0000ff">return</font> val;
  }
  <font color="#009900">// Это приводит к тому же результату:</font>
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> Immutable2 modify2(Immutable2 y){
    Mutable m = y.makeMutable();
    m.add(12).multiply(3).add(11).multiply(2);
    <font color="#0000ff">return</font> m.makeImmutable2();
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Immutable2 i2 = <font color="#0000ff">new</font> Immutable2(47);
    Immutable2 r1 = modify1(i2);
    Immutable2 r2 = modify2(i2);
    System.out.println(<font color="#004488">"i2 = "</font> + i2.read());
    System.out.println(<font color="#004488">"r1 = "</font> + r1.read());
    System.out.println(<font color="#004488">"r2 = "</font> + r2.read());
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p class="pad"><b>Immutable2</b> содержит методы, которые, как и ранее, защищали 
неизменность объекта за счет создания новых объектов в тех случаях, когда 
требуется его модификация. Эти операции осуществляются методами <b>add()</b> и 
<b>multiply()</b>. Класс-компаньон <b>Mutable</b> также имеет методы 
<b>add()</b> и <b>multiply()</b>, но они&nbsp;уже служат не для создания нового 
объекта, а для его изменения. Кроме того, в классе <b>Mutable</b> есть метод для 
создания <b>Immutable2</b> объекта с использованием данных и наоборот.&nbsp;</p>
<p class="pad">Два статических метода <b>modify1()</b> и <b>modify2()</b> демонстрируют два 
различных метода решения одной и той же задачи. В методе <b>modify1()</b> все 
действия выполняются внутри класса <b>Immutable2</b> и в процессе работы 
создаются четыре новых <b>Immutable2</b> объекта. (и каждый раз при 
переопределении&nbsp;<b>val</b> предыдущий объект становится мусором).</p>
<p class="pad">В методе <b>modify2()</b> первой операцией является <b>Immutable2 y</b> и 
создание <b>Mutable</b> объекта. (Это напоминает вызов метода <b>clone()</b>, 
рассмотренный нами ранее, но в то же время при этом создается объект нового 
типа). Затем объект <b>Mutable</b> используется для многочисленных операций 
<i>не требующих</i> создания новых объектов. В конце результаты передаются в 
<b>Immutable2</b>. Итак, вместо четырех новых объектов создаются только два 
(<b>Mutable</b> и результат <b>Immutable2</b>).</p>
<p>Такой прием имеет смысл использовать в случаях, когда:</p>
<ul>
  
<li>Вам нужно использовать неизменные объекты и&nbsp; 
  
</li><li>Вам необходимо их часто изменять или 
  
</li><li>Слишком накладно создавать новые неизменные объекты. </li>
</ul>
<h4><a name="Heading621"></a>Immutable строки</h4>
<div align="left">
<p>Ознакомьтесь со следующим кодом:&nbsp;</p>
</div>
<blockquote>
<pre><font size="2"><font color="#009900">//: Приложение А:Stringer.java</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Stringer {
  <font color="#0000ff">static</font> String upcase(String s) {
    <font color="#0000ff">return</font> s.toUpperCase();
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    String q = <font color="#0000ff">new</font> String(<font color="#004488">"howdy"</font>);
    System.out.println(q); <font color="#009900">// howdy</font>
    String qq = upcase(q);
    System.out.println(qq); <font color="#009900">// HOWDY</font>
    System.out.println(q); <font color="#009900">// howdy</font>
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p class="pad">Когда <b>q</b>&nbsp;передается в качестве параметра методу <b>upcase()</b> на 
самом деле передается копия ссылки на <b>q</b>. Объект на который указывает эта 
ссылка физически не меняет своего положения. При передаче в качестве параметров 
копируются только сами ссылки.</p>
<p class="pad">Теперь посмотрим на содержание метода <b>upcase()</b>, как вы видите, ссылка 
полученная в качестве параметра носит имя <b>s</b> и существует только на время 
работы метода <b>upcase()</b>. Когда работа метода <b>upcase()</b> завершена, 
локальная ссылка уничтожается. <b>upcase()</b> возвращает результат - 
оригинальную строку с заменой всех прописных символов на заглавные. Разумеется, 
на самом деле возвращается лишь ссылка на этот результат. Но эта ссылка 
указывает на новый объект, а объект-оригинал <b>q</b> остается в одиночестве. 
Каким же образом это происходит?</p>
<h5><a name="Heading622"></a>Неявные константы</h5>
<div align="left">
<p>Записав:</p>
</div>
<div align="left">
<p><font size="2">String s = <font color="#004488">"asdf"</font>;<br>
String x = 
Stringer.upcase(s);</font></p>
</div>
<div align="left">
<p class="pad">действительно ли вы хотите чтобы <b>uppercase()</b> <i>изменял</i> параметр? 
Как правило нет, поскольку читающий код воспринимает параметр как информацию, 
передаваемую методу не предназначенную для модификации. Это важный момент для 
тех кто стремится сделать код своих программ более удобочитаемым.</p>
</div>
<div align="left">
<p class="pad">В Си++ это сочли настолько важным, что ввели специальное ключевое слово 
<b>const</b>, дабы гарантировать программисту что ссылка (или, для Си++, 
указатель или ссылка) не могут быть использованы для модификации 
объекта-оригинала. Но это требует от программиста Си++ прилежности, чтобы он не 
забывал повсеместно вставлять <b>const</b>. Об этом легко забыть и это вносит 
лишнюю путаницу.&nbsp;</p>
</div>
<h5><a name="Heading623"></a>Перегруженный '+' и StringBuffer</h5>
<p class="pad">Объекты <b>String</b> созданы чтобы быть неизменными с применением 
технологии, рассмотренной выше. Если вы ознакомитесь с документацией по классу 
<b>String</b> (которая рассмотрена далее в этом приложении), вы увидите что все 
методы этого класса, которые изменяют объект <b>String</b> на самом деле лишь 
создают и возвращают абсолютно новый объект <b>String </b>содержащий изменения. 
При этом объект-оригинал <b>String</b> остается неизменным. В Java нет таких 
средств как <b>const</b> в Си++ для обеспечения неизменности объектов на уровне 
компиляции и если вы хотите то вам придется обеспечивать ее самостоятельно, как 
это реализовано в <b>String</b>.</p>
<p class="pad">Поскольку объект <b>String</b> неизменный, вы можете многократно дублировать 
ссылки на него. Поскольку он является объектом только для чтения, нет никакой 
опасности что действия с одной из ссылок приведут к изменению объекта, которое 
отразится на работе с другими ссылками. Так в объектах только для чтения 
решается проблема дублирующих ссылок.</p>
<p class="pad">Также представляется возможным обработка всех случаях, при которых вам 
необходимо вносить изменения в объект. С этой целью создается совершенно новый 
вариант объекта с уже внесенными изменениями, как это реализовано в 
<b>String</b>. Однако, в некоторых случаях это не эффективно. Примером является 
использование оператора '+', перегруженного для объектов <b>String</b>. Термин 
"перегруженный" означает что при использовании с классом определенного типа 
оператор выполняет специфические функции. (Операторы '+' и '+=' для 
<b>String</b> - единственные перегруженные операторы в Java и в Java программист 
не имеет возможности перегружать какие-либо иные операторы) [<a href="file:///C:/out/AppendixA1.htm#%5B83%5D">83</a>]</p>
<p class="pad">Когда '+' используется с объектами <b>String</b>, он выполняет операцию 
объединения двух и более объектов <b>String</b>:</p>
<p>String s = <font color="#004488">"abc"</font> + foo + <font color="#004488">"def"</font> + Integer.toString(47);</p>
<p class="pad">Вы можете предположить то как это <i>может</i> работать: у объекта 
<b>String</b> "abc" есть метод <b>append()</b>, который создает объект 
<b>String</b>, содержащий "abc", объединенный с содержимым <b>foo</b>. Новый 
объект <b>String</b> в свою очередь создает новый объект <b>String</b>, в 
который добавляется "def" и так далее.</p>
<p class="pad">Так могло бы все и происходить, но это требует создания множества объектов 
<b>String</b> лишь для объединения этих новых объектов <b>String</b> и в 
результате у вас получилось бы огромное количество промежуточных объектов 
<b>String</b>, требующих сбора мусора. Могу предположить что разработчики Java 
сначала пробовали именно такой подход (это урок разработчикам программного 
обеспечения - вы ничего не знаете о системе до тех пор, пока сами не напишете 
что-либо и не заставите это работать) и полученные результаты не удовлетворили 
их своей эффективностью.</p>
<p class="pad">Решением является использование модифицируемого класса-компаньона, согласно 
рассмотренному ранее принципу. Для объекта <b>String</b> классом-компаньоном 
является <b>StringBuffer</b>, и компилятор автоматически создает 
<b>StringBuffer</b> для обработки некоторых выражений, в частности при 
использовании операторов '+' и '+=' применительно к объектам <b>String</b>. Вот 
пример того как это происходит:</p>
<pre><font size="2"><font color="#009900">//: Приложение А:ImmutableStrings.java</font>
<font color="#009900">// Демонстрация StringBuffer.</font>

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ImmutableStrings {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    String foo = <font color="#004488">"foo"</font>;
    String s = <font color="#004488">"abc"</font> + foo +
      <font color="#004488">"def"</font> + Integer.toString(47);
    System.out.println(s);
    <font color="#009900">// "Равенство" с использованием StringBuffer:</font>
    StringBuffer sb = 
      <font color="#0000ff">new</font> StringBuffer(<font color="#004488">"abc"</font>); <font color="#009900">// Создает String!</font>
    sb.append(foo);
    sb.append(<font color="#004488">"def"</font>); <font color="#009900">// Создает String!</font>
    sb.append(Integer.toString(47));
    System.out.println(sb);
  }
} <font color="#009900">///:~</font></font></pre>
<p class="pad">При создании строки <b>String s</b> компилятор создает грубую копию 
последующего кода, который использует <b>sb</b>: создается <b>StringBuffer</b> и 
используется <b>append()</b> для добавления новых символов непосредственно в 
объект <b>StringBuffer</b> (это лучше чем каждый раз создавать новые копии) При 
том что это более эффективно, следует отметить что каждый раз при создании строк 
заключенных в кавычки, таких как "<b>abc</b>" или "<b>def</b>", компилятор 
превращает их в объекты <b>String</b>. Поэтому на самом деле создается больше 
объектов чем вам могло показаться, несмотря на эффективность 
<b>StringBuffer</b>.</p>
<h4><a name="Heading624"></a>Классы String и StringBuffer</h4>
<p class="pad">В этом разделе представлен обзор методов для классов <b>String</b> и 
<b>StringBuffer</b> и вы, таким образом, сможете увидеть их взаимодействие. 
Здесь рассмотрены не все методы, а только наиболее важные, имеющие отношение к 
обсуждаемой теме. Перегруженным методам отведена отдельная колонка.</p>
<p>Сначала класс <b>String</b>:</p>
<table border="1">
  <tbody>
  
<tr valign="top">
    
<th valign="top" width="117">
      
<div align="left">
      
<p><b>Метод</b><br>
</p>
</div>
</th>
<th valign="top" width="126">
      
<div align="left">
      
<p><b>Параметры, Перегрузка</b><br>
</p>
</div>
</th>
<th valign="top" width="133">
      
<div align="left">
      
<p><b>Применение</b><br>
</p>
</div>
</th>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>Constructor</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Перегруженные: значение по умолчанию, <b>String</b>, 
      <b>StringBuffer</b>, массивы <b>char</b>, массивы 
      <b>byte</b>.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Создает объекты 
    <b>String</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>length(&nbsp;)</b><br>
</p>
</div>
</td>
<td><br>
</td>
<td>
      
<div align="left">
      
<p>Количество символов в 
      <b>String</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>charAt()</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p><b>int</b> индекс<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Возвращает символ с указанным индексом ячейки 
      <b>String</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>getChars(&nbsp;), 
      getBytes(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Начальная и конечная ячейки, которые будут 
      скопированы и ячейка в внешнего массива, в которую будет произведено 
      копирование.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Копирует <b>char</b> или <b>byte</b> в внешний 
      массив.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>toCharArray(&nbsp;)</b><br>
</p>
</div>
</td>
<td><br>
</td>
<td>
      
<div align="left">
      
<p>Создает массив <b>char[]</b>, хранящий символы из 
      <b>String</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>equals(&nbsp;), 
      equals-IgnoreCase(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p><b>String</b> с которой проводится 
      сравнение.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Проверка на равенство содержимого двух 
      <b>Strings</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>compareTo(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p><b>String</b> с которой проводится 
      сравнение.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Результат отрицательный, ноль или положительный, на 
      основании лексиграфического 
      упорядочения <b>String</b> и параметра. Заглавные и прописные 
      символы не равны!<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>regionMatches(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Смещение в текущей <b>String</b>, другой 
      <b>String</b> и смещение и длина фрагмента для сравнения. Перегрузка 
      добавляет "игнорировать регистр символов."<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Результат <b>boolean</b>, свидетельствующий о 
      совпадении фрагментов.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>startsWith(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p><b>String</b>, который может начинать текущий 
      <b>String</b>. Перегрузка добавляет параметр для указания 
      смещения.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Результат <b>boolean</b> свидетельствует о том, 
      начинается ли <b>String</b> с передаваемой в качестве параметра 
      строки.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>endsWith(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p><b>String</b>, который может завершать текущий 
      <b>String</b>.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Результат <b>boolean</b> свидетельствует о том, 
      завершается ли <b>String</b> передаваемой в качестве параметра 
      строкой.</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>indexOf(&nbsp;), 
      lastIndexOf(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Перегруженные: <b>char</b>, <b>char</b> и индекс 
      начала, <b>String</b>, <b>String</b> и индекс 
    начала.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Возвращает -1 если аргумент не найден в данном 
      <b>String</b>, иначе возвращается индекс начала найденного фрагмента. 
      <b>lastIndexOf(&nbsp;)</b> осуществляет поиск начиная с конца 
      строки.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>substring(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Перегруженный: Индекс начала, индекс начала, и 
      индекс конца.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Возвращает новый объект <b>String</b>, содержащий 
      указанный набор символов.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>concat(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p><b>String</b> для 
объединения<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Возвращает новый объект <b>String</b>, содерщащий 
      символы оригинального объекта <b>String</b> и расположенные вслед за ними 
      символы переданные в качестве параметра.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>replace(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Старый символ используемый для поиска, новый символ 
      используемый для замены.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Возвращает новый объект <b>String</b> с результатами 
      проведенной замены. Если искомый символ не найден, используется старый 
      <b>String</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>toLowerCase(&nbsp;) 
      toUpperCase(&nbsp;)</b><br>
</p>
</div>
</td>
<td><br>
</td>
<td>
      
<div align="left">
      
<p>Возвращает новый объект <b>String</b> с измененными 
      на соответствующий регистр символами. Если изменения не требуется, 
      используется старый <b>String</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>trim(&nbsp;)</b><br>
</p>
</div>
</td>
<td><br>
</td>
<td>
      
<div align="left">
      
<p>Возвращает новый объект <b>String</b> с сокращением 
      с обоих концов пробелов до одинарных. Если изменения не требуются, 
      используется старый <b>String</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>valueOf(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Перегрузка: <b>Object</b>, <b>char[]</b>, 
      <b>char[]</b> и смещение и указатель, <b>boolean</b>, <b>char</b>, 
      <b>int</b>, <b>long</b>, <b>float</b>, 
    <b>double</b>.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Возвращает <b>String</b>, содержащий символьное представление 
      параметра.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>intern(&nbsp;)</b><br>
</p>
</div>
</td>
<td><br>
</td>
<td>
      
<div align="left">
      
<p>Создает один 
      и только один <b>String</b> с уникальной последовательностью 
      символов.<br>
</p>
</div>
</td>
</tr>
</tbody>
</table>
<p class="pad">Как вы видите, все методы <b>String</b> возвращают новый объект <b>String</b> 
в тех случаях, когда необходимо его содержимое. Также обратите внимание на то 
что если модификация не требуется, возвращается ссылка на оригинал 
<b>String</b>. Это позволяет сэкономить память и избавляет от лишних 
трудностей.</p>
<p>Теперь рассмотрим класс <b>StringBuffer</b>:</p>
<table border="1">
  <tbody>
  
<tr valign="top">
    
<th valign="top" width="90">
      
<div align="left">
      
<p><b>Метод</b><br>
</p>
</div>
</th>
<th valign="top" width="152">
      
<div align="left">
      
<p><b>Параметры, перегрузка</b><br>
</p>
</div>
</th>
<th valign="top" width="125">
      
<div align="left">
      
<p><b>Применение</b><br>
</p>
</div>
</th>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>Constructor</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Перегруженный: значение по умолчанию, длина 
      создаваемого буфера, <b>String</b> используемый в качестве 
      источника.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Создает новый объект 
      <b>StringBuffer</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>toString(&nbsp;)</b><br>
</p>
</div>
</td>
<td><br>
</td>
<td>
      
<div align="left">
      
<p>Создает <b>String</b> используя текущий 
      <b>StringBuffer</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>length(&nbsp;)</b><br>
</p>
</div>
</td>
<td><br>
</td>
<td>
      
<div align="left">
      
<p>Количество символов в 
      <b>StringBuffer</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>capacity(&nbsp;)</b><br>
</p>
</div>
</td>
<td><br>
</td>
<td>
      
<div align="left">
      
<p>Возвращает текущий объем занимаемой 
      памяти.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>ensure-</b><br>
<b>Capacity(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Integer определяющий желаемый объем 
      памяти.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p><b>StringBuffer</b> резервирует как минимум 
      указанный объем памяти.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>setLength(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Integer определяющий новую длину строки символов в 
      буфере.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Расширяет ли укорачивает строку симоволов. Есл 
      строка расширяется, новые ячейки заполняются 
    нулями.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>charAt(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Integer указывающий на позицию 
      элемента.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Возвращает <b>char</b> для заданной позиции 
      буфера.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>setCharAt(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Integer, указывающий на позицию элемента и новое 
      значение <b>char</b> для этого элемента.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Изменяет значение в указанной 
      позиции.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>getChars(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Начало и конец копируемого фрагмента, массив в 
      который производится копирование, индекс в целевом 
      массиве.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Выполняет копирование символов <b>char</b> во 
      внешний массив. В отличие от <b>String</b> здесь нет метода 
      <b>getBytes(&nbsp;)</b>.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>append(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Перегруженный: <b>Object</b>, <b>String</b>, 
      <b>char[]</b>, <b>char[]</b> со смещением и длиной, <b>boolean</b>, 
      <b>char</b>, <b>int</b>, <b>long</b>, <b>float</b>, 
      <b>double</b>.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Параметр преобразуется в строку и добавляется в 
      конец текущего буфера. При необходимости размер буфера 
      увеличивается.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>insert(&nbsp;)</b><br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Перегруженный, для всех первым параметром является 
      смещение с которым выполняется вставка: <b>Object</b>, <b>String</b>, 
      <b>char[]</b>, <b>boolean</b>, <b>char</b>, <b>int</b>, <b>long</b>, 
      <b>float</b>, <b>double</b>.<br>
</p>
</div>
</td>
<td>
      
<div align="left">
      
<p>Второй параметр преобразуется в строку и вставляется 
      в текущий буфер начиная с указанного смещения. При необходимости размер 
      буфера увеличивается.<br>
</p>
</div>
</td>
</tr>
  
<tr valign="top">
    
<td>
      
<div align="left">
      
<p><b>reverse(&nbsp;)</b><br>
</p>
</div>
</td>
<td><br>
</td>
<td>
      
<div align="left">
      
<p>Порядок следования символов в буфере меняется на 
      противоположный.<br>
</p>
</div>
</td>
</tr>
</tbody>
</table>
<p class="pad">Наиболее часто используется метод <b>append()</b>, применяемый компилятором 
при обработке выражений <b>String</b>, связанных операторами '+' и '+='. Метод 
<b>insert()</b> имеет ту же форму и оба метода выполняют операции с 
использованием буфера, не создавая при этом новых объектов. </p>
<h4><a name="Heading625"></a>Особенности строк</h4>
<p class="pad">Теперь вы видите что класс <b>String</b> - не совсем обычный класс Java. У 
String много особенностей, не последней из них является тот факт что 
<b>String</b> является одним из встроенных и фундаментальных классов Java. Кроме 
того, заключенные в кавычки символы автоматически преобразуются компилятором в 
<b>String</b>, и с ним допускается применение специальных перегруженных 
операторов + и +=. В этом приложении вы рассмотрели и другие специальные 
особенности: тщательной реализации неизменности используя компаньон 
<b>StringBuffer</b>, а также дополнительные особенности компиляции.</p>
<h3><a name="Heading626"></a>Итоги</h3>
<p class="pad">Поскольку в Java широко используются ссылки и поскольку
каждый создаваемый объект создается в heap и становится мусором сразу
же после того как перестает использоваться, поведение и манипуляция с
объектом изменяется, особенно при передаче и возврате объектов.
Например, в Си или Си++, если вы хотите инициализировать некоторые
фрагменты памяти в методе, вы можете использовать для получения этого
адреса получаемый методом параметр. Иначе вам пришлось бы беспокоиться
на счет того, существует ли до сих пор необходимый вам объект или он
был уничтожен. Поэтому интерфейс подобных методов несколько усложнен.
Но в Java вы не должны волноваться о существовании объекта, за вас обо
всем позаботятся. Вы можете создавать объекты тогда, когда вам
захочется, не беспокоясь о самой механике создания объекта: вы просто
передаете ссылку. Иногда такая простота практически незаметна, а иногда
просто поражает.</p>
<p>За эти волшебные возможности от вас 
требуется учитывать следующие два момента:</p>
<ol>
  
<li>Вам придется мириться с некоторой 
  потерей производительности, связанной с управлением памятью (хотя она может 
  быть весьма незначительной) и неопределенностью в скорости работы 
  программы(поскольку при недостатке памяти может быть активирован сборщик 
  мусора). Для большинства приложений выгоды превышают недостатки а наиболее 
  узкие места можно обойти, используя <b>native</b> методы (см. Приложение 
  B) 
  
</li><li>Дублирующие ссылки: иногда вы 
  можете случайно столкнуться с возникновением двух ссылок на один и тот же 
  объект, что может привести к негативным последствиям лишь в том случае, если 
  обеим ссылкам присваиваются указатели на <i>различные</i> объекты. Вот где 
  потребуется уделить более пристальное внимание и, там где это необходимо, 
  использовать метод <b>clone()</b> для объекта, чтобы защититься от 
  непредвиденных изменений. В качестве альтернативы, когда для&nbsp; для 
  повышения эффективности целесообразно использовать дублирующие ссылки, вы 
  можете применить неизменные объекты, которые могут возвращать объекты того же 
  или иного типа, но не могут использоваться для изменения первоначального 
  объекта, так что эти изменения не отразятся на дублирующих ссылках. 
  </li>
</ol>
<p class="pad">Некоторые люди считают что клонирование в Java плохо реализовано и при 
наследовании используют собственные версии клонирования [<a href="file:///C:/out/AppendixA1.htm#%5B84%5D">84</a>] не пользуясь вызовом метода 
<b>Object.clone()</b>, что избавляет от необходимости наследования интерфейса 
<b>Cloneable</b> и перехвата <b>CloneNotSupportedException</b>. Это весьма 
подходящий прием, поскольку clone() весьма редко поддерживается в пределах 
стандартных библиотек Java, к тому же он довольно безопасен.</p>
<h3><a name="Heading627"></a>Упражнения</h3>
<p class="pad">Решения предложенных упражнений содержатся в электронном документе <i>The 
Thinking in Java Annotated Solution Guide (Думая на Java. Ответы на вопросы с 
комментариями)</i>, доступном за умеренную плату на сайте <i><a href="http://www.bruceeckel.com/" target="_blank">http://www.bruceeckel.com/</a></i>.</p>
<ol>
  
<li>Реализуйте дублирующие ссылки второго уровня. Создайте метод, который 
  получает ссылку на объект, но при этом не изменяет этот объект, но вызывает 
  другой метод, передает ему ссылку и этот второй метод изменяет объект. 
  
</li><li>Создайте класс <b>myString</b>, содержащий объект <b>String</b>, который 
  вы инициализируете в конструкторе, используя параметр конструктора.&nbsp; 
  Добавьте метод <b>toString()</b> и метод <b>concatenate()</b>, который 
  объединяет объект <b>String</b> с текстовой строкой. Наследуйте <b>clone()</b> 
  в классе <b>myString</b>. Создайте два статических (<b>static</b>) метода, 
  каждый из которых получает в качестве параметра ссылку <b>myString x</b> и 
  вызывает <b>x.concatenate("тест")</b>, но во втором методе перед этим 
  вызывается метод <b>clone()</b>. Проверьте работу обоих методов и укажите на 
  различия в их работе. 
  
</li><li>Создайте класс <b>Battery</b> содержащий <b>int</b>, который является 
  номером батареи (уникальный идентификатор). Сделайте его клонируемым и 
  создайте для него метод &nbsp;<b>toString()</b>. Затем создайте класс 
  <b>Toy</b>, содержащий массив <b>Battery</b> и метод <b>toString()</b>, 
  распечатывающий номера всех батареек. Напишите <b>clone()</b> для <b>Toy</b>, 
  который автоматически клонирует все свои <b>Battery</b> объекты. Протестируйте 
  его, клонируя <b>Toy</b> и распечатав результаты. 
  
</li><li>Модернизируйте код примера <b>CheckCloneable.java</b> таким образом, чтобы 
  все методы <b>clone()</b> обрабатывали ситуацию 
  <b>CloneNotSupportedException</b> перед тем как возвращать ее вызвавшим их 
  методам. 
  
</li><li>Используя технологию изменяемых классов-компаньонов, создайте неизменный 
  класс, содержащий <b>int</b>, <b>double</b> и массив <b>char</b>. 
  
</li><li>Модернизируйте код примера Compete.java, увеличив количество объектов в 
  классах <b>Thing2</b> и <b>Thing4</b> и посмотрите, удастся ли вам определить 
  как зависят задержки времени от их сложности, и является ли эта зависимость 
  линейной или нет. 
  
</li><li>Модернизируйте код примера <b>Snake.java</b>, реализовав вариант глубокого 
  копирования "змеи". 
  
</li><li>Наследуйте <b>ArrayList</b> и реализуйте в его методе <b>clone()</b> 
  возможность глубокого копирования. </li>
</ol>
<hr>

<p><a name="[79]">[79]</a> В Си, где в основном работа происходит с данными малых 
объемов, по умолчанию осуществляется "передача по значению". Для Си такая форма 
весьма эффективна, но при работе с объектами эффективность "передачи по 
значению" значительно снижается. Кроме того, разработка классов с поддержкой 
"передачи по значению" на Си - весьма непростая задача.</p>
<p><a name="[80]">[80]</a> Это слово вы не встретите в словаре английского (и 
русского) языка, но оно применяется в библиотеках Java, и поэтому включено сюда. 
Надеюсь что это не вызовет недоразумений.</p>
<p><a name="[81]">[81]</a> В качестве контраргумента этому утверждению вы можете 
создать простой "пример". Например такой:</p>
<p><font color="#0000ff">public</font> <font color="#0000ff">class</font> Cloneit 
<font color="#0000ff">implements</font> Cloneable {<br>
&nbsp;&nbsp;&nbsp; <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main (String[] args)<font color="#0000ff"><br>
&nbsp;&nbsp; throws </font>CloneNotSupportedException 
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cloneit a = <font color="#0000ff">new</font> 
Cloneit();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cloneit b = 
(Cloneit)a.clone();<br>
&nbsp;&nbsp;&nbsp; }<br>
}</p>
<p class="pad">Однако, он будет работать лишь за счет того, что <b>main()</b> является 
методом класса <b>Cloneit</b> и, таким образом, имеет право вызывать защищенный 
метод базового класса <b>clone()</b>. Если вы попробуете осуществить этот вызов 
из другого класса, это неминуемо приведет к ошибке компиляции.</p>
<p><a name="[82]">[82]</a> За исключением несчастного авокадо.</p>
<p><a name="[83]">[83]</a> Си++ предоставляет программисту возможность по своему 
желанию перегружать операторы. Поскольку зачастую это весьма сложный процесс 
(см. раздел 10 книги Думая на Си++, 2-я редакция, Prentice-Hall, 2000), 
разработчики Java сочли что это "нежелательный элемент", который не должен 
применяться в Java. Однако они таки не реализовали это свое решение, и это не 
так уж плохо, поскольку в результате по иронии судьбы перегрузка операторов в 
Java использовать гораздо проще чем в Си++. Более подробную информацию вы 
найдете на сайте Python (www.Python.org), на котором хранится сборщик мусора и 
простые примеры перегрузки операторов.</p>
<p><a name="[84]">[84]</a> Дуг Леа, который помогал при решении этой проблемы 
предложил мне такой выход, сказав что он просто создает функцию 
<b>duplicate()</b> для каждого класса.</p>

<hr>
 
</body></html>