<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head lang="en"><!-- by.ru advertising --><script language="JavaScript" src="Chapter13_files/upper.js"></script><!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:04/24/2000
Translation Time:06:36:38
Translation Platform:Win32
Number of Output files:23
This File:Chapter13.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
--><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>13: Создание окон и Апплеты</title></head>





<body bgcolor="#ffffff">
<div align="center"> <font face="Verdana" size="-1"> </font> 
  <center>
    <h2><font face="Verdana">
  Thinking in Java, 2nd edition, Revision 11</font></h2>
  <h3><font face="Verdana">©2000 by Bruce Eckel</font></h3>
  
    <font face="Verdana" size="-1"> [ <a href=" Chapter12.html">Предыдущая глава</a> 
    ] [ <a href=" SimpleContents.html">Содержание</a> ] [ <a href=" Contents.html">Оглавление</a> 
    ] [ <a href=" DocIndex.html">Индекс</a> ] [ <a href=" Chapter14.html">Следующая 
    глава </a> ] </font> 
  </center>
  <p></p></div>
<a name="Chapter_14"></a><a name="Chapter_15"></a><a name="_Toc375545444"></a><a name="_Toc477690733"></a><a name="_Toc481064781"></a><a name="Heading414"></a><font face="Verdana">
<h1 align="left"> 13: Создание окон и Апплеты</h1>
</font>
<p><font face="Georgia" size="4">Фундаментальный принцип дизайна - “делать 
  простые вещи легкими, а трудные - возможными”</font><sup><font face="Georgia" size="2">.</font></sup><a href="#fn61">[61]</a><br>
</p>
<p><font face="Georgia">Основной целью дизайна библиотеки графического интерфейса 
  пользователя (GUI) в Java 1.0 было позволить программисту построить GUI, который 
  хорошо выглядит на всех платформах. <a name="Index1546"></a><a name="Index1547"></a><a name="Index1548"></a>Эта 
  цель не была достигнута. Вместо этого Абстрактный Оконный Инструментарий Java 
  1.0 ( <i>Аbstract Window Toolkit</i> - AWT) вводил GUI, который выглядел достаточно 
  заурядно на всех платформах. Кроме того, он был ограничен: вы могли использовать 
  только четыре шрифта и вы не могли получить доступ к любому более сложному и 
  тонкому GUI элементу, имеющемуся в вашей операционной системе. Модель программирования 
  Java 1.0 AWT также была слабая и не объектно-ориентированная. Студент на одном 
  из моих семинаров (который был в Sun во время создания Java) объяснил почему: 
  начальная версия AWT была концептуализирована, разработана и реализована за 
  месяц. Конечно - это чудо продуктивности, а также является предметом объяснения, 
  почему дизайн так важен.</font></p>
<p><font face="Georgia">Ситуация улучшилась с появлением модели событий с Java 
  1.1 AWT, которая стала намного понятней, использовала объектно-ориентированный 
  подход, наряду с добавлением JavaBeans, имела модель компонентного программирования, 
  которая ориентируется на легкое создание среды визуального программирования. 
  Java 2 завершила переход от старого Java 1.0 AWT, тщательно заменяя все, начиная 
  с <a name="Index1551"></a><a name="Index1552"></a>Фундаментальных Классов Java 
  (<i>Java Foundation Classes</i> - JFC), часть GUI, которая теперь называется 
  “<a name="Index1553"></a>Swing”. Теперь есть множество легких в 
  использовании и понимании JavaBeans, которые могут быть перетянуты и брошены 
  (наряду с программированием в ручную) для создания GUI, которым вы можете (наконец) 
  быть удовлетворены. Правила “третьей ревизии” программной индустрии 
  (продукт не считается хорошим до третьей ревизии) выглядит истинным для языков 
  программирования.</font></p>
<p><font face="Georgia">Эта глава не охватывает ничего наиболее современного - 
  библиотеку Java 2 Swing, а разумно считает, что Swing - это финальная стадия 
  GUI библиотеки для Java. Если по некоторым причинам вам необходимо использовать 
  изначальную “старую” библиотеку AWT (потому что вы поддерживаете 
  старый код или у вас есть ограничения со стороны броузера), вы можете найти 
  это описание в первой редакции этой книги, доступной на <i>www.BruceEckel.com</i> 
  (также включенной в CD-ROM, прилагаемый к этой книге).</font></p>
<div align="left"></div>
<p><font face="Georgia">Далее в этой главе вы увидите, как отличаются вещи, когда 
  вы хотите создать апплет и когда вы хотите создать обычное приложение с использование 
  Swing, и как создать программу, являющуюся и приложением и апплетом, так чтобы 
  она могла запускаться в броузере или из командной строки. Почти все GUI примеры 
  в этой книге могут быть исполнены либо как апплет, либо как приложение.</font></p>
<p><font face="Georgia">Пожалуйста, запомните, что это не полный список всех компонентов 
  Swing или всех методов для описанных классов. То, что вы увидите здесь, будет 
  простым. Библиотека Swing обширна, и цель этой главы только ввести вас, познакомив 
  с сутью и прелестью концепции. Если вам нужно больше, то, вероятно, Swing даст 
  вам то, что вы хотите, если вы захотите заняться исследованием.</font></p>
<p><font face="Georgia">Здесь я принимаю во внимание, что вы имеете закаченную 
  и установленную (бесплатную) документацию по библиотеке Java в формате HTML, 
  имеющуюся на <i>java.sun.com</i> и буду рассматривать классы <b>javax.swing</b> 
  этой документации, чтобы увидеть все детали и методы библиотеки Swing. Из-за 
  простоты дизайна Swing здесь вы найдете достаточно информации для решения вашей 
  проблемы. Есть много (более толстых) книг, посвященных исключительно Swing, 
  и вы можете перейти к ним, если вам необходима большая глубина охвата, или если 
  вы хотите изменить родное поведение Swing.</font></p>
<p><font face="Georgia">Когда вы выучите Swing, вы обнаружите:<a name="Index1554"></a><a name="Index1555"></a></font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Swing - наиболее лучшая 
    модель программирования, по сравнению с теми, которые вы, вероятно, видели 
    в других языках и средах разработки. JavaBeans (которая будет введена ближе 
    к концу книги) - это рабочее пространство для работы библиотеки.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">“Построители GUI” 
    (среды визуального программирования) строго следят за аспектами полновесной 
    среды Java разработки. JavaBeans и Swing позволяют построителю писать код 
    для вас при помещении компонентов на форму, используя графические инструменты. 
    Это не только многократно ускоряет разработку во время построения GUI, это 
    позволяет увеличить экспериментирование и, таким образом, позволяет пробовать 
    больше дизайнов и, в конце концов, прийти к какому-то одному лучшему.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Простота и хорошо спроектированная 
    природа Swing означает, что если даже вы используете построитель GUI, а не 
    пишете код руками, результирующий код все равно будет оставаться понятным 
    — это решает большую проблему построителей GUI, которые легко генерируют 
    не читаемый код.</font>
</li></ol>
<p><font face="Georgia">Swing содержит все компоненты, которые вы ожидаете увидеть 
  в современном интерфейсе пользователя, все, начиная от кнопок, содержащих рисунки, 
  заканчивая деревьями и таблицами. Это большая библиотека, но она разработана 
  так, чтобы иметь определенную сложность <font color="#0000ff">для</font> имеющихся 
  под рукой задач — <font color="#0000ff">если</font> что-то просто, вы не 
  пишите много кода, но если вы <font color="#0000ff">пытаетесь создать</font> 
  более сложную вещь, ваш код, вероятно, становится более сложным. Это значит 
  легкость в подходе, но вы получите мощь, <font color="#0000ff">если</font> она 
  вам нужна.</font></p>
<p><font face="Georgia">Все, что вы захотите от Swing, может быть названо “ортогональностью 
  использования”. То есть, как только вы схватите главные идеи библиотеки, 
  вы можете применять их везде. Главным образом, из-за стандартного соглашения 
  об именах, большую часть времени, что я писал эти примеры, я мог догадаться 
  об именах методов, и был прав без дополнительного поиска. Это, конечно, отличительный 
  признак хорошего дизайна библиотеки. Кроме того, вы, как правило, можете включать 
  компоненты в другие компоненты, и вещи будут работать правильно.</font></p>
<p><font face="Georgia">Для скорости все <a name="Index1556"></a>компоненты <a name="Index1556"></a>являются 
  “легковесными”, и Swing целиком написана на Java для портативности.</font></p>
<p><a name="Index1557"></a><a name="Index1558"></a><font face="Georgia">Клавиатура 
  используется автоматически — вы можете запускать Swing приложения без 
  использования мыши, и это не требует дополнительного программирования. Поддержка 
  скроллинга не требует усилий — вы просто оборачиваете ваш компонент с 
  помощью <b>JScrollPane</b>, когда вы добавляете его в вашу форму. Такие особенности, 
  как инструмент подсказок, обычно требует одну строку кода для использования.</font></p>
<p><font face="Georgia"> </font><font face="Georgia">Swing также поддерживает 
  радикальные особенности, называемые “настраиваемы look and feel”, 
  который означает, что UI может динамически меняться в соответствии с ожиданием 
  пользователя для разных платформ и разных операционных систем. Даже возможно 
  (хотя трудно) выдумать ваш собственный вид.</font><a name="_Toc375545446"></a><a name="_Toc481064782"></a></p>
<a name="Heading415"></a><font face="Verdana"></font> 
<h2 align="left"><font face="Verdana">Основы апплета<a name="Index1559"></a></font></h2>
<p><font face="Georgia">Одна из целей разработки Java - это создание <i>апплетов</i>, 
  которые являются маленькими программами, запускаемыми внутри Web броузера. Поскольку 
  они должны быть безопасны, апплеты ограничены в своих возможностях. Однако апплеты 
  являются мощным инструментом для поддержки программирования на стороне клиента 
  - главной способности для Web.</font><a name="_Toc375545464"></a><a name="_Toc481064783"></a></p>
<a name="Heading416"></a>
<h3 align="left"><font face="Verdana"> Ограничения апплета<a name="Index1560"></a><a name="Index1561"></a><a name="Index1562"></a></font></h3>
<p><font face="Georgia">Программирование апплетов настолько ограничено, что часто 
  рассматривается как пребывание “внутри песочницы”, так как вы всегда 
  есть кто-то — то есть, система безопасности Java времени выполнения — 
  наблюдающий за вами.</font></p>
<p><font face="Georgia">Однако вы можете выйти из песочницы и писать обычные приложения, 
  а не апплеты, в этом случае вы можете получить доступ к другим возможностям 
  вашей OS. Мы писали обычные приложения на протяжении всей книги, но они были 
  <i>консольными приложениями</i> без каких-то графических компонентов. Swing 
  также можно использовать для построения GUI обычных приложений.</font></p>
<p><font face="Georgia">Обычно вы можете ответить на вопрос, что позволено делать 
  апплету, взглянув на то, для чего он предназначен: расширить функциональность 
  Web страницы в броузере. Так как, как тот, кто бродит по Internet, вы никогда 
  реально не знаете, расположена ли Web страница дружественно к вам или нет, вам 
  нужен код, запуск которого безопасен. Так что вы, вероятно, заметите огромные 
  ограничения:</font><font face="Georgia"><a name="Index1563"></a></font></p>
<ol>
  <li><font face="Georgia"><i>Апплет не может касаться локального диска</i>. Это 
    означает запись <i>или</i> чтение, так как вы не захотите, чтобы апплет прочел 
    и передал приватную информацию через Internet без вашего разрешения. Запись, 
    конечно, предотвращается, так как это открывает доступ вирусам. Java предлагает 
    <i>цифровую подпись</i> для апплетов. Многие ограничения апплетов освобождаются, 
    когда вы согласитесь <i>доверить апплету</i> (который подписан источником, 
    которому вы доверяете) доступ к вашей машине.</font> 
  </li><li><font face="Georgia"><i>Апплеты занимают много времени при отображении</i>, 
    так как вы должны загрузить все вещи каждый раз, включая разные обращения 
    к серверам для разных классов. Ваш броузер может кэшировать апплеты, но это 
    не гарантируется. Поэтому, вы всегда пакуйте ваши апплеты в JAR (Java Archive) 
    файл, который комбинирует все компоненты апплета (включая другие <b>.class</b> 
    файлы наряду с картинками и звуками) вместе в единственный компрессированный 
    файл, который может быть загружен в одном обращении сервера. “Цифровая 
    подпись” возможна для каждого индивидуального вхождения в JAR файл.</font><a name="_Toc375545465"></a><a name="_Toc481064784"></a> 
</li></ol>
<a name="Heading417"></a>
<h3 align="left"><font face="Verdana"> Преимущества апплетов</font></h3>
<p><font face="Georgia">Если вы можете жить внутри ограничений, апплеты имеют 
  определенные преимущества, особенно при построении клиент/серверных или сетевых 
  приложений:</font><font face="Georgia"><a name="Index1565"></a><a name="Index1566"></a></font></p>
<ol>
  <li><font face="Georgia"><i>Не требуется установки</i>. Апплет имеет истинную 
    независимость от платформы (включая возможность легкого проигрывания звуковых 
    файлов), так что вам не нужно делать никаких изменений вашего кода для различных 
    платформ и при этом никто не должен выполнять какое-либо “выщипывание” 
    при инсталляции. Фактически, инсталляция происходит всякий раз, когда пользователь 
    загружает Web страницу, содержащую апплет, так что обновления происходят легко 
    и автоматически. В традиционных системах по технологии клиент/сервер строительство 
    и установка новых версий клиентского программного обеспечения часто становится 
    кошмаром.</font> 
  </li><li><font face="Georgia"><i>Вам не нужно беспокоится о плохом коде, являющемся 
    причиной крушения чьей-то системы</i>, потому что система безопасности встроена 
    в ядро языка Java и в структуру апплета. Наряду с предыдущим пунктом, это 
    делает Java популярным для, так называемых, Intranet приложений клиент/сервер, 
    которые живут только в пределах компании или на ограниченной области операций, 
    где среда пользователя (Web броузер и дополнения) может определять и/или управляет 
    приложением.</font> 
</li></ol>
<div align="left">
  <p><font face="Georgia">Так как апплеты автоматически интегрируются в HTML, 
    вы имеете встроенную, платформо-независимую систему поддержки апплетов. Это 
    интересный поворот, так как мы привыкли иметь часть документации программы, 
    а не наоборот.</font><a name="_Toc481064785"></a></p>
  </div>
<a name="Heading418"></a>
<h3 align="left"><font face="Verdana"> Рабочее пространство приложения</font></h3>
<p><font face="Georgia">Библиотеки часто группируются в зависимости от их функциональности. 
  Некоторые библиотеки, например, используются как есть. Классы <b>String</b> 
  и <b>ArrayList</b> являются примерами стандартной библиотеки Java. Другие библиотеки 
  разрабатывались специально как строительные кирпичики для создания других классов. 
  Определенная категория библиотеки представляет <a name="Index1567"></a><a name="Index1568"></a><i>рабочее 
  пространство приложения</i>, чьей целью является помощь вам в построении приложения. 
  Она обеспечивает классы или набор классов, которые производят основу поведения, 
  которая вам необходима в каждом приложении определенного типа. Затем, для настройки 
  поведения согласно вашим требованиям, вы наследуете от класса приложения и перегружаете 
  интересующие методы. Рабочее пространство приложения по умолчанию является механизмом 
  управления, вызывающим ваши перегруженные методы в определенное время. Рабочее 
  пространство приложения - это хороший пример “отделения тех вещей, которые 
  меняются, от тех, которые остаются теми же”, так как оно пробует локализовать 
  все уникальные части программы в перегружаемых методах </font><a href="#fn62">[62]</a><font face="Georgia">.</font></p>
<p><font face="Georgia">Апплеты строятся с использованием рабочего пространства 
  приложения. Вы наследуете от класса <b>JApplet</b> и перегружаете соответствующие 
  методы. Есть несколько методов, которые управляют созданием и выполнением апплета 
  на Web странице:</font></p>
<table border="1" width="100%">
  <tbody><tr valign="top"> 
    <th colspan="1" rowspan="1" valign="top" width="72"> <font face="Georgia"><b>Метод</b></font></th>
    <th colspan="1" rowspan="1" valign="top" width="288"> <font face="Georgia"><b>Операция</b></font></th>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>init(&nbsp;)</b></font></td>
    <td> <font face="Georgia">Автоматически вызывается для выполнения начальной 
      инициализации апплета, включая компоновку компонент. Вы всегда перегружаете 
      этот метод.</font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>start(&nbsp;)</b></font></td>
    <td> <font face="Georgia">Вызывается каждый раз, когда апплет переносится 
      в поле зрения Web броузера, чтобы позволить апплету начать нормальные операции 
      (особенно те, которые останавливаются в методе <b>stop(&nbsp;)</b>). Также 
      вызывается после <b>init(&nbsp;)</b>.</font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>stop(&nbsp;)</b></font></td>
    <td> <font face="Georgia">Вызывается каждый раз, когда апплет выходит из поля 
      зрения Web броузера, чтобы позволить апплету завершить дорогостоящие операции. 
      Также вызывается перед <b>destroy(&nbsp;)</b>.</font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>destroy(&nbsp;)</b></font></td>
    <td> <font face="Georgia">Вызывается тогда, когда апплет начинает выгружаться 
      со страницы для выполнения финального освобождения ресурсов, когда апплет 
      более не используется.</font></td>
  </tr>
</tbody></table>
<p></p>
<p><font face="Georgia">С этой информацией вы готовы создать простой апплет:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c13:Applet1.java</font>
<font color="#009900" size="+1">// Очень простой апплет.</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> Applet1 <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> init() {
    getContentPane().add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Applet!"</font>));
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Обратите внимание, что апплету не нужен <b>main(&nbsp;)</b>. 
  Это то, что тянется из рабочего пространства приложения; вы помещаете код запуска 
  в </font><font face="Georgia"> <b>init(&nbsp;)</b>.</font></p>
<p><font face="Georgia">В этой программе есть только одно действие: помещение 
  текстовой метки в апплет с помощью класса <a name="Index1569"></a><b>JLabel</b> 
  (в старом AWT есть соответствующее имя <b>Label</b>, точно так же как и для 
  других имен компонент, так что вы часто будете видеть, что для Swing используется 
  лидирующая “<b>J</b>”). Конструктор для этого класса принимает <b>String</b> 
  и использует его для создания метки. В приведенной выше программе эта метка 
  помещается на форму.</font></p>
<p><font face="Georgia">Метод <b>init(&nbsp;)</b> отвечает за помещение всех компонент 
  на форму, используя метод <b>add(&nbsp;)</b>. Вы можете подумать, что вы способны 
  просто вызвать <b>add(&nbsp;)</b> сам по себе, и, фактически, этот способ использовался 
  в старой библиотеке AWT. Однако Swing требует от вас, чтобы все компоненты добавлялись 
  в “панель содержания” формы, так что вы должны вызывать <b>getContentPane(&nbsp;)</b>, 
  как часть процесса <b>add(&nbsp;)</b></font><font face="Georgia">.</font><a name="_Toc481064786"></a></p>
<div align="left"></div>
<a name="Heading419"></a>
<h3 align="left"><font face="Verdana"> Запуск апплетов в Web броузере</font></h3>
<p><font face="Georgia">Для запуска этой программы вы должны поместить его внутрь 
  Web страницы и просмотреть эту страницу внутри вашего Web броузера, поддерживающего 
  Java. Для помещения <a name="Index1571"></a><a name="Index1572"></a>апплета 
  внутрь Web страницы, вы помещаете специальный ярлык в HTML источник этой Web 
  страницы <a href="#fn63">[63]</a>, чтобы сказать странице, как загрузить и запустить 
  апплет.</font></p>
<p><font face="Georgia">Этот процесс был очень простым, когда сам язык Java был 
  очень прост, и каждый оказывается в одном и том же положении и имел одинаковую 
  поддержку Java в своем Web броузере. Таким образом, вы могли обойтись очень 
  простым кусочком HTML внутри вашей Web странице, как здесь</font><font face="Georgia">:</font></p>
<blockquote>
  <pre><font size="+1">&lt;applet code=Applet1 width=100 height=50&gt;
&lt;/applet&gt;</font></pre>
</blockquote>
<p><font face="Georgia">Затем, с началом войн броузеров и языков, мы (программисты 
  и одиночные конечные пользователи) понесли потери. Спустя некоторое время JavaSoft 
  понял, что мы более не можем ожидать, что броузер поддерживает правильную версию 
  Java, и было только одно решение: обеспечить некоторый род дополнения, которое 
  будет предупреждать механизм расширения броузера. При использовании механизма 
  расширения (который разработчик броузера не может отключить — в попытке 
  получить наибольшую прибыль — без нарушения работы всех расширений сторонних 
  разработчиков), JavaSoft гарантирует, что Java не может быть выброшена из Web 
  броузера враждебным продавцом.</font></p>
<p><font face="Georgia">В Internet Explorer механизм расширения - это управление 
  ActiveX, а в Netscape - это встраиваемый модуль. В вашем HTML коде вы должны 
  вставить ярлыки для поддержки обоих. Вот как будет выглядеть HTML кода того 
  простого примера для </font><font face="Georgia"> <b>Applet1</b>:</font><a href="#fn64">[64]</a></p>
<blockquote>
  <pre><font size="+1">//:! c13:Applet1.html
&lt;html&gt;&lt;head&gt;&lt;title&gt;Applet1&lt;/title&gt;&lt;/head&gt;&lt;hr&gt;
&lt;OBJECT 
  classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93"
  width="100" height="50" align="baseline"  
  codebase="http://java.sun.com/products/plugin/1.2.2/jinstall-1_2_2-win.cab#Version=1,2,2,0"&gt;
&lt;PARAM NAME="code" VALUE="Applet1.class"&gt;
&lt;PARAM NAME="codebase" VALUE="."&gt;
&lt;PARAM NAME="type" VALUE="application/x-java-applet;version=1.2.2"&gt;
&lt;COMMENT&gt;
  &lt;EMBED type=
    "application/x-java-applet;version=1.2.2" 
    width="200" height="200" align="baseline"
    code="Applet1.class" codebase="."
pluginspage="http://java.sun.com/products/plugin/1.2/plugin-install.html"&gt;
  &lt;NOEMBED&gt;
&lt;/COMMENT&gt;
   No Java 2 support for APPLET!!
  &lt;/NOEMBED&gt;
&lt;/EMBED&gt;
&lt;/OBJECT&gt;
&lt;hr&gt;&lt;/body&gt;&lt;/html&gt;
///:~</font></pre>
</blockquote>
<p><font face="Georgia">Некоторые из этих строк слишком длинные и разбиты на несколько 
  для того, чтобы поместится на странице. Код в этой книге (на CD ROM, прилагаемом 
  к книге, и доступный на <i>www.BruceEckel.com</i>) будет работать, и вам не 
  нужно беспокоится об исправлении перенесенных строк.</font></p>
<p><font face="Georgia">Значение <b>code</b> задает имя <b>.class</b> файла, в 
  котором расположен апплет. <b>width</b> и <b>height</b> указывают начальный 
  размер апплета (в пикселях, как и раньше). Есть другие элементы, которые вы 
  можете поместить в ярлык апплета: место, где искать другие файлы <b>.class</b> 
  в Internet (<a name="Index1573"></a><a name="Index1574"></a><b>codebase</b>), 
  информация о выравнивании (<a name="Index1575"></a><a name="Index1576"></a><b>align</b>), 
  специальные идентификаторы, которые делают возможным общение апплета со всем 
  остальным (<a name="Index1577"></a><a name="Index1578"></a><b>name</b>), а также 
  <a name="Index1579"></a><a name="Index1580"></a>параметры апплета, обеспечивающие 
  информацию, которую апплет может найти. Параметры задаются следующей формой</font><font face="Georgia">:</font></p>
<blockquote>
  <pre><font size="+1">&lt;param name=<font color="#004488">"identifier"</font> value = <font color="#004488">"information"</font>&gt;</font></pre>
</blockquote>
<p><font face="Georgia">и их может быть столько, сколько вам нужно.</font></p>
<p><font face="Georgia">Пакет исходного кода для этой книги содержит HTML страницы 
  для каждого апплета в этой книге и, таким образом, много примеров для ярлыка 
  апплета. Вы можете найти полное и конкретное описание о деталях помещения апплетов 
  на Web страницы на </font><font face="Georgia"> <i>java.sun.com</i>.</font><a name="_Toc481064787"></a></p>
<div align="left"></div>
<a name="Heading420"></a>
<h3 align="left"><font face="Verdana"> Использование Appletviewer</font></h3>
<p><font face="Georgia"> JDK от SUN (бесплатно доступен на <i>java.sun.com</i>) 
  имеет инструмент, называемый <a name="Index1581"></a><i>Appletviewer</i>, который 
  выбирает ярлык <b>&lt;applet&gt;</b> из HTML файла и запускает апплет без отображения 
  окружающего HTML текста. Из-за того, что Appletviewer игнорирует все, кроме 
  ярлыка APPLET, вы можете поместить эти ярлыки в исходный код Java как комментарий:</font></p>
<blockquote>
  <pre><font color="#009900" size="+1">// &lt;applet code=MyApplet width=200 height=100&gt;</font>
<font color="#009900" size="+1">// &lt;/applet&gt;</font></pre>
</blockquote>
<p><font face="Georgia">Этим способом вы можете запустить “<b>appletviewer 
  MyApplet.java</b>” и вам не нужно будет создавать маленький HTML файл 
  для запуска теста. Например, вы можете добавить закомментированный HTML ярлык 
  в <b>Applet1.java</b>:</font></p>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c13:Applet1b.java</font>
<font color="#009900" size="+1">// Встроенный ярлык апплета для Appletviewer.</font>
<font color="#009900" size="+1">// &lt;applet code=Applet1b width=100 height=50&gt;</font>
<font color="#009900" size="+1">// &lt;/applet&gt;</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> Applet1b <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> init() {
    getContentPane().add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Applet!"</font>));
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Теперь вы можете вызвать апплет командой</font></p>
<blockquote>
  <pre><font size="+1">appletviewer Applet1b.java</font></pre>
</blockquote>
<p><font face="Georgia">В этой книге эта форма будет использоваться для простого 
  тестирования апплетов. Вскоре вы увидите другой способ кодирования, который 
  позволит вам выполнять апплеты из командной строки без </font><font face="Georgia"> 
  Appletviewer.</font><a name="_Toc481064788"></a></p>
<a name="Heading421"></a> 
<h3 align="left"><font face="Verdana"> Тестирование апплетов</font></h3>
<p><font face="Georgia">Вы можете выполнить простой тест без каких-либо сетевых 
  соединений при запуске Web броузера и открытии HTML файлов, содержащих ярлык 
  апплета. Как только HTML файл будет загружен, броузер обнаружит ярлык апплета 
  и пойдет охотиться за <b>.class</b> файлом, указанным в значении <b>code</b>. 
  Конечно, он просматривает CLASSPATH для того, чтобы определить где охотится, 
  и если ваш <b>.class</b> файл не найден по CLASSPATH, то он выведет сообщение 
  об ошибке в строке состояния броузера о том, что он не смог найти этот <b>.class</b> 
  файл.</font></p>
<p><font face="Georgia">Когда вы захотите проверить это на своем Web сайте, эти 
  вещи становятся немного более сложными. Прежде всего, вы должны <i>иметь</i> 
  Web сайт, который для большинства людей означает провайдеров третьей стороны 
  (<a name="Index1582"></a><a name="Index1583"></a>Internet Service Provider - 
  ISP) в удаленном месте. Так как апплеты - это просто файлы или набор файлов, 
  ISP не должен обеспечивать какую-то особую поддержку для Java. Вы также должны 
  иметь способ переместить HTML файлы и <b>.class</b> файлы вашего сайта в правильную 
  директорию машины провайдера. Обычно это выполняется с помощью программы, использующей 
  <a name="Index1584"></a><a name="Index1585"></a>протокол передачи файлов (FTP), 
  которых имеется великое множество как бесплатных, таки условно-бесплатных. Так 
  что на первый взгляд, все, что вам нужно сделать - это переметить файлы на машину 
  провайдера с помощью FTP, затем соединиться с сайтом и HTML файлом, используя 
  свой броузер; если апплет получен и работает, то все проверено. Верно?</font></p>
<p><font face="Georgia">Здесь вы можете быть одурачены. Если броузер на клиентской 
  машине не может найти <b>.class</b> на сервере, он охотится за ним, просматривая 
  <a name="Index1586"></a><a name="Index1587"></a>CLASSPATH на вашей <i>локальной</i> 
  машине. Таким образом, апплет может не загрузиться правильно с сервера, но для 
  вас это будет выглядеть нормально в процессе тестирования, потому что броузер 
  найдет апплет на вашей машине. Однако кода кто-то другой соединится, его или 
  ее броузер не сможет найти его. Так что при тестировании убедитесь, что вы стерли 
  соответствующий <b>.class</b> файл (или <b>.jar</b> файл) на своей локальной 
  машине, чтобы проверить, что он правильно расположен на сервере.</font></p>
<p><font face="Georgia">Одно из коварных мест, в которое угодил я, когда поместил 
  апплет внутри <b>package</b>. После загрузки HTML файла и апплета оказалось, 
  что путь на сервере к апплету был перепутан с именем пакета. Однако мой броузер 
  нашел его по локальному CLASSPATH. Таким образом, я был единственным, кто мог 
  правильно загрузить апплет. Одновременно это позволило обнаружить, что инструкция 
  <b>package</b> была всему виной. В общем, вы не должны включать инструкцию <a name="Index1588"></a><a name="Index1589"></a><b>package</b> 
  в апплет.</font><a name="_Toc481064789"></a></p>
<div align="left"></div>
<p><a name="Heading422"></a></p>
<h2 align="left"><font face="Verdana">Запуск апплетов из командной строки<a name="Index1590"></a><a name="Index1591"></a></font></h2>
<p><font face="Georgia">Будет время, когда вы захотите сделать программу, которая 
  выполняла что-то иное, чем просто сидела на Web странице. Возможно, вам также 
  нравится делать какие-то вещи, которое может делать “обычное” приложение, 
  но все-таки иметь хваленую моментальную мобильность, обеспечиваемую Java. В 
  предыдущих главах этой книги мы делали приложения для командной строки, но в 
  некоторых средах (например, для Макинтош) не существует командной строки. Так 
  что по многим причинам вы захотите построить оконную программу, не являющуюся 
  апплетом, используя Java. Это весьма резонное желание.</font></p>
<p><font face="Georgia">Библиотека Swing позволяет вам создавать приложения, сохраняющие 
  внешний облик для среды операционной системы. Если вы хотите построить оконное 
  приложение, имеет смысл делать так, <a href="#fn65">[65]</a> если вы может 
  использовать самую последнюю версию Java и соответствующие элементы, чтобы вы 
  могли выпустить приложение, которое не будет смущать ваших пользователей. Если 
  по каким-то причинам вы вынуждены использовать старую версию Java, хорошо подумайте, 
  прежде чем перейдете к построению значительного оконного приложения.</font></p>
<p><a name="Index1592"></a><a name="Index1593"></a><font face="Georgia">Часто 
  у вас будет желание создать класс, который может быть вызван либо как окно, 
  либо как апплет. Это особенно удобно, когда вы проверяете апплет, так как обычно 
  намного проще и легче запустить результирующее приложение-апплет из командной 
  строки, чем запускать его в Web броузере или с помощью Appletviewer.</font></p>
<p><font face="Georgia">Для создания апплета, который может быть запущен из командной 
  строки консоли, вы просто добавляете <b>main(&nbsp;)</b> в ваш апплет, который 
  создает экземпляр апплета внутри <b>JFrame</b>.</font><a href="#fn66">[66]</a> 
  В качестве простого примера давайте взглянем на измененный <font face="Georgia"><b>Applet1b.java</b>, 
  который теперь может работать и как приложение, и как апплет:</font></p>
<div align="left"></div>
<blockquote> 
  <pre><font color="#009900" size="+1">//: c13:Applet1c.java</font>
<font color="#009900" size="+1">// Приложение и апплет.</font>
<font color="#009900" size="+1">// &lt;applet code=Applet1c width=100 height=50&gt;</font>
<font color="#009900" size="+1">// &lt;/applet&gt;</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> Applet1c <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> init() {
    getContentPane().add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Applet!"</font>));
  }
  <font color="#009900">// main() для приложения:</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) {
    JApplet applet = <font color="#0000ff">new</font> Applet1c();
    JFrame frame = <font color="#0000ff">new</font> JFrame(<font color="#004488">"Applet1c"</font>);
    <font color="#009900">// Для закрытия приложения:</font>
    Console.setupClosing(frame);
    frame.getContentPane().add(applet);
    frame.setSize(100,50);
    applet.init();
    applet.start();
    frame.setVisible(<font color="#0000ff">true</font>);
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia"><b>main(&nbsp;)</b> - это просто элемент, добавляющийся 
  к апплету, а оставшаяся часть апплета остается нетронутой. Апплет создается 
  и добавляется в <b>JFrame</b> так, что он может быть отображен.</font></p>
<p><font face="Georgia">Строка:</font></p>
<blockquote>
  <pre><font size="+1">Console.setupClosing(frame);</font></pre>
</blockquote>
<p><font face="Georgia">Является причиной правильного закрытия окна. <b>Console</b> 
  пришло из <b>com.bruceeckel.swing</b> и будет объясняться позднее.</font></p>
<p><font face="Georgia">Вы можете видеть, что в <b>main(&nbsp;)</b> апплет явно 
  инициализируется и стартует, так как в этом случае броузер не выполняет это 
  за вас. Конечно так вы не получите все возможности броузера, который также вызывает 
  <b>stop(&nbsp;)</b> и <b>destroy(&nbsp;)</b>, но для большинства ситуаций это 
  приемлемо. Если это проблема, вы можете выполнить вызовы сами.<a href="#fn67">[67]</a></font></p>
<p><font face="Georgia">Обратите внимание на последнюю строку:</font></p>
<blockquote>
  <pre><font size="+1">frame.setVisible(<font color="#0000ff">true</font>);</font></pre>
</blockquote>
<p><font face="Georgia">Без этого вы не увидите ничего на экране.</font><a name="_Toc481064790"></a></p>
<a name="Heading423"></a>
<h3 align="left"><font face="Verdana"> Отображение рабочего пространства<a name="Index1594"></a><a name="Index1595"></a></font></h3>
<p><font face="Georgia">Хотя тот код, который, который делает программу запускаемой 
  и как апплет, и как приложение, предоставляет ценные результаты, если его использовать 
  везде, он сбивает с толку и впустую тратит бумагу. Вместо этого приведенное 
  ниже отображение рабочего пространства будет использоваться для примеров Swing 
  в оставшейся части книги</font><font face="Georgia">:</font></p>
<blockquote>
  <pre><font color="#009900" size="+1">//: com:bruceeckel:swing:Console.java</font>
<font color="#009900" size="+1">// Инструмент для запуска демонстрации Swing</font>
<font color="#009900" size="+1">// из консоли и доя апплета, и для JFrames.</font>
<font color="#0000ff" size="+1">package</font><font size="+1"> com.bruceeckel.swing;
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> Console {
  <font color="#009900">// Создание строки заголовка из имени класса:</font></font>
  <font color="#0000ff" size="+1">public</font> <font color="#0000ff" size="+1">static</font><font size="+1"> String title(Object o) {
    String t = o.getClass().toString();
    <font color="#009900">// Удаление слова "class":</font></font>
    <font color="#0000ff" size="+1">if</font><font size="+1">(t.indexOf(<font color="#004488">"class"</font>) != -1)
      t = t.substring(6);
    <font color="#0000ff">return</font> t;
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> setupClosing(JFrame frame) {
    <font color="#009900">// Решение JDK 1.2 - это</font></font>
    <font color="#009900" size="+1">// анонимный внутренний класс:</font><font size="+1">
    frame.addWindowListener(<font color="#0000ff">new</font> WindowAdapter() {
      <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> windowClosing(WindowEvent e) {
        System.exit(0);
      }
    });
    <font color="#009900">// улучшенное решение в JDK 1.3:</font></font>
    <font color="#009900" size="+1">// frame.setDefaultCloseOperation(</font>
    <font color="#009900" size="+1">//     EXIT_ON_CLOSE);</font><font size="+1">
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> 
  run(JFrame frame, <font color="#0000ff">int</font> width, <font color="#0000ff">int</font> height) {
    setupClosing(frame);
    frame.setSize(width, height);
    frame.setVisible(<font color="#0000ff">true</font>);
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> 
  run(JApplet applet, <font color="#0000ff">int</font> width, <font color="#0000ff">int</font> height) {
    JFrame frame = <font color="#0000ff">new</font> JFrame(title(applet));
    setupClosing(frame);
    frame.getContentPane().add(applet);
    frame.setSize(width, height);
    applet.init();
    applet.start();
    frame.setVisible(<font color="#0000ff">true</font>);
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> 
  run(JPanel panel, <font color="#0000ff">int</font> width, <font color="#0000ff">int</font> height) {
    JFrame frame = <font color="#0000ff">new</font> JFrame(title(panel));
    setupClosing(frame);
    frame.getContentPane().add(panel);
    frame.setSize(width, height);
    frame.setVisible(<font color="#0000ff">true</font>);
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Этот инструмент вы можете использовать сами, так как он 
  помещен в библиотеке <a name="Index1596"></a><b>com.bruceeckel.swing</b>. Класс 
  <b>Console</b> полностью состоит из статических методов. Первый используется 
  для получения имени класса (используя RTTI) из любого объекта и удаления слова 
  “class”, которое обычно присоединяется спереди методом <b>getClass(&nbsp;)</b>. 
  Здесь используется метод <b>indexOf(&nbsp;)</b> из <b>String</b> для определения 
  присутствия слова “class” и <b>substring(&nbsp;)</b> для получения 
  новой строки без приставки “class” или заключающих пробелов. Это 
  имя используется для метки окна, которая отображается в методах <b>run(&nbsp;)</b>.</font></p>
<p><font face="Georgia"><b>setupClosing(&nbsp;)</b> используется для упрятывания 
  кода, являющегося причиной выхода из программы при закрытии <b>JFrame</b>. По 
  умолчанию при этом ничего не делается, так что если вы не вызовите <b>setupClosing(&nbsp;)</b> 
  или не напишите аналогичный код для своего <a name="Index1597"></a><b>JFrame</b>, 
  приложение не закроется. Причина упрятывания этого кода, а не помещения его 
  прямо в последовательность метода <b>run(&nbsp;)</b>, частично в том, что это 
  позволяет вам использовать этот метод сам по себе, когда вы захотите сделать 
  что-то более сложное по сравнению с тем, что обеспечивает <b>run(&nbsp;)</b>. 
  Однако это изолирует фактор изменения: Java 2 имеет два пути для закрытия некоторых 
  видов окон. В JDK 1.2 решение состоит в создании нового класса <a name="Index1598"></a><b>WindowAdapter</b> 
  и реализации <a name="Index1599"></a><b>windowClosing(&nbsp;)</b>, как показано 
  выше (значение этого будет полностью объяснено позже в этой главе). Однако во 
  время создания JDK 1.3 разработчики библиотеки заметили, что вам обычно нужно 
  закрывать окна в любом случае, если вы создаете не апплет, и поэтому они добавили 
  <a name="Index1600"></a><b>setDefaultCloseOperation(&nbsp;)</b> в <b>JFrame</b> 
  и <b>JDialog</b>. С точки зрения написания кода, новый метод более приятный 
  в использовании, но эта книга была написана в то время, когда еще не было реализации 
  JDK 1.3. для Linux и других платформ, поэтому в интересах совместимости версий 
  изменения были изолированы в методе <b>setupClosing(&nbsp;)</b>.</font></p>
<p><font face="Georgia">Методы <b>run(&nbsp;)</b> перегружены для работы с <b>JApplet</b>, 
  <b>JPanel</b> и <b>JFrame</b>. Обратите внимание, что только для <b>JApplet</b> 
  вызывается <b>init(&nbsp;)</b> и <b>start(&nbsp;)</b>. </font></p>
<p><font face="Georgia">Теперь любой апплет может быть запущен из консоли путем 
  создания <b>main(&nbsp;)</b>, содержащей строку, подобную этой:</font></p>
<blockquote>
  <pre><font size="+1">Console.run(<font color="#0000ff">new</font> MyClass(), 500, 300);</font></pre>
</blockquote>
<p><font face="Georgia">в которой последние два аргумента показывают ширину и 
  высоту. Здесь приведена <b>Applet1c.java</b> измененная для использования <b>Console</b>:</font></p>
<blockquote>
  <pre><font color="#009900" size="+1">//: c13:Applet1d.java</font>
<font color="#009900" size="+1">// Console запускает апплет из командной строки.</font>
<font color="#009900" size="+1">// &lt;applet code=Applet1d width=100 height=50&gt;</font>
<font color="#009900" size="+1">// &lt;/applet&gt;</font>
<font color="#0000ff" size="+1">import</font><font size="+1"> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">class</font><font size="+1"> Applet1d <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">void</font><font size="+1"> init() {
    getContentPane().add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Applet!"</font>));
  }
  <font color="#0000ff">public</font></font> <font color="#0000ff" size="+1">static</font> <font color="#0000ff" size="+1">void</font><font size="+1"> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Applet1d(), 100, 50);
  }
} <font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Это позволяет уменьшить количество повторяющегося кода, 
  одновременно обеспечивая великолепную гибкость в запуске примеров.</font><a name="_Toc481064791"></a></p>

<h3 align="left"><font face="Verdana"><a name="Heading424"></a>Использование Windows 
  Explorer</font></h3>
<p><font face="Georgia">Если вы используете Windows, вы можете упростить процесс 
  запуска Java программ из командной строки путем конфигурирования <a name="Index1601"></a><a name="Index1602"></a>Windows 
  Explorer — файл-менеджера в Windows, не Internet Explorer — так 
  что теперь вы можете просто дважды щелкнуть мышкой на файле <b>.class</b> для 
  его выполнения. Для этого нужно выполнить несколько шагов.</font></p>
<p><font face="Georgia">Первое, загрузить и установить язык программирования <a name="Index1603"></a>Perl 
  с <i>ww.Perl.org</i>. Вы найдете инструкцию и документацию языка на этом сайте.</font></p>
<p><font face="Georgia">Далее, создать следующий сценарий без первой и последней 
  строки (этот сценарий является частью пакета исходного кода книги):</font></p>
<blockquote>
  <pre><font color="#009900" size="+1">//:! c13:RunJava.bat</font><font size="+1">
@rem = '--*-Perl-*--
@echo off
perl -x -S <font color="#004488">"%0"</font> %1 %2 %3 %4 %5 %6 %7 %8 %9
<font color="#0000ff">goto</font> endofperl
@rem ';
#!perl
$file = $ARGV[0];
$file =~ s/(.*)\..*/\1/;
$file =~ s/(.*\\)*(.*)/$+/;
&#180;java $file&#180;;
__END__
:endofperl
<font color="#009900">///:~</font></font></pre>
</blockquote>
<p><font face="Georgia">Теперь откройте Windows Explorer, выберете “Вид 
  (View)”, “Параметры (Folder Options)”, затем щелкните на закладке 
  “Типы файлов (File Types)”. Нажмите кнопку “Новый тип (New 
  Type)”. В качестве “Описания (Description of Type)” введите 
  “Java class file”. В качестве “Стандартного расширения (Associated 
  Extension)” введите “class”. Под пунктом “Действия (Actions)” 
  нажмите кнопку “Создать (New)”. В пункте “Действие (Action)” 
  введите “Open”, а в поле “Приложение, запускающее действие 
  (Application used to perform action)” введите строку, как показано здесь:</font></p>
<blockquote>
  <pre><font color="#004488" size="+1">"c:\aaa\Perl\RunJava.bat"</font> <font color="#004488" size="+1">"%L"</font></pre>
</blockquote>
<p><font face="Georgia">Вы должны настроить путь перед “RunJava.bat”, 
  чтобы он соответствовал месту, в которое вы поместили пакетный файл.</font></p>
<p><font face="Georgia">Как только вы выполните эту установку, вы можете запускать 
  любую программу Java, просто выполнив двойной щелчок на <b>.class</b> файле, 
  содержащем </font><font face="Georgia"> <b>main(&nbsp;)</b>.</font><a name="_Toc375545447"></a><a name="_Toc481064792"></a></p>
<a name="Heading425"></a> <font face="Verdana">
</font><h2 align="left"><font face="Verdana">Создание кнопок<a name="Index1604"></a><a name="Index1605"></a></font></h2>
 
<p><font face="Georgia">Создание кнопок достаточно просто: вы просто вызываете 
  конструктор <b>JButton</b> с меткой, которую хотите поместить на кнопке. Позже 
  вы увидите, что вы можете делать фантастические вещи, такие как помещение графической 
  картинки на кнопку.</font></p>
<p><font face="Georgia">Обычно вам будет нужно создавать поле для кнопки внутри 
  вашего класса, чтобы вы могли обратиться к ней позже.</font></p>
<p><font face="Georgia"> <b>JButton</b> - это компонент — своего рода маленькое 
  окно — который автоматически перерисовывается как часть обновления. Это 
  означает, что вам не нужно явно вызывать перерисовку кнопки или для любого управляющего 
  элемента; вы просто помещаете его на форму, и позволяете ему автоматически заботиться 
  о своей перерисовке. Чтобы поместить кнопку на форму, вы должны выполнить это 
  внутри <b>init(&nbsp;)</b>:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:Button1.java</font>
<font color="#009900">// Помещение кнопки в апплете.</font>
<font color="#009900">// &lt;applet code=Button1 width=200 height=50&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Button1 <font color="#0000ff">extends</font> JApplet {
  JButton 
    b1 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Button 1"</font>), 
    b2 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Button 2"</font>);
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(b1);
    cp.add(b2);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Button1(), 200, 50);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Здесь было добавлено кое-что новое: перед помещением любого 
  элемента в содержащую панель, создается новый “менеджер компоновки” 
  типа <b>FlowLayout</b>. Менеджер компоновки - это способ, которым панель решает, 
  где поместить управляющий элемент на форме. Нормальным для апплета считается 
  использование <b>BorderLayout</b>, но это не работает здесь потому (как вы выучите 
  позднее в этой главе, где управляете компоновкой формы исследовано более подробно), 
  что по умолчанию он перекрывает каждый новый управляющий элемент при добавлении. 
  Однако <b>FlowLayout</b> является причиной того, что управляющие элементы равномерно 
  плавают в форме, слева направо и сверху вниз.</font><a name="_Toc375545448"></a><a name="_Toc481064793"></a></p>
<a name="Heading426"></a><font face="Verdana">
<h2 align="left"> Захват событий<a name="Index1606"></a></h2>
</font> 
<p><font face="Georgia">Вы заметите, что если вы откомпилируете программу и запустите 
  приведенный выше апплет, ничего не произойдет при нажатии кнопки. Это потому, 
  что вы должны пойти и написать определенный код для определения того, что случилось. 
  Основа для <a name="Index1607"></a><a name="Index1608"></a>событийного программирования, 
  которое включает многое из того, что включает GUI, это привязка кода, который 
  отвечает на эти события.</font></p>
<p><font face="Georgia">Способ, которым <font color="#0000ff">это</font> совершается 
  в Swing, это ясно отделенный <font color="#0000ff">интерфейс</font> (графические 
  компоненты) и реализация (код, который вы хотите запустить при возникновении 
  события от компоненты). Каждый компонент Swing может посылать все сообщения, 
  которые могут в нем случатся, и он может посылать события каждого вида индивидуально. 
  Так что <font color="#0000ff">если</font> вам, <font color="#0000ff">например</font>, 
  не интересно было ли перемещение мыши над кнопкой, вы не регистрируете это событие. 
  Это очень простой и элегантный способ обработки в событийном программировании, 
  и как только вы поймете основы концепции, вы сможете легко использовать компоненты 
  Swing, которые вы до этого не видели — фактически, эта модель простирается 
  на все, что может быть классифицировано как JavaBean (который вы выучите позднее 
  в этой главе).</font></p>
<p><font face="Georgia">Сначала мы сфокусируем внимание на основном, интересующем 
  нас событии используемого компонента. В случае <b>JButton</b>, этим “интересующем 
  событием” является нажатие кнопки. Для регистрации своей заинтересованности 
  в нажатии кнопки вы вызываете метод <b>addActionListener(&nbsp;)</b> класса 
  <b>JButton</b>. Этот метод ожидает аргумент, являющийся объектом, реализующим 
  интерфейс <b>ActionListener</b>, который содержит единственный метод, называемый 
  <b>actionPerformed(&nbsp;)</b>. Таким образом, все, что вам нужно сделать для 
  присоединения кода к <b>JButton</b>, это реализовать интерфейс <b>ActionListener</b> 
  в классе и зарегистрировать объект этого класса в <b>JButton</b> через <b>addActionListener(&nbsp;)</b>. 
  Метод будет вызван при нажатии кнопки (это обычно называется <a name="Index1609"></a><i>обратным 
  вызовом</i>).</font></p>
<p><font face="Georgia">Но что должно быть результатом нажатия кнопки? Нам хотелось 
  бы увидеть какие-то изменения на экране, так что введем новый компонент Swing: 
  <a name="Index1610"></a><b>JTextField</b>. Это то место, где может быть напечатан 
  текст или, в нашем случае, текст может быть изменен программой. Хотя есть несколько 
  способов создания <b>JTextField</b>, самым простым является сообщение конструктору 
  нужной вам ширину текстового поля. Как только <b>JTextField</b> помещается на 
  форму, вы можете изменять содержимое, используя метод <b>setText(&nbsp;)</b> 
  (есть много других методов в <b>JTextField</b>, но вы должны посмотреть их в 
  HTML документации для JDK на <i>java.sun.com</i>). Вот как это выглядит:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Button2.java</font>
<font color="#009900">// Ответ на нажатие кнопки.</font>
<font color="#009900">// &lt;applet code=Button2 width=200 height=75&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Button2 <font color="#0000ff">extends</font> JApplet {
  JButton 
    b1 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Button 1"</font>), 
    b2 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Button 2"</font>);
  JTextField txt = <font color="#0000ff">new</font> JTextField(10);
  <font color="#0000ff">class</font> BL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
      String name = 
        ((JButton)e.getSource()).getText();
      txt.setText(name);
    }
  }
  BL al = <font color="#0000ff">new</font> BL();
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    b1.addActionListener(al);
    b2.addActionListener(al);
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(b1);
    cp.add(b2);
    cp.add(txt);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Button2(), 200, 75);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Создание <b>JTextField</b> и помещение его на канву - 
  это шаги, необходимые для и для <b>JButton </b>или любого компонента Swing. 
  Отличия приведенной выше программы в создании вышеупомянутого класса <b>BL</b>, 
  являющегося <b>ActionListener</b>. Аргумент для <b>actionPerformed(&nbsp;)</b> 
  имеет тип <b>ActionEvent</b>, который содержит всю информацию о событии и откуда 
  оно исходит. В этом случае я хочу описать кнопку, которая была нажата: <b>getSource(&nbsp;)</b> 
  производит объект, явившийся источником события, и я полагаю, что это <b>JButton</b>. 
  <b>getText(&nbsp;)</b> возвращает текст, который есть на кнопке, а он помещается 
  в <b>JTextField</b> для демонстрации, что код действительно был вызван при нажатии 
  кнопки.</font></p>
<p><font face="Georgia">В <b>init(&nbsp;)</b> используется <b>addActionListener(&nbsp;)</b> 
  для регистрации объекта <b>BL</b> в обеих кнопках.</font></p>
<p><font face="Georgia">Часто более последовательно кодировать <b>ActionListener</b> 
  как <a name="Index1611"></a><a name="Index1612"></a><a name="Index1613"></a>анонимный 
  внутренний класс, особенно потому, что вы склонны использовать единственный 
  интерфейс для каждого следящего класса. <b>Button2.java</b> может быть изменена 
  для использования анонимного внутреннего класса следующим образом:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Button2b.java</font>
<font color="#009900">// Использование анонимного внутреннего класса.</font>
<font color="#009900">// &lt;applet code=Button2b width=200 height=75&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Button2b <font color="#0000ff">extends</font> JApplet {
  JButton 
    b1 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Button 1"</font>), 
    b2 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Button 2"</font>);
  JTextField txt = <font color="#0000ff">new</font> JTextField(10);
  ActionListener al = <font color="#0000ff">new</font> ActionListener() {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
      String name = 
        ((JButton)e.getSource()).getText();
      txt.setText(name);
    }
  };
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    b1.addActionListener(al);
    b2.addActionListener(al);
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(b1);
    cp.add(b2);
    cp.add(txt);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Button2b(), 200, 75);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Подход с использованием анонимного внутреннего класса 
  будет наиболее предпочтительным (когда это возможно) для примеров из этой книги</font><font face="Georgia">.</font><a name="_Toc375545450"></a><a name="_Toc481064794"></a></p>
<a name="Heading427"></a><font face="Verdana">
<h2 align="left"> Текстовые области</h2>
</font>
<div align="left"> 
  <p><font face="Georgia"> <a name="Index1614"></a><b>JTextArea</b> - это как 
    <b>JTextField</b>, за исключением того, что он может иметь множество строк 
    и имеет большую функциональность. Особенно полезным методом является <b>append(&nbsp;)</b>; 
    с ним вы можете легко сливать вывод в <b>JTextArea</b>, что делает программу, 
    использующую Swing, удобнее (так как вы можете проскроллировать назад) по 
    сравнению с тем, что использовалось в программах командой строки, печатающих 
    в стандартный вывод. В качестве примера приведена программа заполнения <b>JTextArea</b> 
    значениями, получающимися из генератора <b>geography</b> из <a href=" Chapter09.html">Главы 
    9</a>:</font></p>
  </div>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:TextArea.java</font>
<font color="#009900">// Использование управляющего элемента JTextArea.</font>
<font color="#009900">// &lt;applet code=TextArea width=475 height=425&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.util.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;
<font color="#0000ff">import</font> com.bruceeckel.util.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> TextArea <font color="#0000ff">extends</font> JApplet {
  JButton 
    b = <font color="#0000ff">new</font> JButton(<font color="#004488">"Add Data"</font>),
    c = <font color="#0000ff">new</font> JButton(<font color="#004488">"Clear Data"</font>);
  JTextArea t = <font color="#0000ff">new</font> JTextArea(20, 40);
  Map m = <font color="#0000ff">new</font> HashMap();
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    <font color="#009900">// Использование всех данных:</font>
    Collections2.fill(m, 
      Collections2.geography, 
      CountryCapitals.pairs.length);
    b.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        <font color="#0000ff">for</font>(Iterator it= m.entrySet().iterator();
            it.hasNext();){
          Map.Entry me = (Map.Entry)(it.next());
          t.append(me.getKey() + <font color="#004488">": "</font> 
            + me.getValue() + <font color="#004488">"\n"</font>);
        }
      }
    });
    c.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        t.setText(<font color="#004488">""</font>);
      }
    });
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(<font color="#0000ff">new</font> JScrollPane(t));
    cp.add(b);
    cp.add(c);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> TextArea(), 475, 425);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">В <b>init(&nbsp;)</b> <b>Map</b> заполняется всеми странами 
  и их столицами. Обратите внимание, что для обеих кнопок создается <a name="Index1615"></a><b>ActionListener</b> 
  и добавляется без определения промежуточной переменной, так как вам не нужно 
  будет снова обращаться к следящему классу в программе. Кнопка Add Data” 
  форматирует и добавляет все данные, а кнопка “Clear Data” использует 
  <b>setText(&nbsp;)</b> для удаления всего текста из <b>JTextArea</b>.</font></p>
<p><font face="Georgia">Когда <b>JTextArea</b> добавляется в апплет, он оборачивается 
  в <a name="Index1616"></a><a name="Index1617"></a><b>JScrollPane</b>, для управления 
  скроллингом, когда слишком много текста помещается на экран. Это все, что вы 
  должны сделать для поддержки возможности скроллинга. Пробуя выяснить, как делать 
  аналогичные вещи в других средах программирования GUI, я был поражен простотой 
  и хорошим дизайном компонент, подобных </font><font face="Georgia"><b>JScrollPane</b>.</font><a name="_Toc481064795"></a></p>
<a name="Heading428"></a> <font face="Verdana">
<h2 align="left">Управление компоновкой<a name="Index1618"></a></h2>
</font> 
<p><font face="Georgia">Способ, которым вы помещаете компоненты на форму в Java, 
  вероятно, отличается от всех других используемых вами GUI систем. Во-первых, 
  это все код; здесь нет “ресурсов”, которые управляют помещением 
  компонентов. Во-вторых, способ, которым компоненты помещаются на форму, управляется 
  не абсолютным позиционированием, а с помощью “менеджера компоновки”, 
  который решает, как располагать компонент, основываясь на порядке, в котором 
  вы добавляете (<b>add(&nbsp;)</b>) их. Размер, образ и расположение компонентов 
  будет значительно отличаться при использовании разных компоновщиков. Кроме того, 
  менеджер компоновки адаптирует размеры вашего апплета или окна приложения, так 
  что если размеры окна меняются, размер, образ и расположение компонентов может 
  соответственно измениться.</font></p>
<p><a name="Index1620"></a><font face="Georgia"><b>JApplet</b>, <b>JFrame</b>,<b> 
  JWindow</b> и <b>JDialog</b> все могут производить <b>Container</b> с помощью 
  <b>getContentPane(&nbsp;)</b>, который может содержать и отображать <b>Component</b>. 
  В <b>Container</b> есть метод, называемый <a name="Index1621"></a><b>setLayout(&nbsp;)</b>, 
  который позволяет вам выбрать между различными менеджерами компоновки. Другие 
  классы, такие как <a name="Index1622"></a><b>JPanel</b>, содержат и отображают 
  компоненты непосредственно, и вы так же можете установить менеджер компоновки 
  непосредственно, без использования панели содержания.</font></p>
<p><font face="Georgia">В этом разделе мы исследуем различные менеджеры компоновки, 
  помещая кнопки (так как это самое простое, что можно сделать). Здесь не будет 
  никакого захвата событий, так как эти примеры предназначены только для показа, 
  как расположатся кнопки.</font><a name="_Toc375545458"></a><a name="_Toc375545459"></a><a name="_Toc481064796"></a></p>
<div align="left"></div>
<a name="Heading429"></a><font face="Verdana"> 
<h3 align="left"> BorderLayout</h3>
</font> 
<p><font face="Georgia">Апплет по умолчанию использует схему компоновки по умолчанию: 
  <a name="Index1623"></a><b>BorderLayout</b> (несколько предыдущих примеров меняли 
  менеджер компоновки на <b>FlowLayout</b>). Без каких-то дополнительных инструкций 
  он принимает все, что вы добавляете (<b>add(&nbsp;)</b>) и помещает это в центр, 
  растягивая объект во все стороны до края.</font></p>
<p><font face="Georgia">Однако <b>BorderLayout</b> может больше. Этот менеджер 
  компоновки имеет концепцию четырех граничных областей и центральной области. 
  Когда вы добавляете что-то в панель, которая использует <b>BorderLayout</b>, 
  вы можете использовать перегруженный метод <b>add(&nbsp;)</b>, принимающий константу 
  в качестве своего первого аргумента. Это значение может быть любым из следующих</font><font face="Georgia">:<b><a name="Index1624"></a><a name="Index1625"></a><a name="Index1626"></a><a name="Index1627"></a></b></font></p>
<div align="left"></div>
<div align="left">
  <p><font face="Georgia"><b>BorderLayout.NORTH </b>(верх)</font><br>
    <font face="Georgia"><b>BorderLayout.SOUTH</b> (низ)</font><br>
    <font face="Georgia"><b>BorderLayout.EAST</b> (справа)</font><br>
    <font face="Georgia"><b>BorderLayout.WEST</b> (слева)</font><br>
    <font face="Georgia"><b>BorderLayout.CENTER</b> (заполнить середину до других 
    компонент или до краев)</font></p>
</div>
<p><font face="Georgia">Если вы не указываете область для помещения объекта, по 
  умолчанию выбирается <b>CENTER</b>.</font></p>
<p><font face="Georgia">Вот пример. Используется компоновка по умолчанию, так 
  как для <b>JApplet</b> по умолчанию используется <b>BorderLayout</b>:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:BorderLayout1.java</font>
<font color="#009900">// Демонстрация BorderLayout.</font>
<font color="#009900">// &lt;applet code=BorderLayout1 </font>
<font color="#009900">// width=300 height=250&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> BorderLayout1 <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.add(BorderLayout.NORTH, 
      <font color="#0000ff">new</font> JButton(<font color="#004488">"North"</font>));
    cp.add(BorderLayout.SOUTH, 
      <font color="#0000ff">new</font> JButton(<font color="#004488">"South"</font>));
    cp.add(BorderLayout.EAST, 
      <font color="#0000ff">new</font> JButton(<font color="#004488">"East"</font>));
    cp.add(BorderLayout.WEST, 
      <font color="#0000ff">new</font> JButton(<font color="#004488">"West"</font>));
    cp.add(BorderLayout.CENTER, 
      <font color="#0000ff">new</font> JButton(<font color="#004488">"Center"</font>));
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> BorderLayout1(), 300, 250);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Для всех место, кроме <b>CENTER</b>, элемент, который 
  вы добавляете, сжимается, чтобы занимать наименьшее пространство по одному измерению, 
  а по другому измерению он растягивается. Однако для <b>CENTER</b>, подстройка 
  идет в обоих направлениях, чтобы занять середину.</font><a name="_Toc481064797"></a></p>
<a name="Heading430"></a><font face="Verdana">
<h3 align="left"> FlowLayout<a name="Index1628"></a></h3>
</font> 
<p><font face="Georgia">При этом компоненты просто “вливаются” в форму 
  слева направо, пока не закончится место сверху, затем происходит переход на 
  нижнюю строку и продолжается заливка.</font></p>
<p><font face="Georgia">Вот пример, который устанавливает менеджер компоновки 
  <b>FlowLayout</b>. Вы заметите, что с <b>FlowLayout</b> компоненты принимают 
  свои “естественные” размеры. Например, <b>JButton</b>, будет равна 
  размеру своей строки.</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:FlowLayout1.java</font>
<font color="#009900">// Демонстрация FlowLayout.</font>
<font color="#009900">// &lt;applet code=FlowLayout1 </font>
<font color="#009900">// width=300 height=250&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> FlowLayout1 <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 20; i++)
      cp.add(<font color="#0000ff">new</font> JButton(<font color="#004488">"Button "</font> + i));
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> FlowLayout1(), 300, 250);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Все компоненты будут компактными, занимая наименьший из 
  возможных размеров, при использовании <b>FlowLayout</b>, так что вы можете быть 
  немного удивлены поведением. Например, потому что размер <b>JLabel</b> будет 
  определяться его строкой, попытка использовать выравнивание текста по правому 
  краю оставит отображение неизменным, когда вы используете </font><font face="Georgia"> 
  <b>FlowLayout</b>.</font><a name="_Toc375545460"></a><a name="_Toc481064798"></a></p>
<a name="Heading431"></a><font face="Verdana">
<h3 align="left"> GridLayout</h3>
</font> 
<p><font face="Georgia"> <a name="Index1629"></a><b>GridLayout</b> позволяет вам 
  построить таблицу компонент, и когда вы добавляете их, они помещаются слева 
  - направо и сверху - вниз в сетке. В конструкторе вы определяете число строк 
  и столбцов, сколько вам необходимо и они будут расположены в равной пропорции.</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:GridLayout1.java</font>
<font color="#009900">// Демонстрация GridLayout.</font>
<font color="#009900">// &lt;applet code=GridLayout1 </font>
<font color="#009900">// width=300 height=250&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> GridLayout1 <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> GridLayout(7,3));
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 20; i++)
      cp.add(<font color="#0000ff">new</font> JButton(<font color="#004488">"Button "</font> + i));
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> GridLayout1(), 300, 250);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">В этом случае есть 21 ячейка, но только 20 кнопок. Последний 
  слот остается пустым, не происходит “балансировки” при использовании 
  </font><font face="Georgia"> <b>GridLayout</b>.</font><a name="_Toc375545462"></a><a name="_Toc481064799"></a></p>
<a name="Heading432"></a><font face="Verdana">
<h3 align="left"> GridBagLayout</h3>
</font> 
<p><font face="Georgia"> <a name="Index1630"></a><b>GridBagLayout</b> обеспечивает 
  вас потрясающим инструментом для точного решения, как области вашего окна будут 
  располагаться, и как они будут переформатироваться при изменении размеров окна. 
  Однако это и наиболее сложный менеджер компоновки и достаточно трудный для понимания. 
  Он предназначен, в основном, для автоматического генерирования кода построителем 
  GUI (хорошие построители GUI будут использовать <b>GridBagLayout</b> вместо 
  абсолютного размещения). Если ваш дизайн достаточно сложен, и вы чувствуете 
  необходимость использовать <b>GridBagLayout</b>, то вы должны использовать инструмент 
  построителя GUI для генерации вашего дизайна. Если вы чувствуете, что должны 
  знать запутанные детали, я отошлю вас к книге <i>Core Java 2</i> by Horstmann 
  &amp; Cornell (Prentice-Hall, 1999), или к любой книге, посвященной Swing, для 
  начального знакомства.</font><a name="_Toc481064800"></a></p>
<a name="Heading433"></a><font face="Verdana">
<h3 align="left"> Абсолютное позиционирование</h3>
</font> 
<p><font face="Georgia">Также возможно установить абсолютное позиционирование 
  графической компоненты таким способом:</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Установить <b>null</b> 
    вместо менеджера компоновки для вашего <b>Container</b>: <b>setLayout(null)</b>.</font> 
  </li><li><font face="Verdana">Вызвать </font><font face="Georgia"> <b>setBounds(&nbsp;)</b> 
    или <b>reshape(&nbsp;)</b> (в зависимости от версии языка) для каждого компонента, 
    передавая прямоугольник границы в координатах пикселей. Вы можете выполнить 
    это в конструкторе или в <b>paint(&nbsp;)</b>, в зависимости от того, чего 
    вы хотите добиться.</font> 
</li></ol>
<p><font face="Georgia">Некоторые построители GUI широко используют этот подход, 
  но это обычно не лучший способ генерации кода. Более полезные построители GUI 
  используют вместо него <b>GridBagLayout</b></font><font face="Georgia">.</font><a name="_Toc481064801"></a></p>
<a name="Heading434"></a><font face="Verdana">
<h3 align="left"> BoxLayout<a name="Index1632"></a></h3>
</font> 
<p><font face="Georgia">Потому, что люди имеют много трудностей при работе с <b>GridBagLayout</b>, 
  Swing также включает <b>BoxLayout</b>, который предоставляет вам много полезного, 
  что умеет <b>GridBagLayout</b> без той сложности, так что вы можете часто использовать 
  его, когда вам нужно выполнить ручное кодирование (опят таки, если ваш дизайн 
  станет через чур сложным, используйте построитель GUI, который генерирует для 
  вас <b>GridBagLayout</b>). <b>BoxLayout</b> позволяет вам управлять вам размещением 
  компонент либо вертикально, либо горизонтально, и управлять пространством между 
  компонентами, используя что-то, называемое “<a name="Index1633"></a>подпорки 
  и <a name="Index1634"></a>склейки”. Сначала, позвольте показать, как использовать 
  <b>BoxLayout</b> непосредственно, тем же способом, как были продемонстрированы 
  другие менеджеры компоновки:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:BoxLayout1.java</font>
<font color="#009900">// Вертикальный и горизонтальный BoxLayouts.</font>
<font color="#009900">// &lt;applet code=BoxLayout1 </font>
<font color="#009900">// width=450 height=200&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> BoxLayout1 <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    JPanel jpv = <font color="#0000ff">new</font> JPanel();
    jpv.setLayout(
      <font color="#0000ff">new</font> BoxLayout(jpv, BoxLayout.Y_AXIS));
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 5; i++)
      jpv.add(<font color="#0000ff">new</font> JButton(<font color="#004488">""</font> + i));
    JPanel jph = <font color="#0000ff">new</font> JPanel();
    jph.setLayout(
      <font color="#0000ff">new</font> BoxLayout(jph, BoxLayout.X_AXIS));
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 5; i++)
      jph.add(<font color="#0000ff">new</font> JButton(<font color="#004488">""</font> + i));
    Container cp = getContentPane();
    cp.add(BorderLayout.EAST, jpv);
    cp.add(BorderLayout.SOUTH, jph);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> BoxLayout1(), 450, 200);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Конструктор для <b>BoxLayout</b> немного отличается от 
  других менеджеров компоновки — вы обеспечиваете <b>Container</b>, который 
  будет управляться <b>BoxLayout</b>, в качестве первого аргумента, и направление 
  компоновки в качестве второго аргумента.</font></p>
<p><font face="Georgia">Для упрощения дела, есть специальный контейнер, называемый 
  <a name="Index1635"></a><b>Box</b>, который использует <b>BoxLayout</b>, как 
  свой родной менеджер. Следующий пример располагает компоненты горизонтально 
  и вертикально, используя <b>Box</b>, который имеет два статических метода для 
  создания боксов с вертикальным и горизонтальным выравниванием:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Box1.java</font>
<font color="#009900">// Вертикальный и горизонтальный BoxLayouts.</font>
<font color="#009900">// &lt;applet code=Box1 </font>
<font color="#009900">// width=450 height=200&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Box1 <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Box bv = Box.createVerticalBox();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 5; i++)
      bv.add(<font color="#0000ff">new</font> JButton(<font color="#004488">""</font> + i));
    Box bh = Box.createHorizontalBox();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 5; i++)
      bh.add(<font color="#0000ff">new</font> JButton(<font color="#004488">""</font> + i));
    Container cp = getContentPane();
    cp.add(BorderLayout.EAST, bv);
    cp.add(BorderLayout.SOUTH, bh);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Box1(), 450, 200);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Как только вы получаете <b>Box</b>, вы передаете его в 
  качестве второго аргумента при добавлении компонента в панель содержания.</font></p>
<p><font face="Georgia">Распорки между компонентами измеряется в пикселях. Для 
  использования распорок, вы просто добавляете их между вставкой компонент:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:Box2.java</font>
<font color="#009900">// Добавление разделителей.</font>
<font color="#009900">// &lt;applet code=Box2 </font>
<font color="#009900">// width=450 height=300&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Box2 <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Box bv = Box.createVerticalBox();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 5; i++) {
      bv.add(<font color="#0000ff">new</font> JButton(<font color="#004488">""</font> + i));
      bv.add(Box.createVerticalStrut(i*10));
    }
    Box bh = Box.createHorizontalBox();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 5; i++) {
      bh.add(<font color="#0000ff">new</font> JButton(<font color="#004488">""</font> + i));
      bh.add(Box.createHorizontalStrut(i*10));
    }
    Container cp = getContentPane();
    cp.add(BorderLayout.EAST, bv);
    cp.add(BorderLayout.SOUTH, bh);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Box2(), 450, 300);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Распорки разделяют компоненты на фиксированную величину, 
  а склейки наоборот: они разделят компоненты настолько, насколько это возможно. 
  Так что это, скорее “пружина”, чем “клей” (а дизайн, 
  на котором это базируется должен называться “пружины и распорки”, 
  так что выбор терминов немного непонятен).</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:Box3.java</font>
<font color="#009900">// Использование Glue (клея).</font>
<font color="#009900">// &lt;applet code=Box3 </font>
<font color="#009900">// width=450 height=300&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Box3 <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Box bv = Box.createVerticalBox();
    bv.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Hello"</font>));
    bv.add(Box.createVerticalGlue());
    bv.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Applet"</font>));
    bv.add(Box.createVerticalGlue());
    bv.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"World"</font>));
    Box bh = Box.createHorizontalBox();
    bh.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Hello"</font>));
    bh.add(Box.createHorizontalGlue());
    bh.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Applet"</font>));
    bh.add(Box.createHorizontalGlue());
    bh.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"World"</font>));
    bv.add(Box.createVerticalGlue());
    bv.add(bh);
    bv.add(Box.createVerticalGlue());
    getContentPane().add(bv);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Box3(), 450, 300);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Распорки работают в одном направлении, но закрепленное 
  место фиксирует пространство между компонентами в обоих направлениях:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:Box4.java</font>
<font color="#009900">// Закрепленное Место(Rigid Areas) - это как пара распорок.</font>
<font color="#009900">// &lt;applet code=Box4 </font>
<font color="#009900">// width=450 height=300&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Box4 <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Box bv = Box.createVerticalBox();
    bv.add(<font color="#0000ff">new</font> JButton(<font color="#004488">"Top"</font>));
    bv.add(Box.createRigidArea(
      <font color="#0000ff">new</font> Dimension(120, 90)));
    bv.add(<font color="#0000ff">new</font> JButton(<font color="#004488">"Bottom"</font>));
    Box bh = Box.createHorizontalBox();
    bh.add(<font color="#0000ff">new</font> JButton(<font color="#004488">"Left"</font>));
    bh.add(Box.createRigidArea(
      <font color="#0000ff">new</font> Dimension(160, 80)));
    bh.add(<font color="#0000ff">new</font> JButton(<font color="#004488">"Right"</font>));
    bv.add(bh);
    getContentPane().add(bv);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Box4(), 450, 300);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Вы должны знать, что закрепленные области несколько спорны.</font><font face="Georgia"> 
  Так как они использую абсолютное значение, некоторые люди чувствуют, что они 
  причиняют больше неприятностей, чем они стоят.</font><a name="_Toc481064802"></a></p>
<a name="Heading435"></a><font face="Verdana">
<h3 align="left"> Лучший подход?</h3>
</font> 
<p><font face="Georgia">Swing достаточно мощный; он может дать очень много при 
  использовании всего нескольких строк. Примеры, показанные в этой книге, достаточно 
  просты, и с целью обучения есть смысл писать их руками. Вы на самом деле можете 
  выбрать комбинацию простых компоновок. Однако, с некоторой точки зрения, это 
  теряет смысл для ручного проектирования GUI форм — это становится слишком 
  сложным, и вы теряете время при программировании. Разработчики Java и Swing 
  ориентировали язык и библиотеку на использование инструментов поддержки построителей 
  GUI, которые были созданы с целью ускорения создания и приобретения опыта программирования. 
  Как только вы поймете, что происходит с компоновкой и как работать с событиями 
  (описано далее), то не особенно важно, что вы на самом деле знаете детали того, 
  как располагать компоненты в ручную — позвольте соответствующему инструменту 
  сделать это за вас (Java, помимо всего, предназначена для увеличения продуктивности 
  программиста).</font><a name="_Toc481064803"></a></p>
<a name="Heading436"></a><font face="Verdana">
<h2 align="left">Модель событий Swing<a name="Index1636"></a><a name="Index1637"></a><a name="Index1638"></a><a name="Index1639"></a><a name="Index1640"></a></h2>
</font> 
<p><font face="Georgia">В модели событий Swing компоненты могут инициировать (“возбуждать”) 
  события. Каждый тип события представляется разными классами. Когда событие возбуждается 
  событие, оно принимается одним или несколькими “слушателями”, которые 
  реагируют на это событие. Таким образом, источник событий и место, где событие 
  обрабатывается, могут быть разделены. Так как вы обычно используете компоненты 
  Swing, как они есть, то необходимо писать код, вызывающийся в том случае, когда 
  компонент принимает событие, это хороший пример разделения интерфейса и реализации.</font></p>
<p><a name="Index1642"></a><font face="Georgia">Каждый слушатель события - это 
  объект класса, который реализует определенный тип интерфейса слушателя. Как 
  программист, все, что вы делаете - это создаете объект слушателя и регистрируете 
  его в компоненте, который возбуждает событие. Эта регистрация выполняется вызовом 
  метода <b>addXXXListener(&nbsp;)</b> для компонента, возбуждающего событие, 
  в котором “<b>XXX</b>” представляет тип слушателя события. Вы можете 
  легко узнать, какой тип события может быть обработан, просмотрев имена методов 
  “addListener”, и если вы попробуете слушать неверные события, вы 
  обнаружите ошибку времени компиляции. Позже в этой главе вы увидите, что JavaBeans 
  также использует имена методов “addListener” для определения того, 
  какое событие может обработать Bean.</font></p>
<p><font face="Georgia">Поэтому, вся ваша событийная логика переходит в класс 
  слушателя. Когда вы создаете класс-слушатель, главное ограничение в том, что 
  он должен реализовывать подходящий интерфейс. Вы можете создать класс глобального 
  слушателя. Но это та ситуация, в которой <a name="Index1643"></a><a name="Index1644"></a>внутренние 
  классы более полезны, не только потому, что они обеспечивают логическое группирование 
  ваших классов - слушателей внутри UI или логических бизнес - классов, которые 
  они обслуживают, но и потому (как вы увидите позже), что фактически, объект 
  внутреннего класса хранит ссылку на родительский объект, обеспечивая лучший 
  способ для перекрестного вызова класса и подсистемных границ.</font></p>
<p><font face="Georgia">Все дальнейшие примеры этой главы используют модель событий 
  Swing, а оставшаяся часть этого раздела опишет детали этой модели.</font><a name="_Toc481064804"></a></p>
<div align="left"></div>
<a name="Heading437"></a><font face="Verdana">
<h3 align="left"> События и типы слушателей</h3>
</font> 
<p><font face="Georgia">Все компоненты Swing включают методы <b>addXXXListener(&nbsp;)</b> 
  и <b>removeXXXListener(&nbsp;)</b>, так что подходящий тип слушателя может быть 
  добавлен и удален для каждого компонента. Вы заметите, что “<b>XXX</b>” 
  в каждом случае также представляет аргумент метода, например: <b>addMyListener(MyListener 
  m)</b>. Приведенная ниже таблица включает основные ассоциированные события, 
  слушатели и методы, наряду с основными компонентами, которые поддерживают эти 
  определенные события, обеспечивая методы <a name="Index1645"></a><b>addXXXListener(&nbsp;)</b> 
  и <a name="Index1646"></a><b>removeXXXListener(&nbsp;)</b>. Вы должны иметь 
  в виду, что модель событий разработана для расширения, так что вы можете насчитать 
  другие <a name="Index1647"></a><a name="Index1648"></a>события и типы слушателей, 
  не попавшие в эту таблицу.</font></p>
<table border="1" width="100%">
  <tbody><tr valign="top"> 
    <th colspan="1" rowspan="1" valign="top" width="182"> Событие, интерфейс слушателя 
      и методы добавления, удаления</th>
    <th colspan="1" rowspan="1" valign="top" width="182"> <font face="Georgia"><b>Компоненты, 
      поддерживающие это событие</b></font> </th>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>ActionEvent</b></font><br>
      <font face="Georgia"><b>ActionListener</b></font><br>
      <font face="Georgia"><b>addActionListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeActionListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia"><b>JButton, JList, JTextField, JMenuItem </b> и 
      наследованные от них, включая <b> JCheckBoxMenuItem, JMenu </b>и<b> JpopupMenu.</b></font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>AdjustmentEvent</b></font><br>
      <font face="Georgia"><b>AdjustmentListener</b></font><br>
      <font face="Georgia"><b>addAdjustmentListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeAdjustmentListener(&nbsp;)</b></font></td>
    <td> 
      <div align="left"> 
        <p><font face="Georgia"><b>JScrollbar</b></font> и все, что вы создаете, 
          реализуя <font face="Georgia"> <b> Adjustable interface.</b></font></p>
      </div>
    </td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>ComponentEvent</b></font><br>
      <font face="Georgia"><b>ComponentListener</b></font><br>
      <font face="Georgia"><b>addComponentListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeComponentListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia"><b>*Component </b>и наследованные от него, включая 
      <b>JButton, JCanvas, JCheckBox, JComboBox, Container, JPanel, JApplet, JScrollPane, 
      Window, JDialog, JFileDialog, JFrame, JLabel, JList, JScrollbar, JTextArea 
      </b>и <b>JTextField.</b></font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>ContainerEvent</b></font><br>
      <font face="Georgia"><b>ContainerListener</b></font><br>
      <font face="Georgia"><b>addContainerListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeContainerListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia"><b>Container </b>и наследованные от него, включая<b> 
      JPanel, JApplet, JScrollPane, Window, JDialog, JFileDialog </b>и<b> JFrame.</b></font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>FocusEvent</b></font><br>
      <font face="Georgia"><b>FocusListener</b></font><br>
      <font face="Georgia"><b>addFocusListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeFocusListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia"><b>Component </b>и<b> унаследованные*.</b></font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>KeyEvent</b></font><br>
      <font face="Georgia"><b>KeyListener</b></font><br>
      <font face="Georgia"><b>addKeyListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeKeyListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia"><b>Component </b></font><font face="Georgia">и<b> 
      унаследованные*.</b></font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>MouseEvent </b>(для кликов и перемещений)</font><br>
      <font face="Georgia"><b>MouseListener</b></font><br>
      <font face="Georgia"><b>addMouseListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeMouseListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia"><b>Component </b></font><font face="Georgia">и<b> 
      унаследованные*.</b></font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>MouseEvent</b></font><a href="#fn68">[68]</a><font face="Georgia"><b> 
      </b>(для кликов и перемещений)</font><br>
      <font face="Georgia"><b>MouseMotionListener</b></font><br>
      <font face="Georgia"><b>addMouseMotionListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeMouseMotionListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia"><b>Component </b></font><font face="Georgia">и<b> 
      унаследованные*.</b></font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>WindowEvent</b></font><br>
      <font face="Georgia"><b>WindowListener</b></font><br>
      <font face="Georgia"><b>addWindowListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeWindowListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia"><b>Window </b>и унаследованные от него, включая 
      <b> JDialog, JFileDialog</b> и <b>JFrame.</b></font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>ItemEvent</b></font><br>
      <font face="Georgia"><b>ItemListener</b></font><br>
      <font face="Georgia"><b>addItemListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeItemListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia"><b>JCheckBox, JCheckBoxMenuItem, JComboBox, JList 
      </b> и все, что реализует <b>ItemSelectable interface.</b></font></td>
  </tr>
  <tr valign="top"> 
    <td> <font face="Georgia"><b>TextEvent</b></font><br>
      <font face="Georgia"><b>TextListener</b></font><br>
      <font face="Georgia"><b>addTextListener(&nbsp;)</b></font><br>
      <font face="Georgia"><b>removeTextListener(&nbsp;)</b></font></td>
    <td> <font face="Georgia">Все, что унаследовано от <b> JTextComponent, </b>включая<b> 
      JTextArea </b>и<b> JTextField.</b></font></td>
  </tr>
</tbody></table>
<p></p>
<p><font face="Georgia">Вы видите, что каждый тип компонент поддерживает только 
  определенные типы событий. Оказывается, довольно трудно просмотреть все события, 
  поддерживаемые компонентом. Простой подход - это изменение программы <b>ShowMethodsClean.java</b> 
  из <a href=" Chapter12.html">Главы 12</a>, чтобы отобразить все слушатели событий, 
  поддерживаемые компонентами Swing, которые вы вводите.</font></p>
<p><a name="Index1649"></a><font face="Georgia">В <a href=" Chapter12.html">Главе 
  12</a> была введена <a name="Index1650"></a><i>рефлексия</i>, которая использовалась 
  для поиска методов определенного класса — или всего списка методов или 
  подмножества методов, имена которых содержат передаваемое вами ключевое слово. 
  Магия этого в том, что так автоматически можно показать все методы класса без 
  прохождения по иерархии наследования, проверяя классы на всех уровнях. Таким 
  образом, это обеспечивает сохранение драгоценного времени при программировании: 
  потому что имена большинства методов Java сделаны очень многозначительными и 
  описательными, вы можете искать имена методов, содержащих определенное, интересующее 
  вас слово. Когда вы найдете то, что вы искали, проверьте онлайн документацию.</font></p>
<p><font face="Georgia">Однако в <a href=" Chapter12.html">Главе 12</a> не было 
  Swing, поэтому инструментарий той главы был разработан как приложение для командной 
  строки. Здесь более полезная GUI версия, специализирующаяся на поиске методов 
  “addListener” в компонентах Swing:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:ShowAddListeners.java</font>
<font color="#009900">// Отображение методов "addXXXListener" любого</font>
<font color="#009900">// класса Swing.</font>
<font color="#009900">// &lt;applet code = ShowAddListeners </font>
<font color="#009900">// width=500 height=400&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> javax.swing.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.lang.reflect.*;
<font color="#0000ff">import</font> java.io.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;
<font color="#0000ff">import</font> com.bruceeckel.util.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ShowAddListeners <font color="#0000ff">extends</font> JApplet {
  Class cl;
  Method[] m;
  Constructor[] ctor;
  String[] n = <font color="#0000ff">new</font> String[0];
  JTextField name = <font color="#0000ff">new</font> JTextField(25);
  JTextArea results = <font color="#0000ff">new</font> JTextArea(40, 65);
  <font color="#0000ff">class</font> NameL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      String nm = name.getText().trim();
      <font color="#0000ff">if</font>(nm.length() == 0) {
        results.setText(<font color="#004488">"No match"</font>);
        n = <font color="#0000ff">new</font> String[0];
        <font color="#0000ff">return</font>;
      }
      <font color="#0000ff">try</font> {
        cl = Class.forName(<font color="#004488">"javax.swing."</font> + nm);
      } <font color="#0000ff">catch</font>(ClassNotFoundException ex) {
        results.setText(<font color="#004488">"No match"</font>);
        <font color="#0000ff">return</font>;
      }
      m = cl.getMethods();
      <font color="#009900">// Преобразование в массив Strings:</font>
      n = <font color="#0000ff">new</font> String[m.length];
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; m.length; i++)
        n[i] = m[i].toString();
      reDisplay();
    }
  } 
  <font color="#0000ff">void</font> reDisplay() {
    <font color="#009900">// Создание результирующего множества:</font>
    String[] rs = <font color="#0000ff">new</font> String[n.length];
    <font color="#0000ff">int</font> j = 0;
    <font color="#0000ff">for</font> (<font color="#0000ff">int</font> i = 0; i &lt; n.length; i++)
      <font color="#0000ff">if</font>(n[i].indexOf(<font color="#004488">"add"</font>) != -1 &amp;&amp;
        n[i].indexOf(<font color="#004488">"Listener"</font>) != -1)
          rs[j++] = 
            n[i].substring(n[i].indexOf(<font color="#004488">"add"</font>));
    results.setText(<font color="#004488">""</font>);
    <font color="#0000ff">for</font> (<font color="#0000ff">int</font> i = 0; i &lt; j; i++)
      results.append(
        StripQualifiers.strip(rs[i]) + <font color="#004488">"\n"</font>);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    name.addActionListener(<font color="#0000ff">new</font> NameL());
    JPanel top = <font color="#0000ff">new</font> JPanel();
    top.add(<font color="#0000ff">new</font> JLabel(
      <font color="#004488">"Swing class name (press ENTER):"</font>));
    top.add(name);
    Container cp = getContentPane();
    cp.add(BorderLayout.NORTH, top);
    cp.add(<font color="#0000ff">new</font> JScrollPane(results));
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> ShowAddListeners(), 500,400);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Класс <b>StripQualifiers</b>, определенный в <a href=" Chapter12.html">Главе 
  12</a> здесь повторно используется, импортируясь из библиотеки <b>com.bruceeckel.util</b>.</font></p>
<p><font face="Georgia"> GUI содержит <b> JTextField</b> <b>name</b>, в котором 
  вы можете вводить имя класса Swing, который вы хотите просмотреть. Результат 
  отображается в <b>JTextArea</b>.</font></p>
<p><font face="Georgia">Вы увидите, что нет никаких кнопок или других компонент, 
  чтобы указать, что можно начать поиск. Это потому, что за <b>JTextField</b> 
  следит <b>ActionListener</b>. Когда вы сделаете изменения и нажмете ENTER, список 
  немедленно обновится. Если текст не пустой, он используется внутри <a name="Index1651"></a><a name="Index1652"></a><b>Class.forName(&nbsp;)</b>, 
  чтобы попытаться найти класс. Если имя неверное, <b>Class.forName(&nbsp;)</b> 
  завершится неудачей, в результате чего появится исключение. Оно будет поймано 
  и в <b>JTextArea</b> появится “No match”. Но если вы напечатаете 
  корректное имя (включая большие буквы), <b>Class.forName(&nbsp;)</b> завершится 
  успешно и <b>getMethods(&nbsp;)</b> вернет массив объектов <b>Method</b>. Каждый 
  объект массива включается в <b>String</b> через <b>toString(&nbsp;)</b> (так 
  получается полная сигнатура метода) и добавляется в <b>n</b> - массив <b>String</b>. 
  Массив <b>n</b> - это член класса <b>ShowAddListeners</b>, он используется при 
  обновлении отображения, когда вызывается <b>reDisplay(&nbsp;).</b></font></p>
<p><font face="Georgia"><b>reDisplay(&nbsp;)</b> создает массив <b>String</b>, 
  называемый <b>rs</b> (для “result set”). Результирующее множество 
  условно копируется из <b>String</b> в <b>n</b>, который содержит “add” 
  и “Listener”. Затем используются <b>indexOf(&nbsp;) </b>и <b>substring(&nbsp;) 
  </b>для удаления квалификаторов, таких как <b>public</b>, <b>static</b> и т.п. 
  В конце <b>StripQualifiers.strip(&nbsp;)</b> удаляет дополнительные квалификаторы 
  имени.</font></p>
<p><font face="Georgia">Эта программа - это удобный способ для исследования совместимости 
  компонент Swing. Как только вы узнаете, какие события поддерживает определенный 
  компонент, вам не нужно будет искать ничего, чтобы отреагировать на это событие. 
  Вы просто:</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Берете имя класса события 
    и удаляете слово “<b>Event</b>”. К остатку прибавляете слово “<b>Listener</b>”. 
    Это интерфейс слушателя, который вы должны реализовать в вашем внутреннем 
    классе.</font>
  </li><li><font face="Georgia">Реализуете<font face="Verdana"> </font>вышеупомянутый 
    интерфейс и пишите методы для событий, который вы хотите отслеживать. Например, 
    вы можете следить за движением мыши, тогда вы пишите код метода <b>mouseMoved(&nbsp;)</b> 
    из интерфейса <b>MouseMotionListener</b>. (Конечно, вы должны реализовать 
    другие методы, но есть сокращения, которые вы скоро увидите.)</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Создаете объект класса 
    слушателя из Шага 2. Регистрируете его в вашем компоненте с помощью метода, 
    произведенного добавлением “<b>add</b>” к имени вашего слушателя. 
    Например: <b>addMouseMotionListener(&nbsp;)</b>.</font>
</li></ol>
<p><font face="Georgia">Вот некоторые из <a name="Index1653"></a>интерфейсов слушателя:</font></p>
<div align="center">
  <table border="1">
    <tbody><tr valign="top"> 
      <th colspan="1" rowspan="1" valign="top" width="144"> <font face="Georgia"><b>Интерфейс 
        слушателя </b></font><br>
        <font face="Georgia"><b>w/ adapter</b></font></th>
      <th colspan="1" rowspan="1" valign="top" width="238"> <font face="Georgia"><b>Методы 
        интерфейса</b></font></th>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>ActionListener</b></font></td>
      <td> <font face="Georgia"><b>actionPerformed(ActionEvent)</b></font></td>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>AdjustmentListener</b></font></td>
      <td> <font face="Georgia"><b>adjustmentValueChanged(</b></font><br>
        <font face="Georgia"><b> AdjustmentEvent)</b></font></td>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>ComponentListener</b></font><br>
        <font face="Georgia"><b>ComponentAdapter</b></font></td>
      <td> <font face="Georgia"><b>componentHidden(ComponentEvent)</b></font><br>
        <font face="Georgia"><b>componentShown(ComponentEvent)</b></font><br>
        <font face="Georgia"><b>componentMoved(ComponentEvent)</b></font><br>
        <font face="Georgia"><b>componentResized(ComponentEvent)</b></font></td>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>ContainerListener</b></font><br>
        <font face="Georgia"><b>ContainerAdapter</b></font></td>
      <td> <font face="Georgia"><b>componentAdded(ContainerEvent)</b></font><br>
        <font face="Georgia"><b>componentRemoved(ContainerEvent)</b></font></td>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>FocusListener</b></font><br>
        <font face="Georgia"><b>FocusAdapter</b></font></td>
      <td> <font face="Georgia"><b>focusGained(FocusEvent)</b></font><br>
        <font face="Georgia"><b>focusLost(FocusEvent)</b></font></td>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>KeyListener</b></font><br>
        <font face="Georgia"><b>KeyAdapter</b></font></td>
      <td> <font face="Georgia"><b>keyPressed(KeyEvent)</b></font><br>
        <font face="Georgia"><b>keyReleased(KeyEvent)</b></font><br>
        <font face="Georgia"><b>keyTyped(KeyEvent)</b></font></td>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>MouseListener</b></font><br>
        <font face="Georgia"><b>MouseAdapter</b></font></td>
      <td> <font face="Georgia"><b>mouseClicked(MouseEvent)</b></font><br>
        <font face="Georgia"><b>mouseEntered(MouseEvent)</b></font><br>
        <font face="Georgia"><b>mouseExited(MouseEvent)</b></font><br>
        <font face="Georgia"><b>mousePressed(MouseEvent)</b></font><br>
        <font face="Georgia"><b>mouseReleased(MouseEvent)</b></font></td>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>MouseMotionListener</b></font><br>
        <font face="Georgia"><b>MouseMotionAdapter</b></font></td>
      <td> <font face="Georgia"><b>mouseDragged(MouseEvent)</b></font><br>
        <font face="Georgia"><b>mouseMoved(MouseEvent)</b></font></td>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>WindowListener</b></font><br>
        <font face="Georgia"><b>WindowAdapter</b></font></td>
      <td> <font face="Georgia"><b>windowOpened(WindowEvent)</b></font><br>
        <font face="Georgia"><b>windowClosing(WindowEvent) </b></font><br>
        <font face="Georgia"><b>windowClosed(WindowEvent) </b></font><br>
        <font face="Georgia"><b>windowActivated(WindowEvent) </b></font><br>
        <font face="Georgia"><b>windowDeactivated(WindowEvent) </b></font><br>
        <font face="Georgia"><b>windowIconified(WindowEvent) </b></font><br>
        <font face="Georgia"><b>windowDeiconified(WindowEvent)</b></font></td>
    </tr>
    <tr valign="top"> 
      <td> <font face="Georgia"><b>ItemListener</b></font></td>
      <td> <font face="Georgia"><b>itemStateChanged(ItemEvent)</b></font></td>
    </tr>
  </tbody></table>
  <p></p>
</div>
<p><font face="Georgia">Это не полный список, частично потому, что событийная 
  модель позволяет вам создавать вам свои собственные типы событий и ассоциированные 
  слушатели. Таким образом, вы регулярно будете просматривать библиотеки, чтобы 
  унаследовать свое собственное событие, и знания, полученные в этой главе, позволят 
  вам понять, как использовать это события.</font></p>
<a name="Heading438"></a><font face="Verdana">
<h4 align="left"> Использование слушающих адаптеров для упрощения<a name="Index1654"></a><a name="Index1655"></a></h4>
</font> 
<p><font face="Georgia">В приведенной выше таблице вы можете видеть, что некоторые 
  интерфейсы слушателей имеют только один метод. Они очень просты для реализации, 
  так как вы реализуете его, только когда напишите этот определенный метод. Однако 
  интерфейсы слушателей, имеющие несколько методов, менее приятны в использовании. 
  Например, то, что вы должны всегда делать при создании приложения, это обеспечение 
  <b>WindowListener</b> для <b>JFrame</b>, так что когда вы получаете событие 
  <b>windowClosing(&nbsp;)</b>, вы могли бы вызвать <b>System.exit(&nbsp;)</b> 
  для выхода из приложения. Но так как <b>WindowListener</b> - это интерфейс, 
  вы должны реализовать все другие методы, даже если они ничего не делают. Это 
  может раздражать.</font></p>
<p><font face="Georgia">Для решения проблемы некоторые (но не все) из интерфейсов 
  слушателей, которые имеют более одного метода, снабжаются адаптерами, имена 
  которых вы можете видеть в приведенной выше таблице. Каждый адаптер обеспечивает 
  по умолчанию пустые методы для каждого метода интерфейса. Поэтому все, что вам 
  нужно сделать - это наследовать от адаптера и перекрыть только те методы, которые 
  нужно изменить. Например, типичный <b>WindowListener</b>, который вы будете 
  использовать, выглядит так (помните, что это было помещено внутрь класса <b>Console</b> 
  в <b>com.bruceeckel.swing</b>):</font></p>
<blockquote><font size="+1">
  <pre><font color="#0000ff">class</font> MyWindowListener <font color="#0000ff">extends</font> WindowAdapter {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> windowClosing(WindowEvent e) {
    System.exit(0);
  }
}</pre>
  </font></blockquote>
<p><font face="Georgia">Основное назначение адаптеров состоит в облегчении создания 
  слушающих классов.</font></p>
<p><font face="Georgia">Однако есть темная сторона адаптеров, из-за которой можно 
  попасть в ловушку. Предположим, что вы написали <b>WindowAdapter</b> как показано 
  выше</font><font face="Georgia">:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  <pre><font color="#0000ff">class</font> MyWindowListener <font color="#0000ff">extends</font> WindowAdapter {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> WindowClosing(WindowEvent e) {
    System.exit(0);
  }
}</pre>
  </font></blockquote>
<p><font face="Georgia">Это не работает и это может свести вас с ума в попытке 
  узнать почему, так как все прекрасно компилируется и запускается — за 
  исключением того, что окно при закрытии окна не происходит выход из программы. 
  Вы видите проблему? Она в имени метода <b>WindowClosing(&nbsp;)</b> вместо <b>windowClosing(&nbsp;)</b>. 
  Однако это не тот метод, который вызывается при закрытии окна, так что вы не 
  получаете желаемый результат. Несмотря на неудобства, интерфейс гарантирует, 
  что методы будут реализованы правильно.</font><a name="_Toc375545452"></a><a name="_Toc481064805"></a></p>
<a name="Heading439"></a><font face="Verdana">
<h3 align="left"> Отслеживание множественных событий</h3>
</font> 
<p><font face="Georgia">Чтобы убедится, что эти события действительно возбуждаются, 
  и в качестве эксперимента, стоит создать апплет, который отслеживает дополнительное 
  поведение <b>JButton </b>(а не только следит за его нажатием). Этот пример также 
  показывает вам, как наследовать вашу собственный объект кнопки, потому что она 
  будет использоваться как мишень для всех интересующих нас событий. Чтобы сделать 
  это, вы просто наследуете от <a name="Index1656"></a> <b>JButton</b>.</font><a href="#fn69">[69]</a></p>
<p><font face="Georgia">Класс <b>MyButton</b> - это внутренний класс <b>TrackEvent</b>, 
  так что <b>MyButton</b> может получить доступ в родительское окно и управлять 
  его текстовыми полями, что необходимо для записи информации статуса в поля родителя. 
  Конечно это ограниченная ситуация, так как <b>myButton</b> может использоваться 
  только в соединении с <b>TrackEvent</b>. Код такого рода иногда называется “глубоко 
  связанный”:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:TrackEvent.java</font>
<font color="#009900">// Показ возникающих событий.</font>
<font color="#009900">// &lt;applet code=TrackEvent</font>
<font color="#009900">//  width=700 height=500&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.util.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> TrackEvent <font color="#0000ff">extends</font> JApplet {
  HashMap h = <font color="#0000ff">new</font> HashMap();
  String[] event = {
    <font color="#004488">"focusGained"</font>, <font color="#004488">"focusLost"</font>, <font color="#004488">"keyPressed"</font>,
    <font color="#004488">"keyReleased"</font>, <font color="#004488">"keyTyped"</font>, <font color="#004488">"mouseClicked"</font>,
    <font color="#004488">"mouseEntered"</font>, <font color="#004488">"mouseExited"</font>,<font color="#004488">"mousePressed"</font>,
    <font color="#004488">"mouseReleased"</font>, <font color="#004488">"mouseDragged"</font>, <font color="#004488">"mouseMoved"</font>
  };
  MyButton
    b1 = <font color="#0000ff">new</font> MyButton(Color.blue, <font color="#004488">"test1"</font>),
    b2 = <font color="#0000ff">new</font> MyButton(Color.red, <font color="#004488">"test2"</font>);
  <font color="#0000ff">class</font> MyButton <font color="#0000ff">extends</font> JButton {
    <font color="#0000ff">void</font> report(String field, String msg) {
      ((JTextField)h.get(field)).setText(msg);
    }    
    FocusListener fl = <font color="#0000ff">new</font> FocusListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> focusGained(FocusEvent e) {
        report(<font color="#004488">"focusGained"</font>, e.paramString());
      }
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> focusLost(FocusEvent e) {
        report(<font color="#004488">"focusLost"</font>, e.paramString());
      }
    };
    KeyListener kl = <font color="#0000ff">new</font> KeyListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> keyPressed(KeyEvent e) {
        report(<font color="#004488">"keyPressed"</font>, e.paramString());
      }
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> keyReleased(KeyEvent e) {
        report(<font color="#004488">"keyReleased"</font>, e.paramString());
      }
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> keyTyped(KeyEvent e) {
        report(<font color="#004488">"keyTyped"</font>, e.paramString());
      }
    };
    MouseListener ml = <font color="#0000ff">new</font> MouseListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> mouseClicked(MouseEvent e) {
        report(<font color="#004488">"mouseClicked"</font>, e.paramString());
      }
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> mouseEntered(MouseEvent e) {
        report(<font color="#004488">"mouseEntered"</font>, e.paramString());
      }
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> mouseExited(MouseEvent e) {
        report(<font color="#004488">"mouseExited"</font>, e.paramString());
      }
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> mousePressed(MouseEvent e) {
        report(<font color="#004488">"mousePressed"</font>, e.paramString());
      }
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> mouseReleased(MouseEvent e) {
        report(<font color="#004488">"mouseReleased"</font>, e.paramString());
      }
    };
    MouseMotionListener mml = 
      <font color="#0000ff">new</font> MouseMotionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> mouseDragged(MouseEvent e) {
        report(<font color="#004488">"mouseDragged"</font>, e.paramString());
      }
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> mouseMoved(MouseEvent e) {
        report(<font color="#004488">"mouseMoved"</font>, e.paramString());
      }
    };
    <font color="#0000ff">public</font> MyButton(Color color, String label) {
      <font color="#0000ff">super</font>(label);
      setBackground(color);
      addFocusListener(fl);
      addKeyListener(kl);
      addMouseListener(ml);
      addMouseMotionListener(mml);
    }
  }  
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container c = getContentPane();
    c.setLayout(<font color="#0000ff">new</font> GridLayout(event.length+1,2));
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; event.length; i++) {
      JTextField t = <font color="#0000ff">new</font> JTextField();
      t.setEditable(<font color="#0000ff">false</font>);
      c.add(<font color="#0000ff">new</font> JLabel(event[i], JLabel.RIGHT));
      c.add(t);
      h.put(event[i], t);
    }
    c.add(b1);
    c.add(b2);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> TrackEvent(), 700, 500);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">В конструкторе <b>MyButton</b> устанавливается цвет вызовом 
  <b>SetBackground(&nbsp;)</b>. Все слушатели устанавливаются простым вызовом 
  метода.</font></p>
<p><font face="Georgia">Класс <b>TrackEvent</b> содержит <a name="Index1657"></a><b>HashMap</b> 
  для хранения строк, представляющих тип события, и поля <b>JTextField</b>, которые 
  содержат информацию о событиях. Конечно, это должно создаваться статически перед 
  помещением в <b>HashMap</b>, но я думаю, что вы согласитесь, что это гораздо 
  легче использовать и изменять. Обычно, если вам нужно добавить или удалить новый 
  тип события в <b>TrackEvent</b>, вы просто добавляете или удаляете строку в 
  массиве <b>event</b> — все остальное происходит автоматически.</font></p>
<p><font face="Georgia">Когда вызывается <b>report(&nbsp;)</b> он дает имя события 
  и строку параметров события. Далее используется <b>HashMap h</b> из внешнего 
  класса для поиска реального <b>JTextField</b>, ассоциированного с этим именем 
  события, и происходит помещение строки параметров в это поле.</font></p>
<p><font face="Georgia">С этот примером забавно поиграть, так как вы на самом 
  деле видите то, что происходит с событиями в вашей программе.</font><a name="_Toc481064806"></a></p>
<div align="left"></div>
<a name="Heading440"></a> <font face="Verdana">
<h2 align="left">Каталог компонентов Swing<a name="Index1658"></a></h2>
</font> 
<p><font face="Georgia">Теперь, когда вы понимаете менеджеры компоновки и модель 
  событий, вы готовы посмотреть как использовать компоненты Swing. Этот раздел 
  не является исчерпывающим описанием компонент Swing и их свойств, которые вы, 
  вероятно, будите использовать большую часть времени. Каждый пример намеренно 
  сделан очень маленьким, чтобы вы могли разобрать код и использовать его в ваших 
  программах.</font></p>
<p><font face="Georgia">Вы легко увидите, как выглядит каждый из этих примеров 
  при запуске при просмотре HTML страниц в скаченном исходном коде для этой главы.</font></p>
<font size="+1"> 
<pre>Имейте в виду:</pre>
</font> 
<ol>
  <li><font face="Verdana"> </font><font face="Georgia"> HTML документация с java.sun.com 
    содержит все классы Swing и их методы (здесь показаны только некоторые из 
    них).</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Поскольку для названия 
    событий Swing используется соглашение, очень легко узнать, как написать и 
    установить обработчик определенного типа события. Используйте программу поиска 
    <b>ShowAddListeners.java</b> из предыдущей части этой главы в помощь вашему 
    исследованию определенного компонента.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Когда вещи становятся 
    сложными, вы должны располагать GUI построителем.</font><a name="_Toc481064807"></a> 
</li></ol>
<a name="Heading441"></a><font face="Verdana">
<h3 align="left"> Кнопки</h3>
</font> 
<p><font face="Georgia">Swing включает несколько разных типов <a name="Index1659"></a>кнопок. 
  Все кнопки, checkBox-элементы, радио кнопки и даже элементы меню наследованы 
  от <a name="Index1660"></a><b>AbstractButton</b> (который, так как сюда включен 
  элемент меню, вероятно должен называться “AbstractChooser” или аналогичным 
  образом). Вы скоро увидите использование элементов меню, но следующий пример 
  показывает различные поддерживаемые типы кнопок:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:Buttons.java</font>
<font color="#009900">// Различные кнопки Swing.</font>
<font color="#009900">// &lt;applet code=Buttons</font>
<font color="#009900">//  width=350 height=100&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> javax.swing.plaf.basic.*;
<font color="#0000ff">import</font> javax.swing.border.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Buttons <font color="#0000ff">extends</font> JApplet {
  JButton jb = <font color="#0000ff">new</font> JButton(<font color="#004488">"JButton"</font>);
  BasicArrowButton
    up = <font color="#0000ff">new</font> BasicArrowButton(
      BasicArrowButton.NORTH),
    down = <font color="#0000ff">new</font> BasicArrowButton(
      BasicArrowButton.SOUTH),
    right = <font color="#0000ff">new</font> BasicArrowButton(
      BasicArrowButton.EAST),
    left = <font color="#0000ff">new</font> BasicArrowButton(
      BasicArrowButton.WEST);
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(jb);
    cp.add(<font color="#0000ff">new</font> JToggleButton(<font color="#004488">"JToggleButton"</font>));
    cp.add(<font color="#0000ff">new</font> JCheckBox(<font color="#004488">"JCheckBox"</font>));
    cp.add(<font color="#0000ff">new</font> JRadioButton(<font color="#004488">"JRadioButton"</font>));
    JPanel jp = <font color="#0000ff">new</font> JPanel();
    jp.setBorder(<font color="#0000ff">new</font> TitledBorder(<font color="#004488">"Directions"</font>));
    jp.add(up);
    jp.add(down);
    jp.add(left);
    jp.add(right);
    cp.add(jp);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Buttons(), 350, 100);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Пример начинается с <a name="Index1661"></a><b>BasicArrowButton</b> 
  из <b>javax.swing.plaf.basic</b>, затем вводятся различные специфичные типы 
  кнопок. Когда вы запустите пример, вы увидите, что переключающаяся кнопка запоминает 
  свое последнее состояние, нажатая или нет. Checkbox-элемент и радио кнопка имеют 
  идентичное поведение, нужно просто кликнуть на нее для включения или выключения 
  (они унаследованы от </font><font face="Georgia"> <a name="Index1662"></a><b>JToggleButton</b>).</font></p>
<a name="Heading442"></a><font face="Verdana">
<h4 align="left"> Группы кнопок<a name="Index1663"></a></h4>
</font> 
<p><font face="Georgia">Если вам нужны радио кнопки для получения поведения, вида 
  “исключающего или”, вы должны добавить их в “группу кнопок”. 
  Но, как показывает приведенный ниже пример, любая <b>AbstractButton</b> может 
  быть добавлена в <b>ButtonGroup</b>.</font></p>
<p><font face="Georgia"> </font><font face="Georgia">Для предотвращения повтора 
  большого количества кода этот пример использует <a name="Index1664"></a>рефлексию 
  для генерации различных типов кнопок. Это происходит в <b>makeBPanel(&nbsp;)</b>, 
  которая создает группу кнопок и <a name="Index1665"></a><b>JPanel</b>. Второй 
  аргумент для <b>makeBPanel(&nbsp;)</b> - это массив <b>String</b>. Для каждого 
  <b>String</b>, в <b>JPanel</b> добавляется кнопка класса, соответствующего первому 
  аргументу:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:ButtonGroups.java</font>
<font color="#009900">// Использование рефлексии для создания групп</font>
<font color="#009900">// различных типов AbstractButton.</font>
<font color="#009900">// &lt;applet code=ButtonGroups</font>
<font color="#009900">//  width=500 height=300&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> javax.swing.border.*;
<font color="#0000ff">import</font> java.lang.reflect.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ButtonGroups <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">static</font> String[] ids = { 
    <font color="#004488">"June"</font>, <font color="#004488">"Ward"</font>, <font color="#004488">"Beaver"</font>, 
    <font color="#004488">"Wally"</font>, <font color="#004488">"Eddie"</font>, <font color="#004488">"Lumpy"</font>,
  };
  <font color="#0000ff">static</font> JPanel 
  makeBPanel(Class bClass, String[] ids) {
    ButtonGroup bg = <font color="#0000ff">new</font> ButtonGroup();
    JPanel jp = <font color="#0000ff">new</font> JPanel();
    String title = bClass.getName();
    title = title.substring(
      title.lastIndexOf('.') + 1);
    jp.setBorder(<font color="#0000ff">new</font> TitledBorder(title));
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; ids.length; i++) {
      AbstractButton ab = <font color="#0000ff">new</font> JButton(<font color="#004488">"failed"</font>);
      <font color="#0000ff">try</font> {
        <font color="#009900">// Получение динамического метода конструктора,</font>
        <font color="#009900">// который принимает аргумент String:</font>
        Constructor ctor = bClass.getConstructor(
          <font color="#0000ff">new</font> Class[] { String.<font color="#0000ff">class</font> });
        <font color="#009900">// Создание нового объекта:</font>
        ab = (AbstractButton)ctor.newInstance(
          <font color="#0000ff">new</font> Object[]{ids[i]});
      } <font color="#0000ff">catch</font>(Exception ex) {
        System.err.println(<font color="#004488">"can't create "</font> + 
          bClass);
      }
      bg.add(ab);
      jp.add(ab);
    }
    <font color="#0000ff">return</font> jp;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(makeBPanel(JButton.<font color="#0000ff">class</font>, ids));
    cp.add(makeBPanel(JToggleButton.<font color="#0000ff">class</font>, ids));
    cp.add(makeBPanel(JCheckBox.<font color="#0000ff">class</font>, ids));
    cp.add(makeBPanel(JRadioButton.<font color="#0000ff">class</font>, ids));
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> ButtonGroups(), 500, 300);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Заголовок для бордюра берется из имени класса, от которого 
  отсекается вся информация о пути. <b>AbstractButton</b> инициализируется с помощью 
  <b>JButton</b>, которая имеет метку “Failed”, так что если вы игнорируете 
  сообщение исключения, вы видите проблему на экране. Метод <a name="Index1666"></a><a name="Index1667"></a><b>getConstructor(&nbsp;)</b> 
  производит объект <b>Constructor</b>, который принимает массив аргументов типов 
  в массиве <a name="Index1668"></a><a name="Index1669"></a><b>Class</b>, переданном 
  <b>getConstructor(&nbsp;)</b>. Затем, все, что вам нужно сделать, это вызвать 
  <a name="Index1670"></a><a name="Index1671"></a><b>newInstance(&nbsp;)</b>, 
  передав этот массив элементов <b>Object</b>, содержащий ваши реальные аргументы 
  — в этом случае просто <b>String</b> из массива <b>ids.</b></font></p>
<p><font face="Georgia">Здесь немного усложнен простой процесс. Для получения 
  поведения кнопок, вида “исключающее или”, вы создаете группу кнопок 
  и добавляете каждую кнопку, для которой вам нужно поведение в группе. Когда 
  вы запустите программу, вы увидите, что все кнопки, за исключением <b>JButton</b>, 
  показывают это поведение, вида “исключающее или”</font><font face="Georgia">.</font><a name="_Toc481064808"></a></p>
<a name="Heading443"></a><font face="Verdana">
<h3 align="left"> Иконки</h3>
</font> 
<p><font face="Georgia">Вы можете использовать <a name="Index1672"></a><b>Icon</b> 
  внутри <b>JLabel</b> или всего, что унаследовано от <b>AbstractButton</b> (включая 
  <a name="Index1673"></a><b>JButton</b>, <a name="Index1674"></a><b>JCheckBox</b>, 
  <a name="Index1675"></a><b>JRadioButton</b> и разного рода <a name="Index1676"></a><b>JMenuItem</b>). 
  Использование <b>Icon</b> с <b>JLabel</b> достаточно ясное (вы увидите пример 
  позже). Приведенный ниже пример исследует все дополнительные способы, которыми 
  вы можете использовать <b>Icon</b> с кнопками и их потомками.</font></p>
<p><font face="Georgia">Вы можете использовать любой <b>gif</b> файл, который 
  хотите, и один из них, использующийся в этом примере, является частью кода этой 
  книги, доступной на <i>www.BruceEckel.com</i>. Для открытия файла и получения 
  изображения, просто создайте <a name="Index1677"></a><b>ImageIcon</b> и передайте 
  ему имя файла. После этого вы можете использовать полученную <b>Icon</b> в вашей 
  программе.</font></p>
<p><font face="Georgia">Обратите внимание, что информация о пути жестко встроена 
  в этот пример; вы должны изменить путь на соответствующий положению файла изображения 
  на вашей машине.</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Faces.java</font>
<font color="#009900">// Поведение Icon в Jbuttons.</font>
<font color="#009900">// &lt;applet code=Faces</font>
<font color="#009900">//  width=250 height=100&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Faces <font color="#0000ff">extends</font> JApplet {
  <font color="#009900">// Следующая информация о пути необходима</font>
  <font color="#009900">// для запуска апплета непосредственно с диска:</font>
  <font color="#0000ff">static</font> String path = 
    <font color="#004488">"C:</font><font color="#004488">/aaa-TIJ2-distribution</font><font color="#004488">/code</font><font color="#004488">/c13</font><font color="#004488">/"</font>;
  <font color="#0000ff">static</font> Icon[] faces = {
    <font color="#0000ff">new</font> ImageIcon(path + <font color="#004488">"face0.gif"</font>),
    <font color="#0000ff">new</font> ImageIcon(path + <font color="#004488">"face1.gif"</font>),
    <font color="#0000ff">new</font> ImageIcon(path + <font color="#004488">"face2.gif"</font>),
    <font color="#0000ff">new</font> ImageIcon(path + <font color="#004488">"face3.gif"</font>),
    <font color="#0000ff">new</font> ImageIcon(path + <font color="#004488">"face4.gif"</font>),
  };
  JButton 
    jb = <font color="#0000ff">new</font> JButton(<font color="#004488">"JButton"</font>, faces[3]),
    jb2 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Disable"</font>);
  <font color="#0000ff">boolean</font> mad = <font color="#0000ff">false</font>;
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    jb.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        <font color="#0000ff">if</font>(mad) {
          jb.setIcon(faces[3]);
          mad = <font color="#0000ff">false</font>;
        } <font color="#0000ff">else</font> {
          jb.setIcon(faces[0]);
          mad = <font color="#0000ff">true</font>;
        }
        jb.setVerticalAlignment(JButton.TOP);
        jb.setHorizontalAlignment(JButton.LEFT);
      }
    });
    jb.setRolloverEnabled(<font color="#0000ff">true</font>);
    jb.setRolloverIcon(faces[1]);
    jb.setPressedIcon(faces[2]);
    jb.setDisabledIcon(faces[4]);
    jb.setToolTipText(<font color="#004488">"Yow!"</font>);
    cp.add(jb);
    jb2.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        <font color="#0000ff">if</font>(jb.isEnabled()) {
          jb.setEnabled(<font color="#0000ff">false</font>);
          jb2.setText(<font color="#004488">"Enable"</font>);
        } <font color="#0000ff">else</font> {
          jb.setEnabled(<font color="#0000ff">true</font>);
          jb2.setText(<font color="#004488">"Disable"</font>);
        }
      }
    });
    cp.add(jb2);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Faces(), 400, 200);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia"> <b>Icon</b> может быть использована во многих конструкторах, 
  но вы можете также использовать <a name="Index1678"></a><b>setIcon(&nbsp;)</b> 
  для добавления или изменения <b>Icon</b>. Этот пример также показывает как <b>JButton</b> 
  (или любая <b>AbstractButton</b>) может устанавливать различные сорта иконок, 
  которые появляются при возникновении каких-то событий с этой кнопкой: когда 
  она нажата, отключена или “<a name="Index1679"></a>перекрыта” (мышь 
  перемещается над ней без кликов). Вы увидите, что это дает кнопке прекрасную 
  анимацию</font><font face="Georgia">.</font><a name="_Toc481064809"></a></p>
<a name="Heading444"></a><font face="Verdana">
<h3 align="left"> Инструмент подсказки<a name="Index1680"></a></h3>
</font> 
<p><font face="Georgia">Предыдущий пример добавляет “инструмент подсказки” 
  к кнопке. Почти все классы, которые вы будите использовать для создания интерфейса 
  пользователя, наследуются от <a name="Index1681"></a><b>JComponent</b>, который 
  содержит метод, называемый <b>setToolTipText(String)</b>. Поэтому, фактически, 
  для всего, что вы помещаете на форму, все, что вам нужно сделать, это сказать 
  (для объекта <b>jc</b> любого класса, унаследованного от <b>JComponent</b>):</font></p>
<blockquote><font size="+1">
  <pre>jc.setToolTipText(<font color="#004488">"My tip"</font>);</pre>
  </font></blockquote>
<p><font face="Georgia">и когда мышь задержится над этим <b>JComponent</b> на 
  предопределенное время, возле мыши всплывет крошечный прямоугольник, содержащий 
  ваш текст.</font><a name="_Toc481064810"></a></p>
<a name="Heading445"></a><font face="Verdana">
<h3 align="left"> Текстовые поля<a name="Index1683"></a></h3>
</font> 
<p><font face="Georgia">Этот пример показывает дополнительные возможности, имеющиеся 
  в <b>JTextField</b>:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:TextFields.java</font>
<font color="#009900">// Текстовые поля и события Java.</font>
<font color="#009900">// &lt;applet code=TextFields width=375</font>
<font color="#009900">// height=125&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> javax.swing.event.*;
<font color="#0000ff">import</font> javax.swing.text.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> TextFields <font color="#0000ff">extends</font> JApplet {
  JButton
    b1 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Get Text"</font>),
    b2 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Set Text"</font>);
  JTextField
    t1 = <font color="#0000ff">new</font> JTextField(30),
    t2 = <font color="#0000ff">new</font> JTextField(30),
    t3 = <font color="#0000ff">new</font> JTextField(30);
  String s = <font color="#0000ff">new</font> String();
  UpperCaseDocument
    ucd = <font color="#0000ff">new</font> UpperCaseDocument();
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    t1.setDocument(ucd);
    ucd.addDocumentListener(<font color="#0000ff">new</font> T1());
    b1.addActionListener(<font color="#0000ff">new</font> B1());
    b2.addActionListener(<font color="#0000ff">new</font> B2());
    DocumentListener dl = <font color="#0000ff">new</font> T1();
    t1.addActionListener(<font color="#0000ff">new</font> T1A());
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(b1);
    cp.add(b2);
    cp.add(t1);
    cp.add(t2);
    cp.add(t3);
  }
  <font color="#0000ff">class</font> T1 <font color="#0000ff">implements</font> DocumentListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> changedUpdate(DocumentEvent e){}
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> insertUpdate(DocumentEvent e){
      t2.setText(t1.getText());
      t3.setText(<font color="#004488">"Text: "</font>+ t1.getText());
    }
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> removeUpdate(DocumentEvent e){
      t2.setText(t1.getText());
    }
  }
  <font color="#0000ff">class</font> T1A <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">private</font> <font color="#0000ff">int</font> count = 0;
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t3.setText(<font color="#004488">"t1 Action Event "</font> + count++);
    }
  }
  <font color="#0000ff">class</font> B1 <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      <font color="#0000ff">if</font>(t1.getSelectedText() == <font color="#0000ff">null</font>)
        s = t1.getText();
      <font color="#0000ff">else</font>
        s = t1.getSelectedText();
      t1.setEditable(<font color="#0000ff">true</font>);
    }
  }
  <font color="#0000ff">class</font> B2 <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      ucd.setUpperCase(<font color="#0000ff">false</font>);
      t1.setText(<font color="#004488">"Inserted by Button 2: "</font> + s);
      ucd.setUpperCase(<font color="#0000ff">true</font>);
      t1.setEditable(<font color="#0000ff">false</font>);
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> TextFields(), 375, 125);
  }
}

<font color="#0000ff">class</font> UpperCaseDocument <font color="#0000ff">extends</font> PlainDocument {
  <font color="#0000ff">boolean</font> upperCase = <font color="#0000ff">true</font>;
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setUpperCase(<font color="#0000ff">boolean</font> flag) {
    upperCase = flag;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> insertString(<font color="#0000ff">int</font> offset, 
    String string, AttributeSet attributeSet)
    <font color="#0000ff">throws</font> BadLocationException {
      <font color="#0000ff">if</font>(upperCase)
        string = string.toUpperCase();
      <font color="#0000ff">super</font>.insertString(offset, 
        string, attributeSet);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia"> <b>JTextField t3</b> включено как место для отчета при 
  возбуждении слушателя действия <b>JTextField</b> <b>t1</b>. Вы увидите, что 
  слушатель действия для <b>JTextField</b> возбуждается, только когда вы нажмете 
  кнопку “enter”.</font></p>
<p><font face="Georgia"><b> JTextField t1</b> имеет несколько присоединенных слушателей. 
  Слушатель <b>T1</b> - это <b>DocumentListener</b>, который отвечает на любые 
  изменения в “документе” (в этом случае - это содержимое <b>JTextField</b>). 
  Он автоматически копирует весь текст из <b>t1</b> в <b>t2</b>. Кроме того, документ 
  в <b>t1</b> устанавливается на класс, унаследованный от <b>PlainDocument</b>, 
  называемый <b>UpperCaseDocument</b>, который переводит все символы в верхний 
  регистр. Он автоматически определяет пробелы и выполняет удаление, регулирование 
  каретки и обработку всего, как вы можете ожидать</font><font face="Georgia">.</font><a name="_Toc481064811"></a></p>
<div align="left"></div>
<a name="Heading446"></a><font face="Verdana">
<h3 align="left"> Бордюры</h3>
</font> 
<p><font face="Georgia"><b>JComponent</b> содержит метод, называемый <a name="Index1684"></a><b>setBorder(&nbsp;)</b>, 
  который позволяет вам поместить разные интересные бордюры на любой видимый компонент. 
  Следующий пример демонстрирует несколько различных поддерживаемых бордюров, 
  используя метод, называемый <b>showBorder(&nbsp;)</b>, который создает <b>JPanel</b> 
  и помещает бордюр в каждом случае. Также он использует RTTI для нахождения имени 
  бордюра, который вы используете (отсекая информацию о пути), затем помещает 
  это имя в <a name="Index1685"></a><b>JLabel</b>, находящуюся в середине панели</font><font face="Georgia">:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Borders.java</font>
<font color="#009900">// Различные бордюры Swing.</font>
<font color="#009900">// &lt;applet code=Borders</font>
<font color="#009900">//  width=500 height=300&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> javax.swing.border.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Borders <font color="#0000ff">extends</font> JApplet {
  <font color="#0000ff">static</font> JPanel showBorder(Border b) {
    JPanel jp = <font color="#0000ff">new</font> JPanel();
    jp.setLayout(<font color="#0000ff">new</font> BorderLayout());
    String nm = b.getClass().toString();
    nm = nm.substring(nm.lastIndexOf('.') + 1);
    jp.add(<font color="#0000ff">new</font> JLabel(nm, JLabel.CENTER), 
      BorderLayout.CENTER);
    jp.setBorder(b);
    <font color="#0000ff">return</font> jp;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.setLayout(<font color="#0000ff">new</font> GridLayout(2,4));
    cp.add(showBorder(<font color="#0000ff">new</font> TitledBorder(<font color="#004488">"Title"</font>)));
    cp.add(showBorder(<font color="#0000ff">new</font> EtchedBorder()));
    cp.add(showBorder(<font color="#0000ff">new</font> LineBorder(Color.blue)));
    cp.add(showBorder(
      <font color="#0000ff">new</font> MatteBorder(5,5,30,30,Color.green)));
    cp.add(showBorder(
      <font color="#0000ff">new</font> BevelBorder(BevelBorder.RAISED)));
    cp.add(showBorder(
      <font color="#0000ff">new</font> SoftBevelBorder(BevelBorder.LOWERED)));
    cp.add(showBorder(<font color="#0000ff">new</font> CompoundBorder(
      <font color="#0000ff">new</font> EtchedBorder(),
      <font color="#0000ff">new</font> LineBorder(Color.red))));
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Borders(), 500, 300);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Вы также можете создать свой собственный бордюр и поместить 
  его внутри кнопок, меток и т.п. — всего, что унаследовано от </font><font face="Georgia"><b>JComponent</b>.</font><a name="_Toc481064812"></a></p>
<a name="Heading447"></a><font face="Verdana">
<h3 align="left"> Панели скроллирования<a name="Index1686"></a></h3>
</font> 
<p><font face="Georgia">Большую часть времени вам будет нужно позволять <b>JScrollPane</b> 
  делать его работу, но вы можете также управлять, какая полоса прокрутки доступна 
  — вертикальная, горизонтальная, обе или ни одной</font><font face="Georgia">:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:JScrollPanes.java</font>
<font color="#009900">//Управление полосами прокрутки в JScrollPane.</font>
<font color="#009900">// &lt;applet code=JScrollPanes width=300 height=725&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> javax.swing.border.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> JScrollPanes <font color="#0000ff">extends</font> JApplet {
  JButton 
    b1 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Text Area 1"</font>),
    b2 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Text Area 2"</font>),
    b3 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Replace Text"</font>),
    b4 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Insert Text"</font>);
  JTextArea 
    t1 = <font color="#0000ff">new</font> JTextArea(<font color="#004488">"t1"</font>, 1, 20),
    t2 = <font color="#0000ff">new</font> JTextArea(<font color="#004488">"t2"</font>, 4, 20),
    t3 = <font color="#0000ff">new</font> JTextArea(<font color="#004488">"t3"</font>, 1, 20),
    t4 = <font color="#0000ff">new</font> JTextArea(<font color="#004488">"t4"</font>, 10, 10),
    t5 = <font color="#0000ff">new</font> JTextArea(<font color="#004488">"t5"</font>, 4, 20),
    t6 = <font color="#0000ff">new</font> JTextArea(<font color="#004488">"t6"</font>, 10, 10);
  JScrollPane 
    sp3 = <font color="#0000ff">new</font> JScrollPane(t3,
      JScrollPane.VERTICAL_SCROLLBAR_NEVER,
      JScrollPane.HORIZONTAL_SCROLLBAR_NEVER),
    sp4 = <font color="#0000ff">new</font> JScrollPane(t4,
      JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
      JScrollPane.HORIZONTAL_SCROLLBAR_NEVER),
    sp5 = <font color="#0000ff">new</font> JScrollPane(t5,
      JScrollPane.VERTICAL_SCROLLBAR_NEVER,
      JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS),
    sp6 = <font color="#0000ff">new</font> JScrollPane(t6,
      JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
      JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
  <font color="#0000ff">class</font> B1L <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t5.append(t1.getText() + <font color="#004488">"\n"</font>);
    }
  }
  <font color="#0000ff">class</font> B2L <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t2.setText(<font color="#004488">"Inserted by Button 2"</font>);
      t2.append(<font color="#004488">": "</font> + t1.getText());
      t5.append(t2.getText() + <font color="#004488">"\n"</font>);
    }
  }
  <font color="#0000ff">class</font> B3L <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      String s = <font color="#004488">" Replacement "</font>;
      t2.replaceRange(s, 3, 3 + s.length());
    }
  }
  <font color="#0000ff">class</font> B4L <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t2.insert(<font color="#004488">" Inserted "</font>, 10);
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    <font color="#009900">// Создание бордюра для компонент:</font>
    Border brd = BorderFactory.createMatteBorder(
      1, 1, 1, 1, Color.black);
    t1.setBorder(brd);
    t2.setBorder(brd);
    sp3.setBorder(brd);
    sp4.setBorder(brd);
    sp5.setBorder(brd);
    sp6.setBorder(brd);
    <font color="#009900">// Инициализация слушателей и добавление компонент:</font>
    b1.addActionListener(<font color="#0000ff">new</font> B1L());
    cp.add(b1);
    cp.add(t1);
    b2.addActionListener(<font color="#0000ff">new</font> B2L());
    cp.add(b2);
    cp.add(t2);
    b3.addActionListener(<font color="#0000ff">new</font> B3L());
    cp.add(b3);
    b4.addActionListener(<font color="#0000ff">new</font> B4L());
    cp.add(b4);
    cp.add(sp3); 
    cp.add(sp4); 
    cp.add(sp5);
    cp.add(sp6);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> JScrollPanes(), 300, 725);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">При использовании различных аргументов, в конструкторе 
  <b>JScrollPane</b> происходит управление доступностью полос прокрутки. Этот 
  пример также немного красивее при использовании бордюров.</font><a name="_Toc481064813"></a></p>
<a name="Heading448"></a> <font face="Verdana">
<h3 align="left">Мини редактор<a name="Index1687"></a></h3>
</font> 
<p><font face="Georgia">Управляющий элемент <a name="Index1688"></a><b>JTextPane</b> 
  великолепно подходит для редактирования, без больших усилий. Следующий пример 
  делает очень простое использование этого, игнорирую большую часть функциональности 
  класса</font><font face="Georgia">:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:TextPane.java</font>
<font color="#009900">// JTextPane - это маленький редактор.</font>
<font color="#009900">// &lt;applet code=TextPane width=475 height=425&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;
<font color="#0000ff">import</font> com.bruceeckel.util.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> TextPane <font color="#0000ff">extends</font> JApplet {
  JButton b = <font color="#0000ff">new</font> JButton(<font color="#004488">"Add Text"</font>);
  JTextPane tp = <font color="#0000ff">new</font> JTextPane();
  <font color="#0000ff">static</font> Generator sg = 
    <font color="#0000ff">new</font> Arrays2.RandStringGenerator(7);  
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    b.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 1; i &lt; 10; i++)
          tp.setText(tp.getText() + 
            sg.next() + <font color="#004488">"\n"</font>);
      }
    });
    Container cp = getContentPane();
    cp.add(<font color="#0000ff">new</font> JScrollPane(tp));
    cp.add(BorderLayout.SOUTH, b);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> TextPane(), 475, 425);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Кнопка просто добавляет случайно сгенерированный текст. 
  Смысл <b>JTextPane</b> состоит в том, что она позволяет редактировать текст 
  на месте, так что вы увидите и не нужен метод <b>append(&nbsp;)</b>. В этом 
  случае (вероятно, недостаточное использование возможностей <b>JTextPane</b>), 
  текст должен захватываться, изменятся и помещаться назад в панель, используя 
  <b>setText(&nbsp;)</b>.</font></p>
<p><font face="Georgia">Как упоминалось ранее, апплет по умолчанию использует 
  компоновку <b>BorderLayout</b>. Если вы добавите что-то в панель без указания 
  детализации, оно просто заполнит центр панели до краев. Однако если вы укажите 
  один из окружающих регионов (NORTH, SOUTH, EAST или WEST), как сделано здесь, 
  компонент поместит себя в этот регион — в этом случае кнопка вмонтирована 
  внизу экрана.</font></p>
<p><font face="Georgia">Обратите внимание на встроенные особенности <b>JTextPane</b>, 
  такие как автоматическое разбиение строк. Есть много других особенностей, которые 
  вы можете просмотреть, используя документацию JDK</font><font face="Georgia">.</font><a name="_Toc481064814"></a></p>
<a name="Heading449"></a><font face="Verdana">
<h3 align="left"> CheckBox-элементы</h3>
</font> 
<p><font face="Georgia"> <a name="Index1689"></a>CheckBox-элемент обеспечивает 
  способ создания единственного выбора включения/выключения; он состоит из небольшого 
  прямоугольника и метки. Прямоугольник обычно содержит небольшой “x” 
  (или какой-то другой индикатор того, что он установлен) или остается пустым, 
  в зависимости от того, был ли он выбран.</font></p>
<p><font face="Georgia">Обычно вы будете создавать <a name="Index1690"></a><b>JCheckBox</b>, 
  используя конструктор, который получает метку в качестве аргумента. Вы можете 
  установить и получить состояние и установить метку, если хотите прочесть или 
  изменить ее после создания <b>JCheckBox</b>.</font></p>
<p><font face="Georgia">Независимо от того, где <b>JCheckBox</b> установлен или 
  создан, происходят события, которые вы можете собирать тем же способом, что 
  и для кнопки, используя <b>ActionListener</b>. Следующий пример использует <b>JTextArea</b>, 
  чтобы убедится, что на всех checkBox-элементах произведен щелчок мышкой</font><font face="Georgia">:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:CheckBoxes.java</font>
<font color="#009900">// Использование JCheckBoxes.</font>
<font color="#009900">// &lt;applet code=CheckBoxes width=200 height=200&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> CheckBoxes <font color="#0000ff">extends</font> JApplet {
  JTextArea t = <font color="#0000ff">new</font> JTextArea(6, 15);
  JCheckBox 
    cb1 = <font color="#0000ff">new</font> JCheckBox(<font color="#004488">"Check Box 1"</font>),
    cb2 = <font color="#0000ff">new</font> JCheckBox(<font color="#004488">"Check Box 2"</font>),
    cb3 = <font color="#0000ff">new</font> JCheckBox(<font color="#004488">"Check Box 3"</font>);
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    cb1.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        trace(<font color="#004488">"1"</font>, cb1);
      }
    });
    cb2.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        trace(<font color="#004488">"2"</font>, cb2);
      }
    });
    cb3.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        trace(<font color="#004488">"3"</font>, cb3);
      }
    });
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(<font color="#0000ff">new</font> JScrollPane(t));
    cp.add(cb1); 
    cp.add(cb2); 
    cp.add(cb3);
  }
  <font color="#0000ff">void</font> trace(String b, JCheckBox cb) {
    <font color="#0000ff">if</font>(cb.isSelected())
      t.append(<font color="#004488">"Box "</font> + b + <font color="#004488">" Set\n"</font>);
    <font color="#0000ff">else</font>
      t.append(<font color="#004488">"Box "</font> + b + <font color="#004488">" Cleared\n"</font>);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> CheckBoxes(), 200, 200);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Метод <b>trace(&nbsp;)</b> посылает имя выделенного <b>JCheckBox</b> 
  и его текущего состояния в <b>JTextArea</b>, используя <b>append(&nbsp;)</b>, 
  так что вы увидите совокупный список checkbox-элементов и их состояния.</font><a name="_Toc375545453"></a><a name="_Toc481064815"></a></p>
<a name="Heading450"></a><font face="Verdana">
<h3 align="left"> Радио кнопки</h3>
</font> 
<p><font face="Georgia">Концепция <a name="Index1691"></a><a name="Index1692"></a>радио 
  кнопок в программировании GUI пришла из до электронного радио для автомобиля 
  с механическими кнопками: когда вы нажимаете одну из них, все остальные, которые 
  были нажаты, отжимаются. Таким образом, это позволяет вам навязывать единственный 
  выбор из многих.</font></p>
<p><font face="Georgia">Все, что вам нужно сделать, это установить ассоциированную 
  группу <a name="Index1693"></a><b>JRadioButton</b>, добавив их в <a name="Index1694"></a><b>ButtonGroup</b> 
  (вы можете иметь любое число <b>ButtonGroup</b> на форме). Одна из кнопок может 
  быть (не обязательно) выбрана в стартовом положении и для нее устанавливается 
  <b>true</b> (используется второй аргумент конструктора). Если вы попробуете 
  установить более чем одну радио кнопку в <b>true</b>, только последняя установка 
  сохранит значение <b>true</b>.</font></p>
<p><font face="Georgia">Здесь приведен пример использования радио кнопок. Обратите 
  внимание, что вы захватываете события радио кнопок, как и все остальные:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:RadioButtons.java</font>
<font color="#009900">// Использование JRadioButton.</font>
<font color="#009900">// &lt;applet code=RadioButtons </font>
<font color="#009900">// width=200 height=100&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> RadioButtons <font color="#0000ff">extends</font> JApplet {
  JTextField t = <font color="#0000ff">new</font> JTextField(15);
  ButtonGroup g = <font color="#0000ff">new</font> ButtonGroup();
  JRadioButton 
    rb1 = <font color="#0000ff">new</font> JRadioButton(<font color="#004488">"one"</font>, <font color="#0000ff">false</font>),
    rb2 = <font color="#0000ff">new</font> JRadioButton(<font color="#004488">"two"</font>, <font color="#0000ff">false</font>),
    rb3 = <font color="#0000ff">new</font> JRadioButton(<font color="#004488">"three"</font>, <font color="#0000ff">false</font>);
  ActionListener al = <font color="#0000ff">new</font> ActionListener() {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t.setText(<font color="#004488">"Radio button "</font> + 
        ((JRadioButton)e.getSource()).getText());
    }
  };
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    rb1.addActionListener(al);
    rb2.addActionListener(al);
    rb3.addActionListener(al);
    g.add(rb1); g.add(rb2); g.add(rb3);
    t.setEditable(<font color="#0000ff">false</font>);
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(t); 
    cp.add(rb1); 
    cp.add(rb2); 
    cp.add(rb3); 
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> RadioButtons(), 200, 100);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Для отображения состояния используется текстовое поле. 
  Это поле устанавливается, как не редактируемое, потому что оно используется 
  только для отображения данных, а не для сбора их. Таким образом - это альтернатива 
  использованию <b>JLabel</b>.</font><a name="AAAIndexingCurrentPoint"></a><a name="_Toc375545454"></a><a name="_Toc481064816"></a></p>
<a name="Heading451"></a><font face="Verdana">
<h3 align="left"> Комбинированные поля (выпадающие списки)</h3>
</font> 
<p><font face="Georgia">Как и группа радио кнопок, <a name="Index1695"></a><a name="Index1696"></a>выпадающий 
  список - это способ заставить пользователя выбрать только один элемент из группы 
  возможных. Однако это более компактный способ выполнить это и он более легкий 
  с точки зрения смены элементов списка, который не удивит пользователя. (Вы можете 
  изменить радио кнопки динамически, но при этом произойдут визуальные вибрации).</font></p>
<p><a name="Index1697"></a><a name="Index1698"></a><font face="Georgia"><b>JComboBox</b> 
  из Java отличается от аналогичного элемента в Windows, который позволяет вам 
  выбрать из списка <i>или</i> напечатать в нем свое собственное значение. С помощью 
  <b>JComboBox</b> вы выбираете один и только один элемент из списка. В следующем 
  примере <b>JComboBox</b> в начале заполняется некоторым числом элементов, а 
  затем добавляются новые элементы при нажатии кнопки.</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:ComboBoxes.java</font>
<font color="#009900">// Использование выпадающих списков.</font>
<font color="#009900">// &lt;applet code=ComboBoxes</font>
<font color="#009900">// width=200 height=100&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ComboBoxes <font color="#0000ff">extends</font> JApplet {
  String[] description = { <font color="#004488">"Ebullient"</font>, <font color="#004488">"Obtuse"</font>,
    <font color="#004488">"Recalcitrant"</font>, <font color="#004488">"Brilliant"</font>, <font color="#004488">"Somnescent"</font>,
    <font color="#004488">"Timorous"</font>, <font color="#004488">"Florid"</font>, <font color="#004488">"Putrescent"</font> };
  JTextField t = <font color="#0000ff">new</font> JTextField(15);
  JComboBox c = <font color="#0000ff">new</font> JComboBox();
  JButton b = <font color="#0000ff">new</font> JButton(<font color="#004488">"Add items"</font>);
  <font color="#0000ff">int</font> count = 0;
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 4; i++)
      c.addItem(description[count++]);
    t.setEditable(<font color="#0000ff">false</font>);
    b.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        <font color="#0000ff">if</font>(count &lt; description.length)
          c.addItem(description[count++]);
      }
    });
    c.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        t.setText(<font color="#004488">"index: "</font>+ c.getSelectedIndex()
          + <font color="#004488">"   "</font> + ((JComboBox)e.getSource())
          .getSelectedItem());
      }
    });
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(t);
    cp.add(c);
    cp.add(b);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> ComboBoxes(), 200, 100);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia"><b> JTextField</b> отображает “выбранный индекс”, 
  являющийся последовательностью номеров элементов, являющихся выбранными, точно 
  так же как и метки для радио кнопок.</font><a name="_Toc375545455"></a><a name="_Toc481064817"></a></p>
<a name="Heading452"></a><font face="Verdana">
<h3 align="left"> Списки<a name="Index1699"></a><a name="Index1700"></a></h3>
</font> 
<p><font face="Georgia">Список значительно отличается от <b>JComboBox </b>и не 
  только по внешнему виду. В то время как <b>JComboBox</b> выпадает вниз при активации, 
  <a name="Index1701"></a><b>JList</b> занимает определенное фиксированное число 
  строк на экране все время и не изменяется. Если вы хотите видеть элементы в 
  списке, вы просто вызываете <a name="Index1702"></a><b>getSelectedValues(&nbsp;)</b>, 
  который производи массив <b>String</b> из выбранных элементов.</font></p>
<p><font face="Georgia"> <b>JList</b> позволяет множественный выбор: если вы используете 
  кнопку CTRL при щелчке мышью на более чем одном элементе (удерживайте кнопку 
  “control” при выполнении дополнительных щелчков мышью) начальный 
  элемент остается подсвеченным, и вы можете выбрать столько элементов, сколько 
  хотите. Если вы выбрали элемент, а затем щелкнули на другом, удерживая кнопку 
  SHIFT, выберутся все элементы в пространстве между этими двумя. Для удаления 
  элемента из группы вы можете выполнить щелчок с нажатой кнопкой CTRL.</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:List.java</font>
<font color="#009900">// &lt;applet code=List width=250</font>
<font color="#009900">// height=375&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> javax.swing.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> javax.swing.border.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> List <font color="#0000ff">extends</font> JApplet {
  String[] flavors = { <font color="#004488">"Chocolate"</font>, <font color="#004488">"Strawberry"</font>,
    <font color="#004488">"Vanilla Fudge Swirl"</font>, <font color="#004488">"Mint Chip"</font>,
    <font color="#004488">"Mocha Almond Fudge"</font>, <font color="#004488">"Rum Raisin"</font>,
    <font color="#004488">"Praline Cream"</font>, <font color="#004488">"Mud Pie"</font> };
  DefaultListModel lItems=<font color="#0000ff">new</font> DefaultListModel();
  JList lst = <font color="#0000ff">new</font> JList(lItems);
  JTextArea t = <font color="#0000ff">new</font> JTextArea(flavors.length,20);
  JButton b = <font color="#0000ff">new</font> JButton(<font color="#004488">"Add Item"</font>);
  ActionListener bl = <font color="#0000ff">new</font> ActionListener() {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      <font color="#0000ff">if</font>(count &lt; flavors.length) {
        lItems.add(0, flavors[count++]);
      } <font color="#0000ff">else</font> {
        <font color="#009900">// Отключено, так как не осталось больше</font>
        <font color="#009900">// вкусов для добавления в список</font>
        b.setEnabled(<font color="#0000ff">false</font>);
      }
    }
  };
  ListSelectionListener ll =
    <font color="#0000ff">new</font> ListSelectionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> valueChanged(
        ListSelectionEvent e) {
          t.setText(<font color="#004488">""</font>);
          Object[] items=lst.getSelectedValues();
          <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; items.length; i++)
            t.append(items[i] + <font color="#004488">"\n"</font>);
        }
    };
  <font color="#0000ff">int</font> count = 0;
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    t.setEditable(<font color="#0000ff">false</font>);
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    <font color="#009900">// Создание бордюра для компонента:</font>
    Border brd = BorderFactory.createMatteBorder(
      1, 1, 2, 2, Color.black);
    lst.setBorder(brd);
    t.setBorder(brd);
    <font color="#009900">// Добавление первых четырех элементов в список</font>
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; 4; i++)
      lItems.addElement(flavors[count++]);
    <font color="#009900">// Добавление элементов в Панель Содержания для отображения</font>
    cp.add(t);
    cp.add(lst);
    cp.add(b);
    <font color="#009900">// Регистрация слушателей событий</font>
    lst.addListSelectionListener(ll);
    b.addActionListener(bl);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> List(), 250, 375);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Когда вы нажимаете кнопку, происходит добавление элементов 
  в верх списка (потому что в <b>addItem(&nbsp;)</b> второй аргумент равен 0).</font></p>
<p><font face="Georgia">Вы можете видеть, что бордюр также добавляется в списки.</font></p>
<p><font face="Georgia">Если вы хотите поместить массив <b>String</b> в <b>JList</b>, 
  есть достаточно простое решение: вы передаете массив в конструктор <b>JList</b>, 
  а он строит список автоматически. Есть только одно объяснение для использования 
  “модели списка” в приведенном выше примере - это то, что список 
  может быть изменен во время выполнения программы.</font></p>
<p><font face="Georgia"><b>JList</b> не поддерживает напрямую автоматическое скроллирование. 
  Конечно, все, что вам нужно сделать, это "обернуть" <b>JList</b> в 
  <a name="Index1703"></a><b>JScrollPane</b>, а все остальной автоматически будет 
  сделано за вас.</font><a name="_Toc375545457"></a><a name="_Toc481064818"></a></p>
<div align="left"></div>
<a name="Heading453"></a><font face="Verdana">
<h3 align="left"> Закладки<a name="Index1704"></a><a name="Index1705"></a><a name="Index1706"></a></h3>
</font> 
<div align="left">
  <p><font face="Georgia"> <b>JTabbedPane</b> позволяет создать вам “диалог 
    с закладками”, который имеет закладки наподобие файлов, расположенные 
    с одной стороны, и позволяющий вам нажимать на закладку для отображения различных 
    диалогов.</font></p>
</div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:TabbedPane1.java</font>
<font color="#009900">// Демонстрация Tabbed Pane.</font>
<font color="#009900">// &lt;applet code=TabbedPane1 </font>
<font color="#009900">// width=350 height=200&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> javax.swing.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> TabbedPane1 <font color="#0000ff">extends</font> JApplet {
  String[] flavors = { <font color="#004488">"Chocolate"</font>, <font color="#004488">"Strawberry"</font>,
    <font color="#004488">"Vanilla Fudge Swirl"</font>, <font color="#004488">"Mint Chip"</font>, 
    <font color="#004488">"Mocha Almond Fudge"</font>, <font color="#004488">"Rum Raisin"</font>, 
    <font color="#004488">"Praline Cream"</font>, <font color="#004488">"Mud Pie"</font> };
  JTabbedPane tabs = <font color="#0000ff">new</font> JTabbedPane();
  JTextField txt = <font color="#0000ff">new</font> JTextField(20);
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; flavors.length; i++)
      tabs.addTab(flavors[i], 
        <font color="#0000ff">new</font> JButton(<font color="#004488">"Tabbed pane "</font> + i));
    tabs.addChangeListener(<font color="#0000ff">new</font> ChangeListener(){
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> stateChanged(ChangeEvent e) {
        txt.setText(<font color="#004488">"Tab selected: "</font> + 
          tabs.getSelectedIndex());
      }
    });
    Container cp = getContentPane();
    cp.add(BorderLayout.SOUTH, txt);
    cp.add(tabs);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> TabbedPane1(), 350, 200);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia"> Java использование механизма “панели с закладками” 
  достаточно важно, поскольку в программировании апплетов использование всплывающих 
  диалогов обескураживает автоматическим добавлением небольшого предупреждения 
  к любому диалогу, который всплывает из апплета.</font></p>
<p><font face="Georgia">Когда вы запустите программу, вы увидите, что <b>JTabbedPane</b> 
  автоматически размещает закладки, если их слишком много для размещения в один 
  ряд. Вы можете заметить это при изменении окна после запуска программы и командной 
  строки консоли</font><font face="Georgia">.</font><a name="_Toc481064819"></a></p>
<div align="left"></div>
<a name="Heading454"></a><font face="Verdana">
<h3 align="left"> Окна сообщений</h3>
</font> 
<p><font face="Georgia">Оконная среда часто содержит стандартный набор <a name="Index1707"></a>окон 
  сообщений, которые позволяют вам быстро посылать сообщения пользователю или 
  получать информацию от пользователя. В Swing эти окна сообщений содержаться 
  в <a name="Index1708"></a><b>JOptionPane</b>. Вы имеете много различных возможностей 
  (некоторые из них достаточно изощренные), но, наверное, одна из наиболее часто 
  использующихся, это окно сообщения и диалог подтверждения, вызывающийся при 
  использовании <b>JOptionPane.showMessageDialog(&nbsp;)</b> и <b>JOptionPane. 
  showConfirmDialog(&nbsp;)</b>. Следующий пример показывает подмножество окон 
  сообщения, поддерживаемых </font><font face="Georgia"> <b>JOptionPane</b>:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:MessageBoxes.java</font>
<font color="#009900">// Демонстрация JoptionPane.</font>
<font color="#009900">// &lt;applet code=MessageBoxes </font>
<font color="#009900">// width=200 height=150&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> MessageBoxes <font color="#0000ff">extends</font> JApplet {
  JButton[] b = { <font color="#0000ff">new</font> JButton(<font color="#004488">"Alert"</font>), 
    <font color="#0000ff">new</font> JButton(<font color="#004488">"Yes</font><font color="#004488">/No"</font>), <font color="#0000ff">new</font> JButton(<font color="#004488">"Color"</font>),
    <font color="#0000ff">new</font> JButton(<font color="#004488">"Input"</font>), <font color="#0000ff">new</font> JButton(<font color="#004488">"3 Vals"</font>)
  };
  JTextField txt = <font color="#0000ff">new</font> JTextField(15);
  ActionListener al = <font color="#0000ff">new</font> ActionListener() {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
      String id = 
        ((JButton)e.getSource()).getText();
      <font color="#0000ff">if</font>(id.equals(<font color="#004488">"Alert"</font>))
        JOptionPane.showMessageDialog(<font color="#0000ff">null</font>, 
          <font color="#004488">"There's a bug on you!"</font>, <font color="#004488">"Hey!"</font>, 
          JOptionPane.ERROR_MESSAGE);
      <font color="#0000ff">else</font> <font color="#0000ff">if</font>(id.equals(<font color="#004488">"Yes</font><font color="#004488">/No"</font>))
        JOptionPane.showConfirmDialog(<font color="#0000ff">null</font>, 
          <font color="#004488">"or no"</font>, <font color="#004488">"choose yes"</font>, 
          JOptionPane.YES_NO_OPTION);
      <font color="#0000ff">else</font> <font color="#0000ff">if</font>(id.equals(<font color="#004488">"Color"</font>)) {
        Object[] options = { <font color="#004488">"Red"</font>, <font color="#004488">"Green"</font> };
        <font color="#0000ff">int</font> sel = JOptionPane.showOptionDialog(
          <font color="#0000ff">null</font>, <font color="#004488">"Choose a Color!"</font>, <font color="#004488">"Warning"</font>, 
          JOptionPane.DEFAULT_OPTION, 
          JOptionPane.WARNING_MESSAGE, <font color="#0000ff">null</font>, 
          options, options[0]);
          <font color="#0000ff">if</font>(sel != JOptionPane.CLOSED_OPTION)
            txt.setText(
              <font color="#004488">"Color Selected: "</font> + options[sel]);
      } <font color="#0000ff">else</font> <font color="#0000ff">if</font>(id.equals(<font color="#004488">"Input"</font>)) {
        String val = JOptionPane.showInputDialog(
            <font color="#004488">"How many fingers do you see?"</font>); 
        txt.setText(val);
      } <font color="#0000ff">else</font> <font color="#0000ff">if</font>(id.equals(<font color="#004488">"3 Vals"</font>)) {
        Object[] selections = {
          <font color="#004488">"First"</font>, <font color="#004488">"Second"</font>, <font color="#004488">"Third"</font> };
        Object val = JOptionPane.showInputDialog(
          <font color="#0000ff">null</font>, <font color="#004488">"Choose one"</font>, <font color="#004488">"Input"</font>,
          JOptionPane.INFORMATION_MESSAGE, 
          <font color="#0000ff">null</font>, selections, selections[0]);
        <font color="#0000ff">if</font>(val != <font color="#0000ff">null</font>)
          txt.setText(
            val.toString());
      }
    }
  };
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; b.length; i++) {
      b[i].addActionListener(al);
      cp.add(b[i]);
    }
    cp.add(txt);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> MessageBoxes(), 200, 200);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Чтобы быть способным написать единственный <b>ActionListener</b>, 
  я использую несколько рискованный подход проверки <b>String</b> метки кнопки. 
  Проблема при этом в том, что легко получить слегка искаженную кнопку, обычно 
  с большой буквы, и эта ошибка может быть трудна для обнаружения.</font></p>
<p><font face="Georgia">Обратите внимание, что <b>showOptionDialog(&nbsp;)</b> 
  и <b>showInputDialog(&nbsp;)</b> обеспечивают возврат объекта, который содержит 
  введенное пользователем значение</font><font face="Georgia">.</font><a name="_Toc481064820"></a></p>
<div align="left"></div>
<a name="Heading455"></a><font face="Verdana">
<h3 align="left"> Меню<a name="Index1709"></a><a name="Index1710"></a><a name="Index1711"></a><a name="Index1712"></a><a name="Index1713"></a><a name="Index1714"></a><a name="Index1715"></a></h3>
</font> 
<p><font face="Georgia">Каждый компонент способен содержать меню, включая <b>JApplet</b>, 
  <b>JFrame</b>, <b>JDialog</b> и их потомков, имеющих метод <b>setJMenuBar(&nbsp;)</b>, 
  который принимает <b>JMenuBar</b> (вы можете иметь только один <b>JMenuBar</b> 
  для определенного компонента). Вы добавляете <b>JMenu</b> в <b>JMenuBar</b>, 
  и <b>JMenuItem</b> в <b>JMenu</b>. Каждый <b>JMenuItem</b> может иметь присоединенный 
  к нему <b>ActionListener</b> для сигнализации, что элемент меню выбран.</font></p>
<p><font face="Georgia">В отличие от систем, использующих ресурсы, в Java и Swing 
  вы должны в ручную собрать все меню в исходном коде. Вот очень простой пример 
  меню:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:SimpleMenus.java</font>
<font color="#009900">// &lt;applet code=SimpleMenus </font>
<font color="#009900">// width=200 height=75&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> SimpleMenus <font color="#0000ff">extends</font> JApplet {
  JTextField t = <font color="#0000ff">new</font> JTextField(15);
  ActionListener al = <font color="#0000ff">new</font> ActionListener() {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
      t.setText(
        ((JMenuItem)e.getSource()).getText());
    }
  };
  JMenu[] menus = { <font color="#0000ff">new</font> JMenu(<font color="#004488">"Winken"</font>), 
    <font color="#0000ff">new</font> JMenu(<font color="#004488">"Blinken"</font>), <font color="#0000ff">new</font> JMenu(<font color="#004488">"Nod"</font>) };
  JMenuItem[] items = {
    <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Fee"</font>), <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Fi"</font>),
    <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Fo"</font>),  <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Zip"</font>),
    <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Zap"</font>), <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Zot"</font>), 
    <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Olly"</font>), <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Oxen"</font>),
    <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Free"</font>) };
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; items.length; i++) {
      items[i].addActionListener(al);
      menus[i%3].add(items[i]);
    }
    JMenuBar mb = <font color="#0000ff">new</font> JMenuBar();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; menus.length; i++)
      mb.add(menus[i]);
    setJMenuBar(mb);
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(t); 
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> SimpleMenus(), 200, 75);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Использование оператора остатка от деления в выражении 
  “<b>i%3</b>” распределяет элементы меню на три <b>JMenu</b>. Каждый 
  <b>JMenuItem</b> должен иметь присоединенный к нему <b>ActionListener</b>; здесь 
  один и тот же <b>ActionListener</b> используется везде, но вам обычно нужны 
  индивидуальные слушатели для каждого <b>JMenuItem</b>.</font></p>
<p><a name="Index1716"></a><font face="Georgia"><b>JMenuItem</b> наследует от 
  <b>AbstractButton</b>, так что он имеет поведение, аналогичное кнопке. Сам по 
  себе он обеспечивает элемент, который может быть помещен в выпадающее меню. 
  Есть также три типа наследников от <b>JMenuItem</b>: <b>JMenu</b> для содержания 
  других <b>JMenuItem</b> (так что вы можете иметь каскадированное меню), <b>JCheckBoxMenuItem</b>, 
  которое производит отметки, указывающие, было ли выбрано меню, или нет, и <b>JRadioButtonMenuItem</b>, 
  которое содержит радио кнопки.</font></p>
<p><font face="Georgia">В качестве более изощренного примере здесь снова используются 
  вкусы мороженого, используемые для создания меню. Этот пример также показывает 
  каскадируемое меню, мнемонические обозначение клавиш, <b>JCheckBoxMenuItem</b>, 
  и способ, которым вы можете динамически менять меню:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Menus.java</font>
<font color="#009900">// Подменю, checkbox-элементы в меню, перестановка меню,</font>
<font color="#009900">// мнемоники (горячие клавиши) и команды реакции.</font>
<font color="#009900">// &lt;applet code=Menus width=300</font>
<font color="#009900">// height=100&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Menus <font color="#0000ff">extends</font> JApplet {
  String[] flavors = { <font color="#004488">"Chocolate"</font>, <font color="#004488">"Strawberry"</font>,
    <font color="#004488">"Vanilla Fudge Swirl"</font>, <font color="#004488">"Mint Chip"</font>, 
    <font color="#004488">"Mocha Almond Fudge"</font>, <font color="#004488">"Rum Raisin"</font>, 
    <font color="#004488">"Praline Cream"</font>, <font color="#004488">"Mud Pie"</font> };
  JTextField t = <font color="#0000ff">new</font> JTextField(<font color="#004488">"No flavor"</font>, 30);
  JMenuBar mb1 = <font color="#0000ff">new</font> JMenuBar();
  JMenu 
    f = <font color="#0000ff">new</font> JMenu(<font color="#004488">"File"</font>),
    m = <font color="#0000ff">new</font> JMenu(<font color="#004488">"Flavors"</font>),
    s = <font color="#0000ff">new</font> JMenu(<font color="#004488">"Safety"</font>);
  <font color="#009900">// Альтернативный подход:</font>
  JCheckBoxMenuItem[] safety = {
    <font color="#0000ff">new</font> JCheckBoxMenuItem(<font color="#004488">"Guard"</font>),
    <font color="#0000ff">new</font> JCheckBoxMenuItem(<font color="#004488">"Hide"</font>)
  };
  JMenuItem[] file = {
    <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Open"</font>),
  };
  <font color="#009900">// Вторая полоса меню меняется на:</font>
  JMenuBar mb2 = <font color="#0000ff">new</font> JMenuBar();
  JMenu fooBar = <font color="#0000ff">new</font> JMenu(<font color="#004488">"fooBar"</font>);
  JMenuItem[] other = {
    <font color="#009900">// Добавление горячих клавиш в меню (мнемоник)</font>
    <font color="#009900">// очень просто, но их могут иметь только JMenuItems</font>
    <font color="#009900">// в своем конструкторе:</font>
    <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Foo"</font>, KeyEvent.VK_F),
    <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Bar"</font>, KeyEvent.VK_A),
    <font color="#009900">// Нет горячей клавиши:</font>
    <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Baz"</font>),
  };
  JButton b = <font color="#0000ff">new</font> JButton(<font color="#004488">"Swap Menus"</font>);
  <font color="#0000ff">class</font> BL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      JMenuBar m = getJMenuBar();
      setJMenuBar(m == mb1 ? mb2 : mb1);
      validate(); <font color="#009900">// Обновление фрейма</font>
    }
  }
  <font color="#0000ff">class</font> ML <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      JMenuItem target = (JMenuItem)e.getSource();
      String actionCommand = 
        target.getActionCommand();
      <font color="#0000ff">if</font>(actionCommand.equals(<font color="#004488">"Open"</font>)) {
        String s = t.getText();
        <font color="#0000ff">boolean</font> chosen = <font color="#0000ff">false</font>;
        <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; flavors.length; i++)
          <font color="#0000ff">if</font>(s.equals(flavors[i])) chosen = <font color="#0000ff">true</font>;
        <font color="#0000ff">if</font>(!chosen)
          t.setText(<font color="#004488">"Choose a flavor first!"</font>);
        <font color="#0000ff">else</font>
          t.setText(<font color="#004488">"Opening "</font>+ s +<font color="#004488">". Mmm, mm!"</font>);
      }
    }
  }
  <font color="#0000ff">class</font> FL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      JMenuItem target = (JMenuItem)e.getSource();
      t.setText(target.getText());
    }
  }
  <font color="#009900">// Другой способ: вы можете создать другой класс</font>
  <font color="#009900">// для каждого MenuItem. Затем вам</font>
  <font color="#009900">// не нужно следить, кто есть кто:</font>
  <font color="#0000ff">class</font> FooL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t.setText(<font color="#004488">"Foo selected"</font>);
    }
  }
  <font color="#0000ff">class</font> BarL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t.setText(<font color="#004488">"Bar selected"</font>);
    }
  }
  <font color="#0000ff">class</font> BazL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t.setText(<font color="#004488">"Baz selected"</font>);
    }
  }
  <font color="#0000ff">class</font> CMIL <font color="#0000ff">implements</font> ItemListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> itemStateChanged(ItemEvent e) {
      JCheckBoxMenuItem target = 
        (JCheckBoxMenuItem)e.getSource();
      String actionCommand = 
        target.getActionCommand();
      <font color="#0000ff">if</font>(actionCommand.equals(<font color="#004488">"Guard"</font>))
        t.setText(<font color="#004488">"Guard the Ice Cream! "</font> +
          <font color="#004488">"Guarding is "</font> + target.getState());
      <font color="#0000ff">else</font> <font color="#0000ff">if</font>(actionCommand.equals(<font color="#004488">"Hide"</font>))
        t.setText(<font color="#004488">"Hide the Ice Cream! "</font> +
          <font color="#004488">"Is it cold? "</font> + target.getState());
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    ML ml = <font color="#0000ff">new</font> ML();
    CMIL cmil = <font color="#0000ff">new</font> CMIL();
    safety[0].setActionCommand(<font color="#004488">"Guard"</font>);
    safety[0].setMnemonic(KeyEvent.VK_G);
    safety[0].addItemListener(cmil);
    safety[1].setActionCommand(<font color="#004488">"Hide"</font>);
    safety[0].setMnemonic(KeyEvent.VK_H);
    safety[1].addItemListener(cmil);
    other[0].addActionListener(<font color="#0000ff">new</font> FooL());
    other[1].addActionListener(<font color="#0000ff">new</font> BarL());
    other[2].addActionListener(<font color="#0000ff">new</font> BazL());
    FL fl = <font color="#0000ff">new</font> FL();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; flavors.length; i++) {
      JMenuItem mi = <font color="#0000ff">new</font> JMenuItem(flavors[i]);
      mi.addActionListener(fl);
      m.add(mi);
      <font color="#009900">// Добавляем разделитель:</font>
      <font color="#0000ff">if</font>((i+1) % 3 == 0) 
        m.addSeparator();
    }
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; safety.length; i++)
      s.add(safety[i]);
    s.setMnemonic(KeyEvent.VK_A);
    f.add(s);
    f.setMnemonic(KeyEvent.VK_F);
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; file.length; i++) {
      file[i].addActionListener(fl);
      f.add(file[i]);
    }
    mb1.add(f);
    mb1.add(m);
    setJMenuBar(mb1);
    t.setEditable(<font color="#0000ff">false</font>);
    Container cp = getContentPane();
    cp.add(t, BorderLayout.CENTER);
    <font color="#009900">// Готовим систему к замене меню:</font>
    b.addActionListener(<font color="#0000ff">new</font> BL());
    b.setMnemonic(KeyEvent.VK_S);
    cp.add(b, BorderLayout.NORTH);
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; other.length; i++)
      fooBar.add(other[i]);
    fooBar.setMnemonic(KeyEvent.VK_B);
    mb2.add(fooBar);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Menus(), 300, 100);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">В этой программе я поместил элементы меню в массивы, а 
  затем прошелся по всем массивам, вызывая <b>add(&nbsp;)</b> для каждого <b>JMenuItem</b>. 
  Это делает добавление или удаление пункта меню менее утомительным.</font></p>
<p><font face="Georgia">Эта программа создает не один, а два <b>JMenuBar</b> для 
  демонстрации, что меню может быть заменено во время работы программы. Вы можете 
  посмотреть, как создан <b>JMenuBar</b> из <b>JMenu</b>, и как каждый <b>JMenu</b> 
  создан из <b>JMenuItem</b>,<b> JCheckBoxMenuItem</b>, или даже <b>JMenu</b> 
  (который производит подменю). Когда <b>JMenuBar</b> собран, он может быть установлен 
  в текущей программе с помощью метода <b>setJMenuBar(&nbsp;)</b>. Обратите внимание, 
  что когда нажата кнопка, выполняется проверка какое меню сейчас установлено 
  с помощью вызова метода <b>getJMenuBar(&nbsp;)</b>, а затем помещает другое 
  меню на его место.</font></p>
<p><font face="Georgia">Когда проверяете “Open”, обратите внимание, 
  что пробелы и большие буквы - критичны, но Java не сигнализирует об ошибках, 
  если нет совпадений со словом “Open”. Такой род сравнения строк 
  приводи к ошибкам программы.</font></p>
<p><font face="Georgia">Пометки и снятие пометки на элементах меню происходит 
  автоматически. Код обработки <b>JCheckBoxMenuItem</b> показывает два разных 
  способа определения, что было помечено: сравнение строк (которое, как упоминалось 
  ранее, является не очень безопасным подходом, хотя вы видите его использование) 
  и сравнение объектов - источников события. Как показано, метод <a name="Index1717"></a><b>getState(&nbsp;) 
  </b>может использоваться для проверки состояния. Вы можете также менять состояние 
  <b>JCheckBoxMenuItem</b> с помощью <b>setState(&nbsp;)</b>.</font></p>
<p><font face="Georgia">События для меню немного противоречивы и могут запутать: 
  <a name="Index1718"></a><b>JMenuItem</b> использует <b>ActionListener</b>, а 
  <a name="Index1719"></a><b>JCheckboxMenuItem</b> использует <b>ItemListener</b>. 
  Объект <a name="Index1720"></a><b>JMenu</b> может также поддерживать <b>ActionListener</b>, 
  но обычно это бесполезно. В общем случае вы будете присоединять слушатели к 
  каждому <b>JMenuItem</b>, <b>JCheckBoxMenuItem</b> или <b>JRadioButtonMenuItem</b>, 
  но пример показывает <b>ItemListener</b> и <b>ActionListener</b>, присоединенные 
  к различным компонентам меню.</font></p>
<p><a name="Index1721"></a><a name="Index1722"></a><a name="Index1723"></a><font face="Georgia">Swing 
  поддерживает мнемоники, или “горячие клавиши”, так что вы можете 
  выбрать все что угодно, унаследованное от <b>AbstractButton</b> (кнопки, элементы 
  меню и т.п.), используя клавиатуру вместо мыши. Это достаточно просто: для <b>JMenuItem</b> 
  вы можете использовать перегруженный конструктор, который принимает второй аргумент, 
  идентифицирующий клавишу. Однако большинство <b>AbstractButton</b> не имеют 
  конструкторов, подобных этому, поэтому есть более общий способ решения проблемы 
  - это использование метода <a name="Index1724"></a><b>setMnemonic(&nbsp;)</b>. 
  Приведенный выше пример добавляет мнемонику к кнопке и к некоторым из элементов 
  меню; индикатор горячей клавиши в компоненте появляется автоматически.</font></p>
<p><a name="Index1726"></a><font face="Georgia">Вы также можете видеть использование 
  команды <b>setActionCommand(&nbsp;)</b>. Она выглядит немного странной, потому 
  что в каждом случае “команда реакции” точно такая же, как и метка 
  компонента меню. Почему просто не использовать метку вместо этой альтернативной 
  строки? Проблема заключена в интернационализации. Если вы перенесете эту программу 
  на другой язык, вы захотите изменить только метки в меню, и не изменять код 
  (чтобы не вносить новые ошибки). Чтобы выполнить это легче при кодировании, 
  выполняется проверка ассоциированной строки с этим компонентом меню, “команда 
  реакции” может быть неизменной, в то время как метка меню может измениться. 
  Весь код работает с “командой реакции”, так что на него не влияют 
  никакие изменения меток меню. Обратите внимание, что в этой программе не у всех 
  компонент меню проверяется их команда реакции, так что эти элементы не имеют 
  своих установленных команд реакции.</font></p>
<p><font face="Georgia">Основная работа происходит в слушателях. <b>BL</b> выполняет 
  обмен <a name="Index1727"></a><b>JMenuBar</b>. В <b>ML</b> “cмотрят, кто 
  звонил”, при этом подходе берется источник <a name="Index1728"></a><b>ActionEvent</b> 
  и приводится в типу <a name="Index1729"></a><b>JMenuItem</b>, затем получается 
  строка команды реакции для передачи ее в каскадную инструкцию <b>if</b>.</font></p>
<p><font face="Georgia">Слушатель <b>FL</b> прост, несмотря на то, что он обрабатывает 
  все различные вкусы в меню вкусов. Этот подход полезен, если вы имеете достаточно 
  простую логику, но в общем случае вы будете использовать подход с использованием 
  <b>FooL</b>, <b>BarL</b> и <b>BazL</b>, каждый из которых присоединяется только 
  к одному компоненту меню, так чтобы не нужна было дополнительная логика определения, 
  и вы точно знали, кто вызвал слушателя. Даже с избытком классов, созданных этим 
  способом, внутренний код имеет тенденцию быть меньше, а процесс более понятным.</font></p>
<p><font face="Georgia">Вы можете видеть, что код меню быстро становится многозначным 
  и беспорядочным. Это другой случай, где использование построителя GUI является 
  подходящим решением. Хороший инструмент также берет на себя заботы о меню</font><font face="Georgia">.</font><a name="_Toc481064821"></a></p>
<div align="left"></div>
<a name="Heading456"></a><font face="Verdana">
<h3 align="left"> Всплывающие меню<a name="Index1730"></a><a name="Index1731"></a></h3>
</font> 
<p><font face="Georgia">Наиболее прямой путь для реализации <b>JPopupMenu</b> 
  состоит в создании внутреннего класса, который расширяет <b>MouseAdapter</b>, 
  с последующим добавлением объектов в этот внутренний класс для каждой компоненты, 
  для которой вы хотите встроить всплывающее меню:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Popup.java</font>
<font color="#009900">// Создание всплывающего меню со Swing.</font>
<font color="#009900">// &lt;applet code=Popup</font>
<font color="#009900">//  width=300 height=200&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Popup <font color="#0000ff">extends</font> JApplet {
  JPopupMenu popup = <font color="#0000ff">new</font> JPopupMenu();
  JTextField t = <font color="#0000ff">new</font> JTextField(10);
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(t);
    ActionListener al = <font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        t.setText(
          ((JMenuItem)e.getSource()).getText());
      }
    };
    JMenuItem m = <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Hither"</font>);
    m.addActionListener(al);
    popup.add(m);
    m = <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Yon"</font>);
    m.addActionListener(al);
    popup.add(m);
    m = <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Afar"</font>);
    m.addActionListener(al);
    popup.add(m);
    popup.addSeparator();
    m = <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Stay Here"</font>);
    m.addActionListener(al);
    popup.add(m);
    PopupListener pl = <font color="#0000ff">new</font> PopupListener();
    addMouseListener(pl);
    t.addMouseListener(pl);
  }
  <font color="#0000ff">class</font> PopupListener <font color="#0000ff">extends</font> MouseAdapter {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> mousePressed(MouseEvent e) {
      maybeShowPopup(e);
    }
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> mouseReleased(MouseEvent e) {
      maybeShowPopup(e);
    }
    <font color="#0000ff">private</font> <font color="#0000ff">void</font> maybeShowPopup(MouseEvent e) {
      <font color="#0000ff">if</font>(e.isPopupTrigger()) {
        popup.show(
          e.getComponent(), e.getX(), e.getY());
      }
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Popup(), 300, 200);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><a name="Index1732"></a><font face="Georgia">Один и тот же <b>ActionListener</b> 
  добавляется в каждый <b>JMenuItem</b>, так что он получает текст из метки меню 
  и вставляет его в <b>JTextField</b>.</font><a name="_Toc481064822"></a></p>
<a name="Heading457"></a> <font face="Verdana">
<h3 align="left">Рисунок<a name="Index1733"></a><a name="Index1734"></a><a name="Index1735"></a></h3>
</font> 
<p><font face="Georgia">В хороших рабочих средах GUI рисунок должен быть разумно 
  прост, и это есть в библиотеке Swing. Проблема с любым примером рисования в 
  том, что расчеты, определяющие, где располагать вещи, обычно более сложные, 
  чем вызов процедур рисования, а эти вычисления часто перемешиваются вместе с 
  вызовами рисования, так что может показаться, что интерфейс более сложен, чем 
  есть на самом деле.</font></p>
<p><font face="Georgia">Для упрощения проблемы представления данных на экране, 
  здесь данные будут предоставляться встроенным методом <b>Math.sin(&nbsp;)</b>, 
  который является математической функцией синуса. Чтобы сделать задачу более 
  интересной, и для будущей демонстрации как легко использовать компоненты Swing, 
  будет помещен слайдер внизу формы для динамического контроля числа отображаемых 
  волн синуса. Кроме того, если вы измените размер окна, вы увидите, что волны 
  синуса изменят свой размер в соответствии с размером окна.</font></p>
<p><font face="Georgia">Хотя любой <a name="Index1736"></a><b>JComponent</b> может 
  быть отрисован и, поэтому, использоваться в качестве канвы, если вы хотите просто 
  рисовать на поверхности, вы обычно будете наследовать от <a name="Index1737"></a><b>JPanel</b>. 
  Только один метод вы должны перекрыть - это <b>paintComponent(&nbsp;)</b>, который 
  вызывается всякий раз, когда компонент должен быть перерисован (вам обычно не 
  нужно беспокоится об этом, это делает Swing). Когда он вызывается, Swing передает 
  объект <a name="Index1739"></a><b>Graphics</b> в этот метод, и вы затем можете 
  использовать этот объект для рисования на поверхности.</font></p>
<p><font face="Georgia">В следующем примере вся информация относительно рисования 
  находится в классе <b>SineDraw</b>; класс <b>SineWave</b> просто конфигурирует 
  программу и слайдер. Внутри <b>SineDraw</b> метод <b>setCycles(&nbsp;)</b> обеспечивает 
  способ, позволяющий другому объекту — в этом случае слайдеру — регулировать 
  число циклов.</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:SineWave.java</font>
<font color="#009900">// Рисование с помощью Swing, используя JSlider.</font>
<font color="#009900">// &lt;applet code=SineWave</font>
<font color="#009900">//  width=700 height=400&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> javax.swing.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">class</font> SineDraw <font color="#0000ff">extends</font> JPanel {
  <font color="#0000ff">static</font> <font color="#0000ff">final</font> <font color="#0000ff">int</font> SCALEFACTOR = 200;
  <font color="#0000ff">int</font> cycles;
  <font color="#0000ff">int</font> points;
  <font color="#0000ff">double</font>[] sines;
  <font color="#0000ff">int</font>[] pts;
  SineDraw() { setCycles(5); }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setCycles(<font color="#0000ff">int</font> newCycles) {
    cycles = newCycles;
    points = SCALEFACTOR * cycles * 2;
    sines = <font color="#0000ff">new</font> <font color="#0000ff">double</font>[points];
    pts = <font color="#0000ff">new</font> <font color="#0000ff">int</font>[points];
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; points; i++) {
      <font color="#0000ff">double</font> radians = (Math.PI/SCALEFACTOR) * i;
      sines[i] = Math.sin(radians);
    }
    repaint();
  }    
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> paintComponent(Graphics g) {
    <font color="#0000ff">super</font>.paintComponent(g);
    <font color="#0000ff">int</font> maxWidth = getWidth();
    <font color="#0000ff">double</font> hstep = (<font color="#0000ff">double</font>)maxWidth/(<font color="#0000ff">double</font>)points;
    <font color="#0000ff">int</font> maxHeight = getHeight();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; points; i++)
      pts[i] = (<font color="#0000ff">int</font>)(sines[i] * maxHeight/2 * .95
                     + maxHeight/2);
    g.setColor(Color.red);
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 1; i &lt; points; i++) {
      <font color="#0000ff">int</font> x1 = (<font color="#0000ff">int</font>)((i - 1) * hstep);
      <font color="#0000ff">int</font> x2 = (<font color="#0000ff">int</font>)(i * hstep);
      <font color="#0000ff">int</font> y1 = pts[i-1];
      <font color="#0000ff">int</font> y2 = pts[i];
      g.drawLine(x1, y1, x2, y2);
    }
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> SineWave <font color="#0000ff">extends</font> JApplet {
  SineDraw sines = <font color="#0000ff">new</font> SineDraw();
  JSlider cycles = <font color="#0000ff">new</font> JSlider(1, 30, 5);
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.add(sines);
    cycles.addChangeListener(<font color="#0000ff">new</font> ChangeListener(){
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> stateChanged(ChangeEvent e) {
        sines.setCycles(
          ((JSlider)e.getSource()).getValue());
      }
    });
    cp.add(BorderLayout.SOUTH, cycles);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> SineWave(), 700, 400);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Все члены - данные и массивы используются в расчетах точек 
  волны синуса: <b>cycles</b> указывает нужное число полных волн синуса, <b>points</b> 
  содержит полное число точек, которые будут построены, <b>sines</b> содержит 
  значения функции синуса, а <b>pts</b> содержит y-координату точек, которые будут 
  нарисованы на <b>JPanel</b>. Метод <b>setCycles(&nbsp;)</b> создает массивы, 
  размер которых равен числу необходимых точек и заполняет массив <b>sines</b> 
  значениями. При вызове <b>repaint(&nbsp;)</b>, <b>setCycles(&nbsp;)</b> становится 
  причиной вызова <b>paintComponent(&nbsp;)</b>, так что происходит оставшаяся 
  часть вычислений и перерисовки.</font></p>
<p><font face="Georgia">Первое, что вы должны сделать, когда перекрываете <b>paintComponent(&nbsp;)</b>, 
  это вызвать версию метода базового класса. Затем вы свободны делать все, что 
  захотите; обычно, это означает использование методов <b>Graphics</b>, которые 
  вы можете найти в документации для <b>java.awt.Graphics</b> (в HTML документации 
  на <i>java.sun.com</i>) для рисования и раскраски пикселей в <b>JPanel</b>. 
  Здесь вы можете видеть, что почти весь код задействован в выполнении вычислений; 
  только два метода реально управляют экраном, это <b>setColor(&nbsp;)</b> и <b>drawLine(&nbsp;)</b>. 
  Вы, вероятно, имели схожий опыт, когда создавали свою собственную программу, 
  которая отображала графические данные — большую часть времени вы будете 
  тратить на понимание того, что вы будете рисовать, но сам процесс рисования 
  будет достаточно простым.</font></p>
<p><font face="Georgia">Когда я создавал эту программу, большую часть времени 
  я потратил на получение волны синуса для отображения. Как только я сделал это, 
  я подумал, что было бы неплохо иметь возможность динамически изменять число 
  периодов. Из-за моего опыта программирования, когда я пробовал делать подобные 
  вещи в других языках программирования, я неохотно взялся за эту попытку, но 
  это была самая легкая часть проекта. Я создал <b>JSlider</b> (аргументами являются 
  самое левое значение для <b>JSlider</b>, самое правое значение и начальное значение, 
  соответственно, но также есть и другие конструкторы) и бросил его в <b>JApplet</b>. 
  Затем я взглянул в HTML документацию, и заметил, что есть только слушатель <a name="Index1740"></a><b>addChangeListener</b>, 
  который запускается всегда, когда меняется слайдер для производства нового значения. 
  Для этого был метод с очевидным названием <a name="Index1741"></a><b>stateChanged(&nbsp;)</b>, 
  которые имеет объект <b>ChangeEvent</b>, так что я мог снова посмотреть на источник 
  изменений и найти новое значение. При вызове метода <b>setCycles(&nbsp;)</b> 
  объекта <b>sines</b> передается новое значение и <b>JPanel</b> перерисовывается.</font></p>
<p><font face="Georgia">В общем, вы найдете, что большинство ваших проблем в Swing 
  могут быть решены при использовании аналогичного процесса, и вы найдете, что 
  в общем случае это достаточно просто, даже если вы прежде не использовали некоторые 
  компоненты.</font></p>
<p><font face="Georgia">Если ваши проблемы более сложные, есть более изощренные 
  альтернативные способы рисования, включая JavaBeans компоненты сторонних производителей 
  и Java 2D API. Эти решения не входят в число вопросов, рассматриваемых в этой 
  книге, но вы должны просмотреть их, если ваш код рисования становится слишком 
  обременительным</font><font face="Georgia">.</font><a name="_Toc481064823"></a></p>
<div align="left"></div>
<a name="Heading458"></a><font face="Verdana">
<h3 align="left"> Окна диалогов<a name="Index1742"></a><a name="Index1743"></a></h3>
</font> 
<p><font face="Georgia">Окна диалогов - это окна, которые всплывают из других 
  окон. Их назначение состоит в решении специфических проблем без изменения деталей 
  оригинального окна. Окна диалогов часто используются в оконной среде программ, 
  и менее часто используются в апплетах.</font></p>
<p><font face="Georgia">Для создания диалога вы наследуете от <b>JDialog</b>, 
  который является просто видом окна, как и <b>JFrame</b>. <b>JDialog</b> имеет 
  менеджер компоновки (по умолчанию это <b>BorderLayout</b>) и вы добавляете слушатель 
  событий для работы с событиями. Одно значительное отличие возникает при вызове 
  <a name="Index1744"></a><b>windowClosing(&nbsp;)</b>. Оно состоит в том, что 
  вам не нужно завершать приложение. Вместо этого вы освобождаете ресурсы, используемые 
  окном диалога, вызывая <a name="Index1745"></a><b>dispose(&nbsp;)</b>. Вот простой 
  пример:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Dialogs.java</font>
<font color="#009900">// Создание и использование диалогов.</font>
<font color="#009900">// &lt;applet code=Dialogs width=125 height=75&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">class</font> MyDialog <font color="#0000ff">extends</font> JDialog {
  <font color="#0000ff">public</font> MyDialog(JFrame parent) {
    <font color="#0000ff">super</font>(parent, <font color="#004488">"My dialog"</font>, <font color="#0000ff">true</font>);
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Here is my dialog"</font>));
    JButton ok = <font color="#0000ff">new</font> JButton(<font color="#004488">"OK"</font>);
    ok.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        dispose(); <font color="#009900">// Закрытие диалога.</font>
      }
    });
    cp.add(ok);
    setSize(150,125);
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Dialogs <font color="#0000ff">extends</font> JApplet {
  JButton b1 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Dialog Box"</font>);
  MyDialog dlg = <font color="#0000ff">new</font> MyDialog(<font color="#0000ff">null</font>);
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    b1.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        dlg.show();
      }
    });
    getContentPane().add(b1);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Dialogs(), 125, 75);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Как только <b>JDialog</b> создан, должен быть вызван метод 
  <a name="Index1746"></a><b>show(&nbsp;)</b> для его отображения и активации. 
  Для закрытия диалога должен быть вызван метод <b>dispose(&nbsp;)</b>.</font></p>
<p><font face="Georgia">Вы увидите, что ко всему, что всплывает из апплета, включая 
  диалоги, нет доверия. То есть, вы получите всплывающее окно предупреждения. 
  Это происходит потому, что, теоретически, есть возможность одурачить пользователя 
  и заставить его думать, что он имеет дело с обычным местным приложением и дать 
  ему напечатать номер его кредитной карточки, который будет передан через Web. 
  Апплет всегда присоединяется в Web странице и его видно внутри вашего Web броузера, 
  а диалог не присоединен, поэтому, теоретически, это становится возможным. В 
  результате, не часто можно увидеть апплеты, использующие окна диалога.</font></p>
<p><font face="Georgia">Следующий пример сложнее; окно диалога сделано в виде 
  решетки (используется <b>GridLayout</b>) кнопок специального рода, которые определены 
  здесь, как класс <b>ToeButton</b>. Эти кнопки рисуют рамку вокруг себя и, в 
  зависимости от состояния, остаются пустыми, рисуют “x” или “o” 
  в середине. Изначально они пустые, а затем, в зависимости от того, кто включен, 
  меняются на “x” или “o”. Однако также есть обратная 
  и прямая связь между “x” и “o”, когда вы нажимаете кнопку. 
  (Здесь воссоздается концепция tic-tac-toe, только немного более надоедливая, 
  чем существующая.) Кроме того, диалог может быть установлен на любое число колонок 
  и строк, путем изменения чисел в главном окне приложения.</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:TicTacToe.java</font>
<font color="#009900">// Демонстрация диалогов</font>
<font color="#009900">// и создание ваших собственных компонент.</font>
<font color="#009900">// &lt;applet code=TicTacToe</font>
<font color="#009900">//  width=200 height=100&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> TicTacToe <font color="#0000ff">extends</font> JApplet {
  JTextField 
    rows = <font color="#0000ff">new</font> JTextField(<font color="#004488">"3"</font>),
    cols = <font color="#0000ff">new</font> JTextField(<font color="#004488">"3"</font>);
  <font color="#0000ff">static</font> <font color="#0000ff">final</font> <font color="#0000ff">int</font> BLANK = 0, XX = 1, OO = 2;
  <font color="#0000ff">class</font> ToeDialog <font color="#0000ff">extends</font> JDialog {
    <font color="#0000ff">int</font> turn = XX; <font color="#009900">// Начинается с включения x</font>
    <font color="#009900">// w = число ячеек в ширину</font>
    <font color="#009900">// h = число ячеек в высоту</font>
    <font color="#0000ff">public</font> ToeDialog(<font color="#0000ff">int</font> w, <font color="#0000ff">int</font> h) {
      setTitle(<font color="#004488">"The game itself"</font>);
      Container cp = getContentPane();
      cp.setLayout(<font color="#0000ff">new</font> GridLayout(w, h));
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; w * h; i++)
        cp.add(<font color="#0000ff">new</font> ToeButton());
      setSize(w * 50, h * 50);
      <font color="#009900">// JDK 1.3 закрытие диалога:</font>
      <font color="#009900">//#setDefaultCloseOperation(</font>
      <font color="#009900">//#  DISPOSE_ON_CLOSE);</font>
      <font color="#009900">// JDK 1.2 закрытие диалога:</font>
      addWindowListener(<font color="#0000ff">new</font> WindowAdapter() {
        <font color="#0000ff">public</font> <font color="#0000ff">void</font> windowClosing(WindowEvent e){
          dispose();
        }
      });    
    }
    <font color="#0000ff">class</font> ToeButton <font color="#0000ff">extends</font> JPanel {
      <font color="#0000ff">int</font> state = BLANK;
      <font color="#0000ff">public</font> ToeButton() {
        addMouseListener(<font color="#0000ff">new</font> ML());
      }
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> paintComponent(Graphics g) {
        <font color="#0000ff">super</font>.paintComponent(g);
        <font color="#0000ff">int</font> x1 = 0;
        <font color="#0000ff">int</font> y1 = 0;
        <font color="#0000ff">int</font> x2 = getSize().width - 1;
        <font color="#0000ff">int</font> y2 = getSize().height - 1;
        g.drawRect(x1, y1, x2, y2);
        x1 = x2/4;
        y1 = y2/4;
        <font color="#0000ff">int</font> wide = x2/2;
        <font color="#0000ff">int</font> high = y2/2;
        <font color="#0000ff">if</font>(state == XX) {
          g.drawLine(x1, y1, 
            x1 + wide, y1 + high);
          g.drawLine(x1, y1 + high, 
            x1 + wide, y1);
        }
        <font color="#0000ff">if</font>(state == OO) {
          g.drawOval(x1, y1, 
            x1 + wide/2, y1 + high/2);
        }
      }
      <font color="#0000ff">class</font> ML <font color="#0000ff">extends</font> MouseAdapter {
        <font color="#0000ff">public</font> <font color="#0000ff">void</font> mousePressed(MouseEvent e) {
          <font color="#0000ff">if</font>(state == BLANK) {
            state = turn;
            turn = (turn == XX ? OO : XX);
          } 
          <font color="#0000ff">else</font>
            state = (state == XX ? OO : XX);
          repaint();
        }
      }
    }
  }
  <font color="#0000ff">class</font> BL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      JDialog d = <font color="#0000ff">new</font> ToeDialog(
        Integer.parseInt(rows.getText()),
        Integer.parseInt(cols.getText()));
      d.setVisible(<font color="#0000ff">true</font>);
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    JPanel p = <font color="#0000ff">new</font> JPanel();
    p.setLayout(<font color="#0000ff">new</font> GridLayout(2,2));
    p.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Rows"</font>, JLabel.CENTER));
    p.add(rows);
    p.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Columns"</font>, JLabel.CENTER));
    p.add(cols);
    Container cp = getContentPane();
    cp.add(p, BorderLayout.NORTH);
    JButton b = <font color="#0000ff">new</font> JButton(<font color="#004488">"go"</font>);
    b.addActionListener(<font color="#0000ff">new</font> BL());
    cp.add(b, BorderLayout.SOUTH);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> TicTacToe(), 200, 100);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Поскольку <b>static</b> может быть только на внешнем уровне 
  класса, внутренний класс не может иметь статических данный или статических внутренних 
  классов.</font></p>
<p><a name="Index1747"></a><a name="Index1748"></a><font face="Georgia">Метод 
  <b>paintComponent(&nbsp;)</b> рисует прямоугольник вокруг панели и “x” 
  или “o”. Здесь выполняются достаточно скучные, но понятные вычисления.</font></p>
<p><font face="Georgia">Щелчок мыши захватывает <b>MouseListener</b>, который 
  сначала проверяет, написано ли что-нибудь на панели. Если нет, опрашивается 
  родительское окно, чтобы определить, что нужно включить, и это используется 
  для установки состояния <b>ToeButton</b>. Через механизм внутреннего класса 
  <b>ToeButton</b> обращается назад к своему родителю и меняется. Если кнопка 
  в данный момент отображает “x” или “o”, то знак меняется. 
  Вы можете видеть в расчетах последовательное использование тернарного оператора 
  if-else, описанного в <a href=" Chapter03.html">Главе 3</a>. После смены состояния 
  происходит перерисовка <b>ToeButton</b>.</font></p>
<p><font face="Georgia">Конструктор <b>ToeDialog</b> достаточно прост: он добавляет 
  в <b>GridLayout</b> столько кнопок, сколько вы запросили, затем изменяет их 
  размер до 50 пикселей на сторону для каждой кнопки.</font></p>
<p><font face="Georgia"><b>TicTacToe</b> устанавливает все приложение, создавая 
  <b>JTextField</b> (для ввода числа строк и колонок кнопок в сетке) и кнопку 
  “go” с присоединенным <b>ActionListener</b>. Когда нажимается кнопка, 
  извлекаются данные из <b>JTextField</b>, и, так как они имеют форму <b>String</b>, 
  они переводятся в <b>int</b>, используя статический метод <b>Integer.parseInt(&nbsp;)</b>.</font><a name="_Toc481064824"></a></p>
<div align="left"></div>
<a name="Heading459"></a><font face="Verdana">
<h3 align="left"> Файловые диалоги<a name="Index1751"></a><a name="Index1752"></a></h3>
</font> 
<p><font face="Georgia">Некоторые операционные системы имеют несколько специальных 
  встроенных диалогов для обработки выбора таких вещей, как фонт, цвет, принтер 
  и т.п. Фактически все графические операционные системы поддерживают открытие 
  и сохранение файлов, точно так же и <a name="Index1753"></a><b>JFileChooser</b> 
  из Java инкапсулирует это для легкого использования.</font></p>
<p><font face="Georgia">Следующее приложение использует две формы диалогов <b>JFileChooser</b>, 
  одну для открытия, а другую для записи. Большинство кода будет вам знакомо, 
  а все интересующие нас действия происходят в слушателе событий для двух разных 
  кнопок:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:FileChooserTest.java</font>
<font color="#009900">// Демонстрация файловых диалогов.</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> FileChooserTest <font color="#0000ff">extends</font> JFrame {
  JTextField 
    filename = <font color="#0000ff">new</font> JTextField(),
    dir = <font color="#0000ff">new</font> JTextField();
  JButton 
    open = <font color="#0000ff">new</font> JButton(<font color="#004488">"Open"</font>),
    save = <font color="#0000ff">new</font> JButton(<font color="#004488">"Save"</font>);
  <font color="#0000ff">public</font> FileChooserTest() {
    JPanel p = <font color="#0000ff">new</font> JPanel();
    open.addActionListener(<font color="#0000ff">new</font> OpenL());
    p.add(open);
    save.addActionListener(<font color="#0000ff">new</font> SaveL());
    p.add(save);
    Container cp = getContentPane();
    cp.add(p, BorderLayout.SOUTH);
    dir.setEditable(<font color="#0000ff">false</font>);
    filename.setEditable(<font color="#0000ff">false</font>);
    p = <font color="#0000ff">new</font> JPanel();
    p.setLayout(<font color="#0000ff">new</font> GridLayout(2,1));
    p.add(filename);
    p.add(dir);
    cp.add(p, BorderLayout.NORTH);
  }
  <font color="#0000ff">class</font> OpenL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      JFileChooser c = <font color="#0000ff">new</font> JFileChooser();
      <font color="#009900">// Демонстрируется диалог "Open":</font>
      <font color="#0000ff">int</font> rVal = 
        c.showOpenDialog(FileChooserTest.<font color="#0000ff">this</font>);
      <font color="#0000ff">if</font>(rVal == JFileChooser.APPROVE_OPTION) {
        filename.setText(
          c.getSelectedFile().getName());
          dir.setText(
            c.getCurrentDirectory().toString());
      }
      <font color="#0000ff">if</font>(rVal == JFileChooser.CANCEL_OPTION) {
        filename.setText(<font color="#004488">"You pressed cancel"</font>);
        dir.setText(<font color="#004488">""</font>);
      }
    }
  }
  <font color="#0000ff">class</font> SaveL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      JFileChooser c = <font color="#0000ff">new</font> JFileChooser();
      <font color="#009900">// демонстрация диалога "Save":</font>
      <font color="#0000ff">int</font> rVal = 
        c.showSaveDialog(FileChooserTest.<font color="#0000ff">this</font>);
      <font color="#0000ff">if</font>(rVal == JFileChooser.APPROVE_OPTION) {
        filename.setText(
          c.getSelectedFile().getName());
          dir.setText(
            c.getCurrentDirectory().toString());
      }
      <font color="#0000ff">if</font>(rVal == JFileChooser.CANCEL_OPTION) {
        filename.setText(<font color="#004488">"You pressed cancel"</font>);
        dir.setText(<font color="#004488">""</font>);
      }
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> FileChooserTest(), 250, 110);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Обратите внимание, что есть много вариаций, который вы 
  можете применить к <b>JFileChooser</b>, включая фильтры для выделения имен файлов, 
  которые вы хотите сделать доступными.</font></p>
<p><font face="Georgia">Для диалога </font><font face="Georgia"> “открытия 
  файла” вы вызываете <b>showOpenDialog(&nbsp;)</b>, а для диалога “записи 
  файла” вы вызываете <b>showSaveDialog(&nbsp;)</b>. Возврат из этих команд 
  не происходит до закрытия диалога. Объект <b>JFileChooser</b> все еще существует, 
  поэтому вы можете прочесть данные из него. Методы <b>getSelectedFile(&nbsp;)</b> 
  и <b>getCurrentDirectory(&nbsp;)</b> - это два способа, которыми вы можете спросить 
  результат операции. Если возвращен <b>null</b>, это значит, что пользователь 
  аннулировал диалог</font><font face="Georgia">.</font><a name="_Toc481064825"></a></p>
<div align="left"></div>
<a name="Heading460"></a><font face="Verdana">
<h3 align="left"> HTML в Swing компонентах<a name="Index1754"></a><a name="Index1755"></a></h3>
</font> 
<p><font face="Georgia">Любая компонента, которая может принимать текст, также 
  может принимать HTML текст, который будет переформатироваться в соответствии 
  с правилами HTML. Это означает, что вы можете очень легко добавить разукрашенный 
  текст в компонент Swing. Например:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:HTMLButton.java</font>
<font color="#009900">// Помещение HTML текста в компоненту Swing.</font>
<font color="#009900">// &lt;applet code=HTMLButton width=200 height=500&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> HTMLButton <font color="#0000ff">extends</font> JApplet {
  JButton b = <font color="#0000ff">new</font> JButton(<font color="#004488">"&lt;html&gt;&lt;b&gt;&lt;font size=+2&gt;"</font> +
    <font color="#004488">"&lt;center&gt;Hello!&lt;br&gt;&lt;i&gt;Press me now!"</font>);
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    b.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        getContentPane().add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"&lt;html&gt;"</font>+
          <font color="#004488">"&lt;i&gt;&lt;font size=+4&gt;Kapow!"</font>));
        <font color="#009900">// Производим перекомпоновку для</font>
        <font color="#009900">// включения новой метки:</font>
        validate();
      }
    });
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(b);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> HTMLButton(), 200, 500);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Вы должны начать текст с “&lt;html&gt;”, а 
  затем вы можете использовать обычные ярлыки HTML. Обратите внимание, что вы 
  не обязаны включать закрывающие ярлыки.</font></p>
<p><font face="Georgia"> <b>ActionListener</b> добавляет новую <b>JLabel</b> в 
  форму, которая так же содержит HTML текст. Однако эта метка не добавляется во 
  время <b>init(&nbsp;)</b>, так что вы должны вызвать метод <b>validate(&nbsp;)</b> 
  для контейнера, который заставит перекомпоноваться компоненты (и после этого 
  появится новая метка).</font></p>
<div align="left"></div>
<p><font face="Georgia">Вы также можете использовать HTML текст для <b>JTabbedPane</b>, 
  <b>JMenuItem</b>, <b>JToolTip</b>, <b>JRadioButton</b> и <b>JCheckBox</b>.</font><a name="_Toc481064826"></a></p>
<a name="Heading461"></a><font face="Verdana">
<h3 align="left"> Слайдеры и индикатор выполнения</h3>
</font> 
<p><font face="Georgia"> <a name="Index1756"></a>Слайдер (который уже использовался 
  в примере синусовой волны) позволяет пользователю вводить данные, перемещая 
  точку вперед и назад, что интуитивно понятно в некоторых ситуациях (например, 
  регулятор громкости). Индикатор выполнения отображает данные в относительной 
  форме от “заполненного” до “пустого”, так что пользователь 
  видит перспективу. Мой любимый пример этого - это простая связь слайдера м индикатора 
  выполнения, так что когда вы перемещаете слайдер, индикатор выполнения меняется 
  соответственно</font><font face="Georgia">:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:Progress.java</font>
<font color="#009900">// Использование индикатора выполнения и слайдера.</font>
<font color="#009900">// &lt;applet code=Progress</font>
<font color="#009900">//  width=300 height=200&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> javax.swing.event.*;
<font color="#0000ff">import</font> javax.swing.border.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Progress <font color="#0000ff">extends</font> JApplet {
  JProgressBar pb = <font color="#0000ff">new</font> JProgressBar();
  JSlider sb = 
    <font color="#0000ff">new</font> JSlider(JSlider.HORIZONTAL, 0, 100, 60);
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> GridLayout(2,1));
    cp.add(pb);
    sb.setValue(0);
    sb.setPaintTicks(<font color="#0000ff">true</font>);
    sb.setMajorTickSpacing(20);
    sb.setMinorTickSpacing(5);
    sb.setBorder(<font color="#0000ff">new</font> TitledBorder(<font color="#004488">"Slide Me"</font>));
    pb.setModel(sb.getModel()); <font color="#009900">// Распределенная модель</font>
    cp.add(sb);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Progress(), 300, 200);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Ключевое место сцепления двух компонент вместе заключается 
  в распределении их модели, в строке:</font></p>
<blockquote><font size="+1">
  <pre>pb.setModel(sb.getModel());</pre>
  </font></blockquote>
<p><font face="Georgia">Конечно, вы также можете управлять с использованием двух 
  слушателей, но <font color="#0000ff">этот</font> способ больше подходит <font color="#0000ff">для</font> 
  простой ситуации.</font></p>
<p><font face="Georgia"> <a name="Index1758"></a><b>JProgressBar </b>довольно 
  понятен, а <a name="Index1759"></a><b>JSlider</b> имеет массу опций, таких как 
  ориентация, главные и второстепенные маркеры. Обратите внимание, как просто 
  добавляется бордюр с заголовком.</font><a name="_Toc481064827"></a></p>
<div align="left"></div>
<a name="Heading462"></a><font face="Verdana">
<h3 align="left"> Деревья</h3>
</font> 
<p><font face="Georgia">Использование <a name="Index1760"></a><b>JTree </b>может 
  быть также просто, как об этом сказано:</font></p>
<blockquote><font size="+1">
  <pre>add(<font color="#0000ff">new</font> JTree(
  <font color="#0000ff">new</font> Object[] {<font color="#004488">"this"</font>, <font color="#004488">"that"</font>, <font color="#004488">"other"</font>}));</pre>
  </font></blockquote>
<p><font face="Georgia">Так отображается примитивное <a name="Index1761"></a>дерево. 
  Однако API для деревьев достаточно обширно — несомненно, одно из самых 
  больших в Swing. Это означает, что вы можете делать с деревьями все, что угодно, 
  но более изощренные задачи могут требовать немного исследований и экспериментов.</font></p>
<p><font face="Georgia">К счастью, библиотека обеспечивает ядро: компонент дерева 
  “по умолчанию” обычно делает то, что вам надо. Так что большую часть 
  времени вы будете использовать эти компоненты, и только в специальных случаях 
  вам нужно будет исследовать и понимать деревья более глубоко.</font></p>
<p><font face="Georgia">Следующий пример использует компонент дерева “по 
  умолчанию” для отображения дерева в апплете. Когда вы нажмете кнопку, 
  добавится новое поддерево в текущей выделенной ноде (если нода не выбрана, используется 
  корневая нода)</font><font face="Georgia">:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Trees.java</font>
<font color="#009900">// Простой пример Swing дерева. Деревья могут</font>
<font color="#009900">// быть сделаны намного более сложными, чем здесь.</font>
<font color="#009900">// &lt;applet code=Trees</font>
<font color="#009900">//  width=250 height=250&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> javax.swing.tree.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#009900">// Берется массив Strings и создается первый</font>
<font color="#009900">// элемент ноды, а оставшиеся оставляются:</font>
<font color="#0000ff">class</font> Branch {
  DefaultMutableTreeNode r;
  <font color="#0000ff">public</font> Branch(String[] data) {
    r = <font color="#0000ff">new</font> DefaultMutableTreeNode(data[0]);
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 1; i &lt; data.length; i++)
      r.add(<font color="#0000ff">new</font> DefaultMutableTreeNode(data[i]));
  }
  <font color="#0000ff">public</font> DefaultMutableTreeNode node() { 
    <font color="#0000ff">return</font> r; 
  }
}  

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Trees <font color="#0000ff">extends</font> JApplet {
  String[][] data = {
    { <font color="#004488">"Colors"</font>, <font color="#004488">"Red"</font>, <font color="#004488">"Blue"</font>, <font color="#004488">"Green"</font> },
    { <font color="#004488">"Flavors"</font>, <font color="#004488">"Tart"</font>, <font color="#004488">"Sweet"</font>, <font color="#004488">"Bland"</font> },
    { <font color="#004488">"Length"</font>, <font color="#004488">"Short"</font>, <font color="#004488">"Medium"</font>, <font color="#004488">"Long"</font> },
    { <font color="#004488">"Volume"</font>, <font color="#004488">"High"</font>, <font color="#004488">"Medium"</font>, <font color="#004488">"Low"</font> },
    { <font color="#004488">"Temperature"</font>, <font color="#004488">"High"</font>, <font color="#004488">"Medium"</font>, <font color="#004488">"Low"</font> },
    { <font color="#004488">"Intensity"</font>, <font color="#004488">"High"</font>, <font color="#004488">"Medium"</font>, <font color="#004488">"Low"</font> },
  };
  <font color="#0000ff">static</font> <font color="#0000ff">int</font> i = 0;
  DefaultMutableTreeNode root, child, chosen;
  JTree tree;
  DefaultTreeModel model;
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    root = <font color="#0000ff">new</font> DefaultMutableTreeNode(<font color="#004488">"root"</font>);
    tree = <font color="#0000ff">new</font> JTree(root);
    <font color="#009900">// Это добавляется для заботы о скроллировании:</font>
    cp.add(<font color="#0000ff">new</font> JScrollPane(tree), 
      BorderLayout.CENTER);
    <font color="#009900">// Получение модели дерева:</font>
    model =(DefaultTreeModel)tree.getModel();
    JButton test = <font color="#0000ff">new</font> JButton(<font color="#004488">"Press me"</font>);
    test.addActionListener(<font color="#0000ff">new</font> ActionListener() {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
        <font color="#0000ff">if</font>(i &lt; data.length) {
          child = <font color="#0000ff">new</font> Branch(data[i++]).node();
          <font color="#009900">// Что было последним, на чем вы щелкнули?</font>
          chosen = (DefaultMutableTreeNode)
            tree.getLastSelectedPathComponent();
          <font color="#0000ff">if</font>(chosen == <font color="#0000ff">null</font>) chosen = root;
          <font color="#009900">// Модель будет создавать</font>
          <font color="#009900">// соответствующие события. В ответ</font>
          <font color="#009900">// дерево будет обновлять себя:</font>
          model.insertNodeInto(child, chosen, 0);
          <font color="#009900">// Здесь помещается новая нода</font>
          <font color="#009900">// в текущую выбранную ноду.</font>
        }
      }
    });
    <font color="#009900">// Изменение цвета кнопки:</font>
    test.setBackground(Color.blue);
    test.setForeground(Color.white);
    JPanel p = <font color="#0000ff">new</font> JPanel();
    p.add(test);
    cp.add(p, BorderLayout.SOUTH);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Trees(), 250, 250);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Первый класс, <b>Branch</b>, это инструмент для получения 
  массива <b>String</b> и построения <a name="Index1762"></a><b>DefaultMutableTreeNode</b> 
  с первым элементом <b>String</b> в качестве корня, а другие элементы не трогаются. 
  Затем может быть вызван <b>node(&nbsp;)</b> для производства корня этого “branch”.</font></p>
<p><font face="Georgia">Класс <b>Trees</b> содержит двумерный массив из <b>String</b>, 
  из которого могут быть сделаны <b>Branch</b> (ветви), и <b>static int i</b> 
  для подсчета в массиве. Объект <b>DefaultMutableTreeNode</b> содержит ноды, 
  а физическое представление на экране управляется <b>JTree</b> и ассоциированной 
  с ним моделью - <a name="Index1763"></a><b>DefaultTreeModel</b>. Обратите внимание, 
  что когда <b>JTree</b> добавляется в апплет, он оборачивается в <a name="Index1764"></a><b>JScrollPane</b> 
  — это все, что нужно сделать для автоматического скроллинга.</font></p>
<p><font face="Georgia"> <b>JTree</b> управляется своей <i>моделью</i>. Когда 
  вы делаете изменения в модели, модель генерирует событие, которое является причиной 
  того, что <b>JTree</b> выполняет необходимые обновления для отображения представления 
  дерева. В <b>init(&nbsp;)</b> модель захватывается вызовом <a name="Index1765"></a><b>getModel(&nbsp;)</b>. 
  Когда нажимается кнопка, создается новая “ветвь(branch)”. Затем 
  находится текущий выделенный компонент (или используется корень, если ничего 
  не выбрано) и метод модели <b>insertNodeInto(&nbsp;)</b> выполняет всю работу 
  по изменению дерева и является причиной его обновления.</font></p>
<p><font face="Georgia">Пример, подобный приведенному мной выше, может дать вам 
  то, что вы хотите от дерева. Однако деревья имеют мощь для выполнения всего, 
  что вы можете вообразить — везде, где вы видите слова “по умолчанию” 
  в приведенном выше примере, вы можете заменить своим собственным классом для 
  получения другого поведения. Но остерегитесь: почти все классы имеют большие 
  интерфейсы, так что вы можете потратить много времени на борьбу с пониманием 
  интерфейсов деревьев. Несмотря на это, в этом заключается хороший дизайн, а 
  альтернативы обычно хуже</font><font face="Georgia">.</font><a name="_Toc481064828"></a></p>
<div align="left"></div>
<a name="Heading463"></a><font face="Verdana">
<h3 align="left"> Таблицы</h3>
</font> 
<p><font face="Georgia">Как и деревья, <a name="Index1767"></a>таблицы в Swing 
  всеобъемлющи и мощны. Они в первую очередь предназначены быть популярным интерфейсом, 
  под названием “решетка (grid)” для баз данных через Java Database 
  Connectivity (JDBC, обсуждаемой в <a href=" Chapter15.html">Главе 15</a>) и поэтому 
  они имеют потрясающую гибкость, за которую вы платите сложностью. То, что здесь 
  описано, это только основы, а полное описание могло бы занять целую книгу. Однако 
  также возможно создать относительно простую <a name="Index1768"></a><b>JTable</b>, 
  если вы понимаете основы.</font></p>
<p><font face="Georgia"> <b>JTable</b> управляет отображением данных, а <b>TableModel</b> 
  оправляет самими данными. Так что для создания <b>JTable</b> вы обычно будете 
  создавать сначала <b>TableModel</b>. Вы можете полностью реализовывать интерфейс 
  <b>TableModel</b>, но обычно проще унаследовать его от вспомогательного класса 
  <b>AbstractTableModel</b>:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:Table.java</font>
<font color="#009900">// Простая демонстрация JTable.</font>
<font color="#009900">// &lt;applet code=Table</font>
<font color="#009900">//  width=350 height=200&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> javax.swing.table.*;
<font color="#0000ff">import</font> javax.swing.event.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Table <font color="#0000ff">extends</font> JApplet {
  JTextArea txt = <font color="#0000ff">new</font> JTextArea(4, 20);
  <font color="#009900">// TableModel управляет всеми данными:</font>
  <font color="#0000ff">class</font> DataModel <font color="#0000ff">extends</font> AbstractTableModel {
    Object[][] data = {
      {<font color="#004488">"one"</font>, <font color="#004488">"two"</font>, <font color="#004488">"three"</font>, <font color="#004488">"four"</font>},
      {<font color="#004488">"five"</font>, <font color="#004488">"six"</font>, <font color="#004488">"seven"</font>, <font color="#004488">"eight"</font>},
      {<font color="#004488">"nine"</font>, <font color="#004488">"ten"</font>, <font color="#004488">"eleven"</font>, <font color="#004488">"twelve"</font>},
    };
    <font color="#009900">// Печатает данные при изменении таблицы:</font>
    <font color="#0000ff">class</font> TML <font color="#0000ff">implements</font> TableModelListener {
      <font color="#0000ff">public</font> <font color="#0000ff">void</font> tableChanged(TableModelEvent e){
        txt.setText(<font color="#004488">""</font>); <font color="#009900">// Очистка</font>
        <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; data.length; i++) {
          <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; data[0].length; j++)
            txt.append(data[i][j] + <font color="#004488">" "</font>);
          txt.append(<font color="#004488">"\n"</font>);
        }
      }
    }
    <font color="#0000ff">public</font> DataModel() {
      addTableModelListener(<font color="#0000ff">new</font> TML());
    }
    <font color="#0000ff">public</font> <font color="#0000ff">int</font> getColumnCount() { 
      <font color="#0000ff">return</font> data[0].length; 
    }
    <font color="#0000ff">public</font> <font color="#0000ff">int</font> getRowCount() { 
      <font color="#0000ff">return</font> data.length;
    }
    <font color="#0000ff">public</font> Object getValueAt(<font color="#0000ff">int</font> row, <font color="#0000ff">int</font> col) {
      <font color="#0000ff">return</font> data[row][col]; 
    }
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> 
    setValueAt(Object val, <font color="#0000ff">int</font> row, <font color="#0000ff">int</font> col) {
      data[row][col] = val;
      <font color="#009900">// Указывает на появление изменений:</font>
      fireTableDataChanged();
    }
    <font color="#0000ff">public</font> <font color="#0000ff">boolean</font> 
    isCellEditable(<font color="#0000ff">int</font> row, <font color="#0000ff">int</font> col) { 
      <font color="#0000ff">return</font> <font color="#0000ff">true</font>; 
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    JTable table = <font color="#0000ff">new</font> JTable(<font color="#0000ff">new</font> DataModel());
    cp.add(<font color="#0000ff">new</font> JScrollPane(table));
    cp.add(BorderLayout.SOUTH, txt);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Table(), 350, 200);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia"><b>DataModel</b> содержит массив данных, но вы можете 
  также получить данные из какого-либо другого источника, такого, как база данных. 
  Конструктор добавляет <b>TableModelListener</b>, который печатает массив всякий 
  раз, когда меняется таблица. Оставшиеся методы следуют Главной концепции об 
  именах, и используются <b>JTable</b>, когда она хочет представить информацию 
  в <b>DataModel</b>. <b>AbstractTableModel</b> по умолчанию обеспечивает методы 
  <b>setValueAt(&nbsp;)</b> и <b>isCellEditable(&nbsp;)</b>, которые предотвращают 
  изменение данных, так что если вы хотите иметь возможность редактирования данных, 
  вы должны перекрыть эти методы.</font></p>
<p><font face="Georgia">Как только вы получите <b>TableModel</b>, все, что вам 
  нужно - это передать ее в конструктор <b>JTable</b>. Обо всех деталях отображения, 
  редактирования и обновления она будет заботиться вместо вас. Этот пример также 
  помещает </font><font face="Georgia"> <b>JTable</b> в <b>JScrollPane</b>.</font><a name="_Toc481064829"></a></p>
<div align="left"></div>
<a name="Heading464"></a><font face="Verdana">
<h3 align="left"> Выбор внешнего вида (Look &amp; Feel)</h3>
</font> 
<p><font face="Georgia">Один из самых интересных аспектов Swing заключен во <a name="Index1769"></a><a name="Index1770"></a>встраиваемом 
  внешнем виде (Look &amp; Feel). Это позволяет вам эмулировать внешний вид различных 
  операционных сред. Вы можете даже делать такие фантастические вещи, как динамическая 
  смена внешнего вида при выполнении программы. Однако обычно вам будет нужно 
  делать одну из двух вещей: либо выбирать “кросс платформенный” внешний 
  вид (это Swing “metal”), либо выбирать внешний вид для используемой 
  системы, так, чтобы ваша Java программа выглядела как созданная специально для 
  этой системы. Код выбора любого из видов достаточно прост — но вы должны 
  выполнить его прежде, чем вы создадите любой визуальный компонент, потому что 
  компоненты будут сделаны с использованием текущего вида и не изменятся только 
  из-за того, что произошла смена внешнего вида в середине выполнения программы 
  (этот процесс более сложный и не общий, поэтому я отошлю вас к книгам, специфицирующимся 
  на Swing).</font></p>
<p><font face="Georgia">На самом деле, если вы хотите использовать кросс платформенный 
  (“metal”) внешний вид в качестве характерного для Swing программ, 
  вам не нужно делать ничего — он используется по умолчанию. Но если вы 
  хотите вместо этого использовать внешний вид текущего операционного окружения, 
  вы просто вставляете следующий код, обычно в начале вашего метода <b>main(&nbsp;)</b> 
  и перед вставкой любых компонент</font><font face="Georgia">:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  <pre><font color="#0000ff">try</font> {
  UIManager.setLookAndFeel(UIManager.
    getSystemLookAndFeelClassName());
} <font color="#0000ff">catch</font>(Exception e) {}</pre>
  </font></blockquote>
<p><font face="Georgia">Вам ничего не нужно делать в предложении <b>catch</b>, 
  потому что <b>UIManager</b> будет по умолчанию использовать кросс платформенный 
  внешний вид, если попытка установить любой другой провалится. Однако во время 
  отладки исключение может быть достаточно полезным, так как вы можете пожелать 
  распечатать формулировку в предложении <b>catch</b>.</font></p>
<p><font face="Georgia">Вот программа, которая принимает аргумент командной строки 
  для выбора внешнего вида, и показывает, как выглядят несколько разных компонент 
  при выбранном внешнем виде:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:LookAndFeel.java</font>
<font color="#009900">// Выбор разных looks &amp; feels.</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.util.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> LookAndFeel <font color="#0000ff">extends</font> JFrame {
  String[] choices = { 
    <font color="#004488">"eeny"</font>, <font color="#004488">"meeny"</font>, <font color="#004488">"minie"</font>, <font color="#004488">"moe"</font>, <font color="#004488">"toe"</font>, <font color="#004488">"you"</font>
  };
  Component[] samples = {
    <font color="#0000ff">new</font> JButton(<font color="#004488">"JButton"</font>),
    <font color="#0000ff">new</font> JTextField(<font color="#004488">"JTextField"</font>),
    <font color="#0000ff">new</font> JLabel(<font color="#004488">"JLabel"</font>),
    <font color="#0000ff">new</font> JCheckBox(<font color="#004488">"JCheckBox"</font>),
    <font color="#0000ff">new</font> JRadioButton(<font color="#004488">"Radio"</font>),
    <font color="#0000ff">new</font> JComboBox(choices),
    <font color="#0000ff">new</font> JList(choices),
  };
  <font color="#0000ff">public</font> LookAndFeel() {
    <font color="#0000ff">super</font>(<font color="#004488">"Look And Feel"</font>);
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; samples.length; i++)
      cp.add(samples[i]);
  }
  <font color="#0000ff">private</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> usageError() {
    System.out.println(
      <font color="#004488">"Usage:LookAndFeel [cross|system|motif]"</font>);
    System.exit(1);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#0000ff">if</font>(args.length == 0) usageError();
    <font color="#0000ff">if</font>(args[0].equals(<font color="#004488">"cross"</font>)) {
      <font color="#0000ff">try</font> {
        UIManager.setLookAndFeel(UIManager.
          getCrossPlatformLookAndFeelClassName());
      } <font color="#0000ff">catch</font>(Exception e) {
          e.printStackTrace(System.err);
      }
    } <font color="#0000ff">else</font> <font color="#0000ff">if</font>(args[0].equals(<font color="#004488">"system"</font>)) {
      <font color="#0000ff">try</font> {
        UIManager.setLookAndFeel(UIManager.
          getSystemLookAndFeelClassName());
      } <font color="#0000ff">catch</font>(Exception e) {
          e.printStackTrace(System.err);
      }
    } <font color="#0000ff">else</font> <font color="#0000ff">if</font>(args[0].equals(<font color="#004488">"motif"</font>)) {
      <font color="#0000ff">try</font> {
        UIManager.setLookAndFeel(<font color="#004488">"com.sun.java."</font>+
          <font color="#004488">"swing.plaf.motif.MotifLookAndFeel"</font>);
      } <font color="#0000ff">catch</font>(Exception e) {
          e.printStackTrace(System.err);
      }
    } <font color="#0000ff">else</font> usageError();
    <font color="#009900">// Обратите внимание, что look &amp; feel должен</font>
    <font color="#009900">// быть установлен перед созданием компонент.</font>
    Console.run(<font color="#0000ff">new</font> LookAndFeel(), 300, 200);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Вы можете видеть, что одна опция явно указывает строку 
  для внешнего вида, как видно в <b>MotifLookAndFeel</b>. Однако этот внешний 
  вид и внешний вид по умолчанию могут легально использоваться на любой платформе; 
  даже если использовать строки для внешнего вида Windows и Macintosh, они могут 
  быть использованы только на соответствующей платформе (это производится при 
  вызове <b>getSystemLookAndFeelClassName(&nbsp;)</b>, а вы находитесь под определенной 
  платформой).</font></p>
<p><font face="Georgia">Так же возможно создать собственный внешний вид, например, 
  если вы строите рабочую среду компании, которая хочет иметь характерный внешний 
  вид. Это большая работа и эта тема выходит далеко за пределы этой книги (фактически, 
  вы обнаружите, что она выходит за пределы обсуждения многих книг о Swing!)</font><font face="Georgia">.</font><a name="_Toc481064830"></a></p>
<a name="Heading465"></a><font face="Verdana">
<h3 align="left"> Буфер обмена</h3>
</font> 
<p><font face="Georgia"> JFC поддерживает ограниченное число операций с <a name="Index1771"></a><a name="Index1772"></a>системным 
  буфером обмена (в пакете <b>java.awt.datatransfer</b>). Вы можете скопировать 
  объект <b>String</b> в буфер обмена как текст, и вы можете вставить текст из 
  буфера обмена в объект <b>String</b>. Конечно, буфер обмена предназначен для 
  хранения данных любого типа, но как представить эти данные в буфере обмена, 
  если программа выполняет вырезание и вставку. Java API для буфера обмена обеспечивает 
  расширяющуюся концепцию “особенностей”. Когда данные приходят из 
  буфера обмена, они имеют множество <a name="Index1773"></a>особенностей, которыми 
  они могут быть представлены (например, графика может быть представлена как строка 
  чисел или как изображение) и вы можете видеть, поддерживает ли определенный 
  буфер интересующие вас особенности.</font></p>
<p><font face="Georgia">Следующая программа просто демонстрирует вырезание, копирование 
  и вставку данных <b>String</b> в <a name="Index1774"></a><b>JTextArea</b>. Одно 
  вы должны заметить, это то, что последовательность кнопок, которую вы обычно 
  используете для вырезания, копирования и вставки так же работает. Но если вы 
  посмотрите на <b>JTextField</b> или<b> JTextArea</b> в любой другой программе, 
  вы обнаружите, что они тоже автоматически поддерживают последовательность клавиш 
  для буфера обмена. Этот пример просто добавляет программное управление буфером 
  обмена, и вы можете использовать эту технику, если хотите захватывать текст 
  из буфера обмена и вставлять во что-то другое, чем </font><font face="Georgia"> 
  <b>JTextComponent</b>.</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:CutAndPaste.java</font>
<font color="#009900">// Использование буфера обмена.</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.awt.datatransfer.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> CutAndPaste <font color="#0000ff">extends</font> JFrame  {
  JMenuBar mb = <font color="#0000ff">new</font> JMenuBar();
  JMenu edit = <font color="#0000ff">new</font> JMenu(<font color="#004488">"Edit"</font>);
  JMenuItem
    cut = <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Cut"</font>),
    copy = <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Copy"</font>),
    paste = <font color="#0000ff">new</font> JMenuItem(<font color="#004488">"Paste"</font>);
  JTextArea text = <font color="#0000ff">new</font> JTextArea(20, 20);
  Clipboard clipbd = 
    getToolkit().getSystemClipboard();
  <font color="#0000ff">public</font> CutAndPaste()  {
    cut.addActionListener(<font color="#0000ff">new</font> CutL());
    copy.addActionListener(<font color="#0000ff">new</font> CopyL());
    paste.addActionListener(<font color="#0000ff">new</font> PasteL());
    edit.add(cut);
    edit.add(copy);
    edit.add(paste);
    mb.add(edit);
    setJMenuBar(mb);
    getContentPane().add(text);
  }
  <font color="#0000ff">class</font> CopyL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      String selection = text.getSelectedText();
      <font color="#0000ff">if</font> (selection == <font color="#0000ff">null</font>)
        <font color="#0000ff">return</font>;
      StringSelection clipString =
        <font color="#0000ff">new</font> StringSelection(selection);
      clipbd.setContents(clipString,clipString);
    }
  }
  <font color="#0000ff">class</font> CutL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      String selection = text.getSelectedText();
      <font color="#0000ff">if</font> (selection == <font color="#0000ff">null</font>)
        <font color="#0000ff">return</font>;
      StringSelection clipString =
        <font color="#0000ff">new</font> StringSelection(selection);
      clipbd.setContents(clipString, clipString);
      text.replaceRange(<font color="#004488">""</font>,
        text.getSelectionStart(),
        text.getSelectionEnd());
    }
  }
  <font color="#0000ff">class</font> PasteL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      Transferable clipData =
        clipbd.getContents(CutAndPaste.<font color="#0000ff">this</font>);
      <font color="#0000ff">try</font> {
        String clipString =
          (String)clipData.
            getTransferData(
              DataFlavor.stringFlavor);
        text.replaceRange(clipString,
          text.getSelectionStart(),
          text.getSelectionEnd());
      } <font color="#0000ff">catch</font>(Exception ex) {
        System.err.println(<font color="#004488">"Not String flavor"</font>);
      }
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> CutAndPaste(), 300, 200);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Создание и добавление меню и <b>JTextArea</b> должно теперь 
  выглядеть прозаическим действием. Что отличается, так это создание поля <b>Clipboard</b> 
  <b>clipbd</b>, которое выполняется через <b>Toolkit</b>.</font></p>
<p><font face="Georgia">Все действия происходят в слушателях. Слушатели <b>CopyL</b> 
  и <b>CutL</b> одинаковы, за исключением того, что последняя строка в <b>CutL</b> 
  стирает скопированную строку. Специальные две строки создания объекта <a name="Index1775"></a><b>StringSelection</b> 
  из <b>String</b> вызывают <a name="Index1776"></a><b>setContents(&nbsp;)</b> 
  с этим <b>StringSelection</b>. Это все, что нужно для помещения <b>String</b> 
  в буфер обмена.</font></p>
<p><font face="Georgia">В <b>PasteL</b> данные вытягиваются из буфера обмена, 
  используя <a name="Index1777"></a><b>getContents(&nbsp;)</b>. Что приходит - 
  это совершенно анонимный объект <b>Transferable</b>, который возвращает массив 
  объектов <a name="Index1780"></a><b>DataFlavor</b>, указывает, какие особенности 
  поддерживаются определенным объектом. Вы можете так же спросить его напрямую 
  с помощью <a name="Index1781"></a><b>isDataFlavorSupported(&nbsp;)</b>, передав 
  особенность, которая вас интересует. Однако здесь выбран самонадеянный подход: 
  вызывается <a name="Index1782"></a><b>getTransferData(&nbsp;)</b> в надежде, 
  что содержимое поддерживает особенности <b>String</b>, а если это не так, проблема 
  выявляется в обработчике исключения.</font></p>
<p><font face="Georgia">В будущем вы можете ожидать поддержку большего числа особенностей.</font><a name="_Toc375545469"></a><a name="_Toc481064831"></a></p>
<div align="left"></div>
<a name="Heading466"></a> <font face="Verdana">
<h2 align="left">Упаковка апплетов в JAR файл<a name="Index1783"></a><a name="Index1784"></a></h2>
</font> 
<p><font face="Georgia">Важность использования утилиты JAR состоит в оптимизации 
  загрузки апплета. В Java 1.0 люди склонялись к попытке впихнуть весь код в единственный 
  класс апплета, чтобы клиенту было нужно единственное обращение к серверу для 
  загрузки кода апплета. Это не только приводило к грязному, трудно читаемому 
  коду (и сложному уходу за программой), но сгенерированный <b>.class</b> файл 
  все еще был не компрессированный, поэтому загрузка происходила не так быстро, 
  как это могло бы быть.</font></p>
<p><font face="Georgia">JAR файлы решили проблему компресси всех ваших <b>.class</b> 
  файлов в единственный файл, который загружается броузером. Теперь вы можете 
  создавать правильный дизайн без заботы о количестве генерируемых <b>.class </b>файлов, 
  а пользователь потратит меньше времени на загрузку.</font></p>
<p><font face="Georgia">Относительно <b>TicTacToe.java</b>. Программа выглядит 
  как единый класс, но, фактически, она содержит пять внутренних классов, так 
  что их всего шесть. Как только вы скомпилируете программу, вы упакуете ее в 
  JAR файл с помощью строки</font><font face="Georgia">:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  <pre>jar cf TicTacToe.jar *.<font color="#0000ff">class</font></pre>
  </font></blockquote>
<p><font face="Georgia">Здесь участвуют только <b>.class</b> из текущей директории, 
  то есть файлы для <b>TicTacToe.java</b> (в противном случае вы получите дополнительный 
  багаж).</font></p>
<p><font face="Georgia">Теперь вы можете создать HTML страницу с новым ярлыком 
  <a name="Index1785"></a><a name="Index1786"></a><a name="Index1787"></a><b>archive</b>, 
  указывающим имя JAR файла. Здесь ярлык использует старую форму ярлыка HTML, 
  как показано ниже:</font></p>
<blockquote><font size="+1">
  <pre>&lt;head&gt;&lt;title&gt;TicTacToe Example Applet
&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;applet code=TicTacToe.<font color="#0000ff">class</font>
        archive=TicTacToe.jar
        width=200 height=100&gt;
&lt;/applet&gt;
&lt;/body&gt;</pre>
  </font></blockquote>
<p><font face="Georgia"> Вам нужно поместить это в новую (грязну, сложную) форму, 
  показанную в этой главе, чтобы это правильно работало.<a name="_Toc481064832"></a></font><font size="+1"><a name=""></a></font><a name="Heading467"></a></p>
<font face="Verdana">
<h2 align="left"> Техника программирования</h2>
</font> 
<p><font face="Georgia">Поскольку GUI программирование в Java имеет развивающуюся 
  технология с некоторыми значительными изменениями, произошедшими при переходе 
  от Java 1.0/1.1к библиотеке Swing в Java 2, то появилось несколько старых идиом 
  программирования, которые просочились в примеры, данные для Swing. Кроме того, 
  Swing позволяет вам программировать больше и лучше, чем это позволяла старые 
  модели. В этом разделе будет введена демонстрация некоторые из этих подходов 
  и произведена проверка идиом</font><font face="Georgia">.</font><a name="_Toc481064833"></a></p>
<a name="Heading468"></a><font face="Verdana">
<h3 align="left"> Динамическое построение событий</h3>
</font> 
<p><font face="Georgia">Одна из выгод <a name="Index1788"></a><a name="Index1789"></a>модели 
  событий Swing заключена в гибкости. Вы можете добавлять и удалять обработку 
  события одним вызовом метода. Следующий пример демонстрирует это:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#009900">//: c13:DynamicEvents.java</font>
<font color="#009900">// Вы можете динамически изменить проявление события.</font>
<font color="#009900">// Также показывается различные акции для события.</font>
<font color="#009900">// &lt;applet code=DynamicEvents</font>
<font color="#009900">//  width=250 height=400&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.util.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> DynamicEvents <font color="#0000ff">extends</font> JApplet {
  ArrayList v = <font color="#0000ff">new</font> ArrayList();
  <font color="#0000ff">int</font> i = 0;
  JButton
    b1 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Button1"</font>),
    b2 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Button2"</font>);
  JTextArea txt = <font color="#0000ff">new</font> JTextArea();
  <font color="#0000ff">class</font> B <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      txt.append(<font color="#004488">"A button was pressed\n"</font>);
    }
  }
  <font color="#0000ff">class</font> CountListener <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">int</font> index;
    <font color="#0000ff">public</font> CountListener(<font color="#0000ff">int</font> i) { index = i; }
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      txt.append(<font color="#004488">"Counted Listener "</font>+index+<font color="#004488">"\n"</font>);
    }
  }
  <font color="#0000ff">class</font> B1 <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      txt.append(<font color="#004488">"Button 1 pressed\n"</font>);
      ActionListener a = <font color="#0000ff">new</font> CountListener(i++);
      v.add(a);
      b2.addActionListener(a);
    }
  }
  <font color="#0000ff">class</font> B2 <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      txt.append(<font color="#004488">"Button2 pressed\n"</font>);
      <font color="#0000ff">int</font> end = v.size() - 1;
      <font color="#0000ff">if</font>(end &gt;= 0) {
        b2.removeActionListener(
          (ActionListener)v.get(end));
        v.remove(end);
      }
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    b1.addActionListener(<font color="#0000ff">new</font> B());
    b1.addActionListener(<font color="#0000ff">new</font> B1());
    b2.addActionListener(<font color="#0000ff">new</font> B());
    b2.addActionListener(<font color="#0000ff">new</font> B2());
    JPanel p = <font color="#0000ff">new</font> JPanel();
    p.add(b1);
    p.add(b2);
    cp.add(BorderLayout.NORTH, p);
    cp.add(<font color="#0000ff">new</font> JScrollPane(txt));
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> DynamicEvents(), 250, 400);
  }
} <font color="#009900">///:~</font></font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Новшества этого примера в том, что:<a name="Index1790"></a><a name="Index1791"></a><a name="Index1792"></a><a name="Index1793"></a><a name="Index1794"></a></font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Есть более одного слушателя, 
    прикрепленного в каждой <b>Button</b>. Обычно компоненты обрабатывают события 
    как <i>групповые</i> (multicast), в том смысле, что вы можете зарегистрировать 
    много слушателей для единственного события. В специальных компонента, в которых 
    события обрабатываются <i>индивидуально</i> (unicast), вы получите <b>TooManyListenersException</b>.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Во время выполнения программы 
    слушатели динамически добавляются и удаляются из <b>Button b2</b>. Добавление 
    происходит тем же способом, который вы видели ранее, но каждый компонент имеет 
    также метод <b>removeXXXListener(&nbsp;)</b> для удаления слушателя каждого 
    типа.</font>
</li></ol>
<p><font face="Georgia">Гибкость такого рода обеспечивает большую мощь вашему 
  программированию.</font></p>
<p><font face="Georgia">Вы должны заметить, что <a name="Index1795"></a>слушатели 
  событий вызываются не гарантированно после того, как они добавлены (хотя большинство 
  реализаций делает работу, фактически, этим способом).</font><a name="_Toc481064834"></a></p>
<div align="left"></div>
<a name="Heading469"></a><font face="Verdana"> 
<h3 align="left"> Отделение бизнес логики от логики пользовательского интерфейса<a name="Index1796"></a></h3>
</font> 
<p><font face="Georgia">В общем случае вы захотите разработать ваши классы так, 
  чтобы каждый из них выполнял только одно. Это особенно важно, когда код <font color="#0000ff">интерфейса</font> 
  пользователя является связанным, так как легче связать “то, что вы делаете” 
  с тем, “как вы это отображаете”. Такой род связывания мешает повторному 
  использованию кода. Поэтому желательно разделить вашу “бизнес логику” 
  и GUI. Этим способом вы сможете не только с легкостью повторно использовать 
  бизнес логику, но и с легкостью повторно использовать GUI.</font></p>
<p><font face="Georgia">Другим подходом является <i>м</i><a name="Index1797"></a><i>ногосвязные</i> 
  системы, где “<a name="Index1798"></a><a name="Index1799"></a>бизнес объекты” 
  располагаются полностью отдельной машине. Такое централизованное расположение 
  бизнес правил позволяет изменениям происходить мгновенно для всех новых транзакций, 
  и поэтому оно является лучшим способом построения системы. Однако такие бизнес 
  объекты могут использоваться во многих различный приложениях и, поэтому, не 
  должны привязываться к определенному режиму отображения. Они просто должны выполнять 
  бизнес операции и ничего более.</font></p>
<p><font face="Georgia">Следующий пример показывает, как легко разделяется бизнес 
  логика и GUI код:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:Separation.java</font>
<font color="#009900">// Разделение GUI логики и бизнес объектов.</font>
<font color="#009900">// &lt;applet code=Separation</font>
<font color="#009900">// width=250 height=150&gt; &lt;/applet&gt;</font>
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> javax.swing.event.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.applet.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">class</font> BusinessLogic {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> modifier;
  <font color="#0000ff">public</font> BusinessLogic(<font color="#0000ff">int</font> mod) {
    modifier = mod;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setModifier(<font color="#0000ff">int</font> mod) {
    modifier = mod;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">int</font> getModifier() {
    <font color="#0000ff">return</font> modifier;
  }
  <font color="#009900">// Какие-то бизнес операции:</font>
  <font color="#0000ff">public</font> <font color="#0000ff">int</font> calculation1(<font color="#0000ff">int</font> arg) {
    <font color="#0000ff">return</font> arg * modifier;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">int</font> calculation2(<font color="#0000ff">int</font> arg) {
    <font color="#0000ff">return</font> arg + modifier;
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Separation <font color="#0000ff">extends</font> JApplet {
  JTextField 
    t = <font color="#0000ff">new</font> JTextField(15),
    mod = <font color="#0000ff">new</font> JTextField(15);
  BusinessLogic bl = <font color="#0000ff">new</font> BusinessLogic(2);
  JButton
    calc1 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Calculation 1"</font>),
    calc2 = <font color="#0000ff">new</font> JButton(<font color="#004488">"Calculation 2"</font>);
  <font color="#0000ff">static</font> <font color="#0000ff">int</font> getValue(JTextField tf) {
    <font color="#0000ff">try</font> {
      <font color="#0000ff">return</font> Integer.parseInt(tf.getText());
    } <font color="#0000ff">catch</font>(NumberFormatException e) {
      <font color="#0000ff">return</font> 0;
    }
  }
  <font color="#0000ff">class</font> Calc1L <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t.setText(Integer.toString(
        bl.calculation1(getValue(t))));
    }
  }
  <font color="#0000ff">class</font> Calc2L <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      t.setText(Integer.toString(
        bl.calculation2(getValue(t))));
    }
  }
  <font color="#009900">// Если вы хотите, чтобы что-то происходило при</font>
  <font color="#009900">// изменении JTextField, добавьте слушатель:</font>
  <font color="#0000ff">class</font> ModL <font color="#0000ff">implements</font> DocumentListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> changedUpdate(DocumentEvent e) {}
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> insertUpdate(DocumentEvent e) {
      bl.setModifier(getValue(mod));
    }
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> removeUpdate(DocumentEvent e) {
      bl.setModifier(getValue(mod));
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color="#0000ff">new</font> FlowLayout());
    cp.add(t);
    calc1.addActionListener(<font color="#0000ff">new</font> Calc1L());
    calc2.addActionListener(<font color="#0000ff">new</font> Calc2L());
    JPanel p1 = <font color="#0000ff">new</font> JPanel();
    p1.add(calc1); 
    p1.add(calc2);
    cp.add(p1);
    mod.getDocument().
      addDocumentListener(<font color="#0000ff">new</font> ModL());
    JPanel p2 = <font color="#0000ff">new</font> JPanel();
    p2.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Modifier:"</font>));
    p2.add(mod);
    cp.add(p2);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> Separation(), 250, 100);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Вы можете видеть, что <b>BusinessLogic</b> является четко 
  очерченным классом, который выполняет свои операции даже не подозревая, что 
  может быть GUI окружение. Он просто делает свою работу.</font></p>
<p><font face="Georgia"><b>Separation</b> следит за всеми деталями UI, и общается 
  с <b>BusinessLogic</b> только через публичный интерфейс. Все операции собираются 
  вокруг обмена информацией между интерфейсом пользователя и объектом <b>BusinessLogic</b>. 
  Таким образом, <b>Separation</b>, в итоге, просто делает свою работу. Так как 
  <b>Separation</b> знает только то, что он общается с объектом <b>BusinessLogic</b> 
  (то есть, они не сильно связаны), он может общаться с другими типами объектов 
  без особых затруднений.</font></p>
<p><font face="Georgia">Думая в терминах разделения UI от бизнес логики, можно 
  облегчить жизнь, когда вы адаптируете унаследованный код для работы с Java.</font><a name="_Toc481064835"></a></p>
<div align="left"></div>
<a name="Heading470"></a><font face="Verdana">
<h3 align="left"> Каноническая форма</h3>
</font> 
<p><font face="Georgia">Внутренние классы, модель событий Swing и, фактически 
  то, что старая модель событий все еще поддерживается наряду с новыми особенностями 
  библиотеки, которые полагаются на программирование в старом стиле, внесли новый 
  элемент путаницы в процесс разработки кода. Теперь есть больше способов для 
  людей писать неприятный код.</font></p>
<p><font face="Georgia">Кроме случаев, объясняемых обстоятельствами, вы должны 
  всегда использовать простейший и ясный подход: <a name="Index1800"></a>классы 
  слушателей (обычно пишущиеся как <a name="Index1801"></a><a name="Index1802"></a>внутренние 
  классы) для решения ваших требований по обработке событий. Эта форма используется 
  в большинстве примеров в этой главе.</font></p>
<p><font face="Georgia">Следуя этой модели вы должны быть способны уменьшить инструкции 
  в вашей программе, который говорят: “Я удивлен, что произошло это событие”. 
  Каждый кусочек кода не должен заниматься проверкой типа. Это лучший способ написания 
  вашего кода; те только потому, что это легче концептуально, но и легче при чтении 
  и уходе.</font><a name="_Toc481064836"></a></p>
<div align="left"></div>
<a name="Heading471"></a> <font face="Verdana">
<h2 align="left">Визуальное программирование и компоненты (Beans)<a name="Index1804"></a></h2>
</font> 
<p><font face="Georgia">Далее в этой книге вы увидите, как ценен Java для создания 
  кусочков кода для повторного использования. “Наиболее часто используемый” 
  блок кода имеет класс, так как он включает связующий модуль характеристик (полей) 
  и поведений (методов), которые могут быть повторно использованы либо напрямую 
  через композицию, либо через наследование.</font></p>
<p><font face="Georgia">Наследование и полиморфизм - это главные части объектно-ориентированного 
  программирования, но для большинства классов, когда вы помещаете их вместе в 
  приложение, то, что вы хотите - это то, чтобы компоненты точно делали то, что 
  вам нужно. Вы можете ввести эти части в вашу разработку, как инженер-электронщик 
  помещает вместе микросхемы на плате. Кажется, что должен быть способ для ускорения 
  такого стиля программирования “модульной сборки”.</font></p>
<p><a name="Index1806"></a><a name="Index1807"></a><a name="Index1808"></a><a name="Index1809"></a><a name="Index1810"></a><a name="Index1811"></a><a name="Index1812"></a><a name="Index1813"></a><font face="Georgia">Первый 
  успешный опыт “визуального программирования” — очень успешный 
  — был получен с Visual Basic (VB) фирмы Microsoft, далее, среда второго 
  поколения - это Delphi от Borland (главный вдохновитель дизайна JavaBeans). 
  С этими инструментами программирования компоненты представлялись визуально, 
  как кнопки или текстовые поля. Визуальное представление, фактически, часто является 
  точным способом показа компонента в работающей программе. Так что часть процесса 
  визуального программирования затрагивает перетаскивание компонент из палитры 
  и помещение их в вашу форму. <a name="Index1814"></a><a name="Index1815"></a>Инструмент 
  построения приложения пишет код за вас, и этот код является причиной создания 
  компонент в работающей программе.</font></p>
<p><font face="Georgia">Простого помещения компонент в форму обычно не достаточно 
  для компиляции программ. Часто вы должны изменить характеристики компонент, 
  такие как цвет, внутренний текст, присоединенную базу данных и т.п. Характеристики, 
  которые могут быть изменены во время дизайна, называются <a name="Index1816"></a><a name="Index1817"></a><i>свойствами</i> 
  (properties). Вы можете манипулировать свойствами вашего компонента внутри построителя 
  приложения, и когда вы создадите программу, эти конфигурационные данные будут 
  сохранены, так что они могут быть обновлены при запуске программы.</font></p>
<p><font face="Georgia">Теперь вы, вероятно, используете идею, что объект - это 
  больше, чем характеристики; это также набор поведений. Во время дизайна, поведение 
  визуальных компонент частично представлено <a name="Index1818"></a><a name="Index1819"></a><i>событиями</i> 
  (events), означающих “Здесь то, что может случиться с компонентом”. 
  Обычно вы решаете, что вам нужно при возникновении события, печатая код этого 
  события. </font></p>
<p><a name="Index1820"></a><a name="Index1821"></a><font face="Georgia">Здесь 
  заключена критическая часть: построитель приложения использует рефлексию для 
  динамического исследования компоненты для нахождения свойств, чтобы позволить 
  вам изменить их (записать состояние при построении программы), а также для отображения 
  событий. В общем, вы делаете что-то типа двойного щелчка на событии, и построитель 
  приложения создает тело кода и привязывает его к определенному событию. Все, 
  что вы делаете в этом месте, это пишите код, выполняющийся при возникновении 
  события.</font></p>
<p><font face="Georgia">Все это прибавляет работы, которую выполняет за вас построитель 
  приложения. В результате вы можете сфокусировать внимание на том, как программа 
  должна выглядеть, и для чего она предназначена, и положится на построитель приложения 
  в управлении деталями. По этой причине инструменты визуального программирования 
  так успешно применяются, они значительно ускоряют процесс построения приложения 
  — в основном интерфейса пользователя, но часто и других частей приложения.</font><a name="_Toc481064837"></a></p>
<div align="left"></div>
<a name="Heading472"></a><font face="Verdana">
<h3 align="left"> Что такое компонент (Bean)?<a name="Index1822"></a><a name="Index1823"></a></h3>
</font> 
<p><font face="Georgia">После того, как осядет пыль, компонент представляет собой 
  блок кода, обычно, заключенного в класс. Ключевая способность построителя приложения 
  состоит в обнаружении свойств и событий компонента. Для создания VB компонент 
  программист должен написать довольно сложный кусок кода, следуя определенным 
  соглашениям для выделения свойств и событий. Delphi был визуальным инструментом 
  программирования второго поколения, и дизайн языка был построен исходя из простоты 
  построения и использования визуальных компонент. Однако Java стал использовать 
  создание визуальных компонент наиболее продвинутым способом с помощью JavaBeans, 
  потому что компонент (Bean) - это просто класс. Вам не нужно писать дополнительный 
  код или использовать специальное расширение языка для создания какого-нибудь 
  компонента. Фактически, вам необходимо сделать только одну вещь: слегка модифицировать 
  способ, которым вы создаете названия методов. То есть использовать имя метода, 
  которое скажет построителю приложения, является ли он свойством, событием или 
  просто обычным методом.</font></p>
<p><a name="Index1824"></a><font face="Georgia">В документации по Java это соглашение 
  об именах ошибочно называется “шаблон разработки (design pattern)”. 
  Это не удачно, так как шаблоны разработки (смотрите <i>Thinking in Patterns 
  with Java</i>, доступной на <i>www.BruceEckel.com</i>) и так оспариваются и 
  без этой путаницы. Это не шаблоны разработки, это просто соглашение об именах 
  и оно достаточно простое:</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Для свойства с именем 
    <b>xxx</b> вы обычно создаете два метода: <b>getXxx(&nbsp;)</b> и <b>setXxx(&nbsp;)</b>. 
    Обратите внимание, что первая буква после “get” или “set” 
    автоматически преобразуется к нижнему регистру для получения имени свойства. 
    Тип, производимый методом “get” должен быть тем же самым, что 
    и тип аргумента в методе “set”. Имя свойcтва и тип для “get” 
    и “set” не связаны.</font> 
  </li><li><font face="Verdana"> </font><font face="Georgia">Для свойства типа <b>boolean</b> 
    вы можете использовать подход для “get” и “set”, описанный 
    выше, но вы также можете использовать “is” вместо “get”.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Обычные методы компонента 
    (Bean) не удовлетворяют соглашению об именах, но они публичные (</font><font face="Georgia"><b>public</b>).</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Для событий вы используете 
    подход “слушателей” из Swing. Он точно такой же, как вы видели: 
    <b>addFooBarListener(FooBarListener)</b> и <b>removeFooBarListener(FooBarListener)</b> 
    для обработки <b>FooBarEvent</b>. Чаше всего для ваших нужд подойдут встроенные 
    события и слушатели, но вы можете также создать свои собственные события и 
    интерфейсы слушателей.</font> 
</li></ol>
<p><font face="Georgia">Пункт 1 отвечает на вопрос о том, что вы могли заметить, 
  когда просматривали код в старом стиле и код в новом стиле: число имен методов 
  стало меньше, и иметь явно осмысленный характер. Теперь вы видите, что большинство 
  из этих изменений были сделаны для адаптации к соглашению об именах в отношении 
  “get” и “set”, чтобы встроить определенный компонент 
  в </font><font face="Georgia"> Bean.</font></p>
<p>Мы может использовать это руководство для создания простого компонента (Bean):</p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: frogbean:Frog.java</font>
<font color="#009900">// Тривиальный JavaBean.</font>
<font color="#0000ff">package</font> frogbean;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;

<font color="#0000ff">class</font> Spots {}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Frog {
  <font color="#0000ff">private</font> <font color="#0000ff">int</font> jumps;
  <font color="#0000ff">private</font> Color color;
  <font color="#0000ff">private</font> Spots spots;
  <font color="#0000ff">private</font> <font color="#0000ff">boolean</font> jmpr;
  <font color="#0000ff">public</font> <font color="#0000ff">int</font> getJumps() { <font color="#0000ff">return</font> jumps; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setJumps(<font color="#0000ff">int</font> newJumps) { 
    jumps = newJumps;
  }
  <font color="#0000ff">public</font> Color getColor() { <font color="#0000ff">return</font> color; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setColor(Color newColor) { 
    color = newColor; 
  }
  <font color="#0000ff">public</font> Spots getSpots() { <font color="#0000ff">return</font> spots; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setSpots(Spots newSpots) {
    spots = newSpots; 
  }
  <font color="#0000ff">public</font> <font color="#0000ff">boolean</font> isJumper() { <font color="#0000ff">return</font> jmpr; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setJumper(<font color="#0000ff">boolean</font> j) { jmpr = j; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> addActionListener(
      ActionListener l) {
    <font color="#009900">//...</font>
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> removeActionListener(
      ActionListener l) {
    <font color="#009900">// ...</font>
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> addKeyListener(KeyListener l) {
    <font color="#009900">// ...</font>
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> removeKeyListener(KeyListener l) {
    <font color="#009900">// ...</font>
  }
  <font color="#009900">// "Обычный" публичный метод:</font>
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> croak() {
    System.out.println(<font color="#004488">"Ribbet!"</font>);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Прежде всего, вы можете видеть, что это просто класс. 
  Обычно все ваши поля будут <b>private</b>, и доступны только через методы. Следуя 
  соглашению об именах, получим свойства <b>jumps</b>, <b>color</b>, <b>spots</b> 
  и <b>jumper</b> (обратите внимание на регистр первой буквы имени свойства). 
  Хотя имя внутреннего идентификатора такое же, как и имя свойства в первых трех 
  случаях, в <b>jumper</b> вы можете видеть, что имя свойства не ограничивает 
  вас в использовании определенного идентификатора для внутренней переменной (или, 
  на самом деле, даже <i>иметь</i> любые внутренние переменные для этого свойства).</font></p>
<p><font face="Georgia">События, обрабатываемые этим компонентом, это <b>ActionEvent</b> 
  и <b>KeyEvent</b>, основываются на наименовании методов “add” и 
  “remove” для ассоциированного слушателя. И, наконец, вы можете видеть, 
  что обычный метод <b>croak(&nbsp;)</b> все еще является частью компонента, потому 
  что это <b>public</b> метод, а не потому, что он удовлетворяет какой-то схеме 
  названий.</font><a name="_Toc481064838"></a></p>
<div align="left"></div>
<a name="Heading473"></a><font face="Verdana">
<h3 align="left"> Извлечение BeanInfo с помощью Инспектора</h3>
</font> 
<p><font face="Georgia">Одна из наиболее критичных частей компонентной схемы возникает, 
  когда вы перетаскиваете компонент (Bean) из палитры и бросаете его в форму. 
  Построитель приложения должен быть способен создать компонент (Bean) (что выполняется 
  с помощью конструктора по умолчанию), а затем, без доступа к исходному коду 
  компонента (Bean), получить всю необходимую информацию для создания страничек 
  свойств и обработчиков событий.</font></p>
<p>Часть решения ясно видна в конце <a href=" Chapter12.html">Главы 12</a>: <font face="Georgia"><a name="Index1825"></a><a name="Index1826"></a></font><i>рефлексия</i> 
  Java позволяет обнаружить все методы анонимных классов. Это совершенное решение 
  проблемы компонента (Bean) без введения любых дополнительных ключевых слов, 
  которые требуются в других визуальных языках программирования. Фактически, одна 
  из главнейших причин добавления рефлексии в Java была в поддержке компонентов 
  (Bean) (хотя рефлексия также поддерживает сериализацию объектов и удаление обращений 
  к методам). Так что вы можете ожидать, что создатель построителя приложения 
  будет рефлектировать каждый компонент (Bean) и охотится за его методами для 
  нахождения свойств и событий для этого компонента (Bean).</p>
<p><font face="Georgia">Это, конечно, возможно, но разработчики Java хотели обеспечить 
  стандартный инструмент, не только для упрощения использования компонент (Bean), 
  но и для обеспечения стандартного подхода для создания более сложных компонент 
  (Bean). Этим инструментом является класс <a name="Index1827"></a><a name="Index1828"></a><b>Introspector</b>, 
  и наиболее важным методом этого класса является <b>static <a name="Index1829"></a><a name="Index1830"></a>getBeanInfo(&nbsp;)</b>. 
  Вы передаете ссылку на <b>Class</b> в этот метод, и он полностью опрашивает 
  этот класс и возвращает объект <b>BeanInfo</b>, который вы можете затем раскрыть 
  для нахождения свойств, методов и србытий.</font></p>
<p><font face="Georgia">Обычно вы не заботитесь об этом — вероятно, вы получите 
  большинство ваших компонентов (Bean) от продавца, и вам не нужно будет знать 
  всю магию, которая происходит внутри. Вы просто перетаскиваете ваш компонент 
  (Bean) на вашу форму, затем конфигурируете его свойства и пишите обработчик 
  для интересующих вас событий. Однако очень интересно и познавательно использовать 
  <b>Introspector</b> для отображения информации о компоненте (bean), так что 
  вот инструмент, который делает это</font><font face="Georgia">:</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:BeanDumper.java</font>
<font color="#009900">// Инспектирование Bean.</font>
<font color="#009900">// &lt;applet code=BeanDumper width=600 height=500&gt;</font>
<font color="#009900">// &lt;/applet&gt;</font>
<font color="#0000ff">import</font> java.beans.*;
<font color="#0000ff">import</font> java.lang.reflect.*;
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> BeanDumper <font color="#0000ff">extends</font> JApplet {
  JTextField query = 
    <font color="#0000ff">new</font> JTextField(20);
  JTextArea results = <font color="#0000ff">new</font> JTextArea();
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> prt(String s) {
    results.append(s + <font color="#004488">"\n"</font>);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> dump(Class bean){
    results.setText(<font color="#004488">""</font>);
    BeanInfo bi = <font color="#0000ff">null</font>;
    <font color="#0000ff">try</font> {
      bi = Introspector.getBeanInfo(
        bean, java.lang.Object.<font color="#0000ff">class</font>);
    } <font color="#0000ff">catch</font>(IntrospectionException e) {
      prt(<font color="#004488">"Couldn't introspect "</font> + 
        bean.getName());
      <font color="#0000ff">return</font>;
    }
    PropertyDescriptor[] properties = 
      bi.getPropertyDescriptors();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; properties.length; i++) {
      Class p = properties[i].getPropertyType();
      prt(<font color="#004488">"Property type:\n  "</font> + p.getName() +
        <font color="#004488">"Property name:\n  "</font> + 
        properties[i].getName());
      Method readMethod = 
        properties[i].getReadMethod();
      <font color="#0000ff">if</font>(readMethod != <font color="#0000ff">null</font>)
        prt(<font color="#004488">"Read method:\n  "</font> + readMethod);
      Method writeMethod = 
        properties[i].getWriteMethod();
      <font color="#0000ff">if</font>(writeMethod != <font color="#0000ff">null</font>)
        prt(<font color="#004488">"Write method:\n  "</font> + writeMethod);
      prt(<font color="#004488">"===================="</font>);
    }
    prt(<font color="#004488">"Public methods:"</font>);
    MethodDescriptor[] methods =
      bi.getMethodDescriptors();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; methods.length; i++)
      prt(methods[i].getMethod().toString());
    prt(<font color="#004488">"======================"</font>);
    prt(<font color="#004488">"Event support:"</font>);
    EventSetDescriptor[] events = 
      bi.getEventSetDescriptors();
    <font color="#0000ff">for</font>(<font color="#0000ff">int</font> i = 0; i &lt; events.length; i++) {
      prt(<font color="#004488">"Listener type:\n  "</font> +
        events[i].getListenerType().getName());
      Method[] lm = 
        events[i].getListenerMethods();
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; lm.length; j++)
        prt(<font color="#004488">"Listener method:\n  "</font> +
          lm[j].getName());
      MethodDescriptor[] lmd = 
        events[i].getListenerMethodDescriptors();
      <font color="#0000ff">for</font>(<font color="#0000ff">int</font> j = 0; j &lt; lmd.length; j++)
        prt(<font color="#004488">"Method descriptor:\n  "</font> +
          lmd[j].getMethod());
      Method addListener = 
        events[i].getAddListenerMethod();
      prt(<font color="#004488">"Add Listener Method:\n  "</font> +
          addListener);
      Method removeListener =
        events[i].getRemoveListenerMethod();
      prt(<font color="#004488">"Remove Listener Method:\n  "</font> +
        removeListener);
      prt(<font color="#004488">"===================="</font>);
    }
  }
  <font color="#0000ff">class</font> Dumper <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e) {
      String name = query.getText();
      Class c = <font color="#0000ff">null</font>;
      <font color="#0000ff">try</font> {
        c = Class.forName(name);
      } <font color="#0000ff">catch</font>(ClassNotFoundException ex) {
        results.setText(<font color="#004488">"Couldn't find "</font> + name);
        <font color="#0000ff">return</font>;
      }
      dump(c);
    }
  }      
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    Container cp = getContentPane();
    JPanel p = <font color="#0000ff">new</font> JPanel();
    p.setLayout(<font color="#0000ff">new</font> FlowLayout());
    p.add(<font color="#0000ff">new</font> JLabel(<font color="#004488">"Qualified bean name:"</font>));
    p.add(query);
    cp.add(BorderLayout.NORTH, p);
    cp.add(<font color="#0000ff">new</font> JScrollPane(results));
    Dumper dmpr = <font color="#0000ff">new</font> Dumper();
    query.addActionListener(dmpr);
    query.setText(<font color="#004488">"frogbean.Frog"</font>);
    <font color="#009900">// Навязываем определение</font>
    dmpr.actionPerformed(
      <font color="#0000ff">new</font> ActionEvent(dmpr, 0, <font color="#004488">""</font>));
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> BeanDumper(), 600, 500);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia"><b>BeanDumper.dump(&nbsp;)</b> - это метод, который делает 
  всю работу. Сначала он пробует создать объект <b>BeanInfo</b>, и если это происходит 
  успешно, вызывает метод <b>BeanInfo</b>, который производит информацию о свойствах, 
  методах и событиях. В <b>Introspector.getBeanInfo(&nbsp;)</b>, вы увидите второй 
  аргумент. Это говорит <b>Introspector,</b> где остановится в иерархии наследования. 
  Здесь он остановится прежде, чем разберет все методы от <b>Object</b>, так как 
  мы не интересуемся ими.</font></p>
<p><font face="Georgia">Для свойств: <a name="Index1831"></a><a name="Index1832"></a><b>getPropertyDescriptors(&nbsp;)</b> 
  возвращает массив из <a name="Index1833"></a><a name="Index1834"></a><b>PropertyDescriptor</b>. 
  Для каждого <b>PropertyDescriptor</b> вы можете вызвать <a name="Index1835"></a><a name="Index1836"></a><b>getPropertyType(&nbsp;)</b> 
  для нахождения класса объекта, который передается и получается через методы 
  свойства. Затем, для каждого свойства вы можете получить псевдоним (получается 
  из имени метода) с помощью <a name="Index1837"></a><a name="Index1838"></a><b>getName(&nbsp;)</b>, 
  метод для чтения с помощью <a name="Index1839"></a><a name="Index1840"></a><b>getReadMethod(&nbsp;)</b>, 
  и метод для записи с помощью <a name="Index1841"></a><a name="Index1842"></a><b>getWriteMethod(&nbsp;)</b>. 
  Последние два метода возвращают объект <b>Method</b>, который может на самом 
  деле использоваться для вызова соответствующего метода объекта (это часть рефлексии).</font></p>
<p><font face="Georgia">Для <b>public</b> методов (включая методы свойств) <a name="Index1843"></a><a name="Index1844"></a><b>getMethodDescriptors(&nbsp;)</b> 
  возвращает массив <b>MethodDescriptor</b>. Для каждого их них вы можете получить 
  ассоциированный объект <a name="Index1847"></a><a name="Index1848"></a><b>Method</b> 
  и напечатать его имя.</font></p>
<p><font face="Georgia">Для событий <a name="Index1849"></a><a name="Index1850"></a><b>getEventSetDescriptors(&nbsp;)</b> 
  возвращает массив (как вы думаете, чего?) <a name="Index1851"></a><a name="Index1852"></a><b>EventSetDescriptor</b>. 
  Каждый элемент массива может быть опрошен для нахождения класса слушателя, методов 
  класса слушателя и методов добавления (add-) и удаления (remove-). Программа 
  <b>BeanDumper</b> печатает всю эту информацию.</font></p>
<p><font face="Georgia">После запуска программа форсирует вычисления <b>frogbean.Frog</b>. 
  То, что получается на выходе, после удаления дополнительных деталей, ненужных 
  здесь, вы видите здесь:</font></p>
<blockquote><font size="+1">
  </font><pre><font size="+1"><font color="#0000ff">class</font> name: Frog
Property type:
  Color
Property name:
  color
Read method:
  <font color="#0000ff">public</font> Color getColor()
Write method:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setColor(Color)
====================
Property type:
  Spots
Property name:
  spots
Read method:
  <font color="#0000ff">public</font> Spots getSpots()
Write method:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setSpots(Spots)
====================
Property type:
  <font color="#0000ff">boolean</font>
Property name:
  jumper
Read method:
  <font color="#0000ff">public</font> <font color="#0000ff">boolean</font> isJumper()
Write method:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setJumper(<font color="#0000ff">boolean</font>)
====================
Property type:
  <font color="#0000ff">int</font>
Property name:
  jumps
Read method:
  <font color="#0000ff">public</font> <font color="#0000ff">int</font> getJumps()
Write method:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setJumps(<font color="#0000ff">int</font>)
====================
Public methods:
<font color="#0000ff">public</font> <font color="#0000ff">void</font> setJumps(<font color="#0000ff">int</font>)
<font color="#0000ff">public</font> <font color="#0000ff">void</font> croak()
<font color="#0000ff">public</font> <font color="#0000ff">void</font> removeActionListener(ActionListener)
<font color="#0000ff">public</font> <font color="#0000ff">void</font> addActionListener(ActionListener)
<font color="#0000ff">public</font> <font color="#0000ff">int</font> getJumps()
<font color="#0000ff">public</font> <font color="#0000ff">void</font> setColor(Color)
<font color="#0000ff">public</font> <font color="#0000ff">void</font> setSpots(Spots)
<font color="#0000ff">public</font> <font color="#0000ff">void</font> setJumper(<font color="#0000ff">boolean</font>)
<font color="#0000ff">public</font> <font color="#0000ff">boolean</font> isJumper()
<font color="#0000ff">public</font> <font color="#0000ff">void</font> addKeyListener(KeyListener)
<font color="#0000ff">public</font> Color getColor()
<font color="#0000ff">public</font> <font color="#0000ff">void</font> removeKeyListener(KeyListener)
<font color="#0000ff">public</font> Spots getSpots()
======================
Event support:
Listener type:
  KeyListener
Listener method:
  keyTyped
Listener method:
  keyPressed
Listener method:
  keyReleased
Method descriptor:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> keyTyped(KeyEvent)
Method descriptor:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> keyPressed(KeyEvent)
Method descriptor:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> keyReleased(KeyEvent)
Add Listener Method:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> addKeyListener(KeyListener)
Remove Listener Method:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> removeKeyListener(KeyListener)
====================
Listener type:
  ActionListener
Listener method:
  actionPerformed
Method descriptor:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent)
Add Listener Method:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> addActionListener(ActionListener)
Remove Listener Method:
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> removeActionListener(ActionListener)
====================</font></pre>
<font size="+1">  </font></blockquote>
<p><font face="Georgia">Вот большая часть того, что видит и производит <b>Introspector</b> 
  в качестве объекта <b>BeanInfo</b> для вашего компонента (Bean). Вы можете видеть, 
  что тип свойств и их имена независимы. Обратите внимание на нижний регистр в 
  имени свойства. (Это не случается, когда имя свойства начинается с более чем 
  одной большой буквы в строке.) Запомните, что имена методов, которые вы видите 
  здесь (такие как методы чтения и записи), на самом деле произведены объектом 
  <b>Method</b>, который может быть использован для вызова ассоциированного метода 
  объекта.</font></p>
<p><font face="Georgia">Список <b>public</b> методов включает методы, которые 
  не связаны со свойствами или событиями, такие как <b>croak(&nbsp;)</b>. Здесь 
  все методы, которые вы можете вызвать программно для компонента (Bean), и построитель 
  приложения может выбрать список всех, когда вы выполняете вызов метода, для 
  облегчения вашей задачи.</font></p>
<p><font face="Georgia">Наконец, вы можете видеть события, передающиеся в слушатели, 
  </font><font face="Georgia">методы слушателей, и методы добавления и удаления 
  слушателей. В общем, так как вы имеете <b>BeanInfo</b>, вы можете найти все, 
  что важно для компонента (Bean). Вы можете также вызвать методы для этого компонента 
  (Bean), даже если у вас нет другой информации, за исключением объекта (опять 
  с помощью рефлексии).</font><a name="_Toc481064839"></a></p>
<div align="left"></div>
<a name="Heading474"></a> <font face="Verdana">
<h3 align="left">Более изощренные компоненты (Bean)</h3>
</font> 
<p><font face="Georgia">Этот следующий пример немного более изощренный, хотя фривольный. 
  Есть <b>JPanel</b>, которая рисует маленькую окружность вокруг мыши, куда бы 
  мышь не переместилась. Когда вы нажимаете кнопку, появляется “Bang!” 
  в середине экрана, и возбуждается слушатель события.</font></p>
<p><font face="Georgia">Свойства, которые вы можете менять, это размер окружности, 
  точно так же как и цвет, размер и текст слова, которое отображается при нажатии 
  кнопки. <b>BangBean</b> также имеет свой собственный <a name="Index1853"></a><b>addActionListener(&nbsp;)</b> 
  и <a name="Index1854"></a><b>removeActionListener(&nbsp;)</b>, так что вы можете 
  присоединять свой собственный слушатель, который будет обрабатывать щелчки мыши 
  в <b>BangBean</b>. Вы должны быть способны распознать свойства и поддержку событий:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  <pre><font color="#009900">//: bangbean:BangBean.java</font>
<font color="#009900">// Графический Bean.</font>
<font color="#0000ff">package</font> bangbean;
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.io.*;
<font color="#0000ff">import</font> java.util.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> BangBean <font color="#0000ff">extends</font> JPanel
     <font color="#0000ff">implements</font> Serializable {
  <font color="#0000ff">protected</font> <font color="#0000ff">int</font> xm, ym;
  <font color="#0000ff">protected</font> <font color="#0000ff">int</font> cSize = 20; <font color="#009900">// Размер окружности</font>
  <font color="#0000ff">protected</font> String text = <font color="#004488">"Bang!"</font>;
  <font color="#0000ff">protected</font> <font color="#0000ff">int</font> fontSize = 48;
  <font color="#0000ff">protected</font> Color tColor = Color.red;
  <font color="#0000ff">protected</font> ActionListener actionListener;
  <font color="#0000ff">public</font> BangBean() {
    addMouseListener(<font color="#0000ff">new</font> ML());
    addMouseMotionListener(<font color="#0000ff">new</font> MML());
  }
  <font color="#0000ff">public</font> <font color="#0000ff">int</font> getCircleSize() { <font color="#0000ff">return</font> cSize; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setCircleSize(<font color="#0000ff">int</font> newSize) {
    cSize = newSize;
  }
  <font color="#0000ff">public</font> String getBangText() { <font color="#0000ff">return</font> text; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setBangText(String newText) {
    text = newText;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">int</font> getFontSize() { <font color="#0000ff">return</font> fontSize; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setFontSize(<font color="#0000ff">int</font> newSize) {
    fontSize = newSize;
  }
  <font color="#0000ff">public</font> Color getTextColor() { <font color="#0000ff">return</font> tColor; }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> setTextColor(Color newColor) {
    tColor = newColor;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> paintComponent(Graphics g) {
    <font color="#0000ff">super</font>.paintComponent(g);
    g.setColor(Color.black);
    g.drawOval(xm - cSize/2, ym - cSize/2, 
      cSize, cSize);
  }
  <font color="#009900">// Это уникальный слушатель, который</font>
  <font color="#009900">// является упрощенной формой управления слушателем:</font>
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> addActionListener (
      ActionListener l) 
        <font color="#0000ff">throws</font> TooManyListenersException {
    <font color="#0000ff">if</font>(actionListener != <font color="#0000ff">null</font>)
      <font color="#0000ff">throw</font> <font color="#0000ff">new</font> TooManyListenersException();
    actionListener = l;
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> removeActionListener(
      ActionListener l) {
    actionListener = <font color="#0000ff">null</font>;
  }
  <font color="#0000ff">class</font> ML <font color="#0000ff">extends</font> MouseAdapter {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> mousePressed(MouseEvent e) {
      Graphics g = getGraphics();
      g.setColor(tColor);
      g.setFont(
        <font color="#0000ff">new</font> Font(
          <font color="#004488">"TimesRoman"</font>, Font.BOLD, fontSize));
      <font color="#0000ff">int</font> width = 
        g.getFontMetrics().stringWidth(text);
      g.drawString(text, 
        (getSize().width - width) /2,
        getSize().height/2);
      g.dispose();
      <font color="#009900">// Вызов метода слушателя:</font>
      <font color="#0000ff">if</font>(actionListener != <font color="#0000ff">null</font>)
        actionListener.actionPerformed(
          <font color="#0000ff">new</font> ActionEvent(BangBean.<font color="#0000ff">this</font>,
            ActionEvent.ACTION_PERFORMED, <font color="#0000ff">null</font>));
    }
  }
  <font color="#0000ff">class</font> MML <font color="#0000ff">extends</font> MouseMotionAdapter {
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> mouseMoved(MouseEvent e) {
      xm = e.getX();
      ym = e.getY();
      repaint();
    }
  }
  <font color="#0000ff">public</font> Dimension getPreferredSize() {
    <font color="#0000ff">return</font> <font color="#0000ff">new</font> Dimension(200, 200);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Первое, что вы заметите, это то, что <b>BangBean</b> реализует 
  интерфейс <a name="Index1855"></a><a name="Index1856"></a><b>Serializable</b>. 
  Это значит, что построитель приложения может “законсервировать” 
  всю информацию для <b>BangBean</b>, используя сериализацию, после того, как 
  дизайнер установит значения свойств. Когда компонент (Bean) создастся как часть 
  работающего приложения, эти “законсервированные” свойства восстанавливаются, 
  так что вы получаете точно то, что разрабатывали.</font></p>
<p><font face="Georgia">Вы можете видеть, что все поля являются <b>private</b>, 
  это то, что вы обычно делаете с компонентами, позволяя получить доступ только 
  через методы, обычно, используя схему “property”.</font></p>
<p><font face="Georgia">Когда вы взглянете на сигнатуру <b>addActionListener(&nbsp;)</b>, 
  вы увидите, что он может выбрасывать <a name="Index1857"></a><b>TooManyListenersException</b>. 
  Это означает, что здесь <a name="Index1858"></a><i>индивидуальная</i> (<i>unicast</i>) 
  обработка, которая означает, что извещается только один слушатель о возникновении 
  события. Обычно вы будете использовать <a name="Index1859"></a><i>групповые</i> 
  (<i>multicast</i>) события, так что много слушателей могут быть извещены о событии. 
  Однако это вводит нас в область, которую вы не готовы воспринять до следующей 
  главы, так что мы вернемся к этому (под заголовком “возврат к JavaBeans”). 
  Индивидуальная обработка обходит проблему.</font></p>
<p><font face="Georgia">Когда вы щелкаете мышью, текст помещается в центр <b>BangBean</b>, 
  а если поле <b>actionListener</b> не <b>null</b>, вызывается <b>actionPerformed(&nbsp;)</b>, 
  в процессе создается новый объект <a name="Index1860"></a><b>ActionEvent</b>. 
  Куда бы мышь не переместилась, захватываются новые координаты, и происходит 
  перерисовка канвы (стирание любого текста, расположенного на канве, как вы увидите).</font></p>
<p><font face="Georgia">Здесь приведен класс <b>BangBeanTest</b>, позволяющий 
  вам проверить компонент либо как апплет, либо как приложение:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  <pre><font color="#009900">//: c13:BangBeanTest.java</font>
<font color="#009900">// &lt;applet code=BangBeanTest </font>
<font color="#009900">// width=400 height=500&gt;&lt;/applet&gt;</font>
<font color="#0000ff">import</font> bangbean.*;
<font color="#0000ff">import</font> javax.swing.*;
<font color="#0000ff">import</font> java.awt.*;
<font color="#0000ff">import</font> java.awt.event.*;
<font color="#0000ff">import</font> java.util.*;
<font color="#0000ff">import</font> com.bruceeckel.swing.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> BangBeanTest <font color="#0000ff">extends</font> JApplet {
  JTextField txt = <font color="#0000ff">new</font> JTextField(20);
  <font color="#009900">// Во время тестирования отчет о действиях:</font>
  <font color="#0000ff">class</font> BBL <font color="#0000ff">implements</font> ActionListener {
    <font color="#0000ff">int</font> count = 0;
    <font color="#0000ff">public</font> <font color="#0000ff">void</font> actionPerformed(ActionEvent e){
      txt.setText(<font color="#004488">"BangBean action "</font>+ count++);
    }
  }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> init() {
    BangBean bb = <font color="#0000ff">new</font> BangBean();
    <font color="#0000ff">try</font> {
      bb.addActionListener(<font color="#0000ff">new</font> BBL());
    } <font color="#0000ff">catch</font>(TooManyListenersException e) {
      txt.setText(<font color="#004488">"Too many listeners"</font>);
    }
    Container cp = getContentPane();
    cp.add(bb);
    cp.add(BorderLayout.SOUTH, txt);
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Console.run(<font color="#0000ff">new</font> BangBeanTest(), 400, 500);
  }
} <font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Когда компонент (Bean) находится в среде разработки, этот 
  класс не будет использоваться, но полезно обеспечить тестирование метода для 
  каждого вашего компонента (Bean). <b>BangBeanTest</b> помещает <b>BangBean</b> 
  в апплет, присоединяет простой <b>ActionListener</b> к <b>BangBean</b> для печати 
  счетчика событий в <b>JTextField</b>, когда бы не возникло <b>ActionEvent</b>. 
  Конечно, обычно построитель приложения создает большинство кода, который использует 
  этот компонент (Bean).</font></p>
<p><font face="Georgia">Когда вы запустите </font> <font face="Georgia"> <b>BangBean</b> 
  через <b>BeanDumper</b>, или поместите <b>BangBean</b> внутрь среды разработки, 
  поддерживающей компоненты, вы заметите, что есть гораздо больше свойств и действий, 
  чем это видно в приведенном выше коде. Это происходит потому, что <b>BangBean</b> 
  наследуется от <b>JPanel</b>, а <b>JPanel </b>- это тоже компонент (Bean), так 
  что вы также видите его свойства и события.</font><a name="_Toc481064840"></a></p>
<div align="left"></div>
<a name="Heading475"></a><font face="Verdana">
<h3 align="left"> Помещение компонент в пакеты<a name="Index1861"></a><a name="Index1862"></a><a name="Index1863"></a><a name="Index1864"></a></h3>
</font> 
<p><font face="Georgia">Прежде, чем вы поместите компонент (Bean) в визуальный 
  построитель, поддерживающий компоненты, он должен быть помещен в стандартный 
  контейнер компонент (Bean), который является JAR файлом, включающим все классы 
  компонент (Bean) наряду с файлом “манифеста”, который говорит: “Это 
  компонент (Bean)”. Файл манифеста - это простой текстовый файл, который 
  следует определенной форме. Для <b>BangBean</b> файл манифеста выглядит так 
  (без первых и последних строчек):</font></p>
<blockquote><font size="+1">
  <pre><font color="#009900">//:! :BangBean.mf</font>
Manifest-Version: 1.0

Name: bangbean/BangBean.<font color="#0000ff">class</font>
Java-Bean: True
<font color="#009900">///:~</font></pre>
  </font></blockquote>
<p><font face="Georgia">Первая строка указывает версию схемы манифеста, которая 
  до особого уведомления от Sun, является 1.0. Вторая строка (пустые строки игнорируются) 
  указывает имя файла <b>BangBean.class</b>, а третья говорит: “Это компонент”. 
  Без третьей строки построитель программы не распознает класс, как компоненте 
  (Bean).</font></p>
<p><font face="Georgia">Сложность состоит только в том, что вы должны убедиться, 
  что вы получили правильный путь в поле “Name:”. Если вы снова взглянете 
  на <b>BangBean.java</b>, вы увидите его в <b>package bangbean </b>(и поэтому 
  поддиректорий, называемый bangbean” должен включаться в путь класса), 
  а имя в файле манифеста должно включать эту информацию о пакете. Кроме того, 
  вы должны поместить файл манифеста в директорию, перед корневым директорием 
  пути вашего пакета, что в этом случае означает помещение файла в директорий, 
  перед поддиректорием “bangbean”. Затем вы должны вызвать <b>jar</b> 
  из той же директории, в которой находится файл манифеста, как показано ниже</font><font face="Georgia">:</font></p>
<div align="left"></div>
<blockquote><font size="+1">
  <pre>jar cfm BangBean.jar BangBean.mf bangbean</pre>
  </font></blockquote>
<p><font face="Georgia">Здесь имеется в виду, что вы хотите в результате получить 
  JAR файл с именем <b>BangBean.jar</b> и что вы хотите поместить файл манифеста, 
  называемый <b>BangBean.mf</b>.</font></p>
<p><font face="Georgia">Вы можете удивиться: “Как насчет всех остальных 
  классов, которые были сгенерированы, когда я компилировал <b>BangBean.java</b>?” 
  Они все заключены в директории <b>bangbean</b>, и вы видите, что последний аргумент 
  для приведенной выше команды <b>jar</b> - это директорий <b>bangbean</b>. Когда 
  вы передаете <b>jar</b> имя поддиректории, он пакует весь поддиректорий в JAR 
  файл (включая, в этом случае, оригинальный файл исходного кода <b>BangBean.java</b> 
  — вы можете не включать исходный код вашего компонента). Кроме того, если 
  вы в последствии распакуете JAR файл, который вы только что создали, вы обнаружите, 
  что ваш манифест файл не находится внутри, а <b>jar</b> создал собственный манифест 
  файл (частично основываясь на вашем), называемый <b>MANIFEST.MF </b>и помещенный 
  в директории <b>META-INF</b> (для “meta-информации”). Если вы откроете 
  этот файл манифеста, вы увидите цифровую подпись информации, добавленной <b>jar 
  </b>для каждого файла, следующего вида:</font></p>
<blockquote><font size="+1">
  <pre>Digest-Algorithms: SHA MD5 
SHA-Digest: pDpEAG9NaeCx8aFtqPI4udSX/O0=
MD5-Digest: O4NcS1hE3Smnzlp2hj6qeg==</pre>
  </font></blockquote>
<p><font face="Georgia">В общем случае, вам не нужно беспокоится об этом, и если 
  вы сделаете изменения, вы можете просто изменить ваш оригинальный файл манифеста 
  и заново вызвать <b>jar</b> для создания нового JAR файла для вашего компонента 
  (Bean). Вы можете также добавить другой компонент (Bean) в JAR файл, просто 
  добавив информацию о нем в ваш файл манифеста.</font></p>
<p><font face="Georgia">Однако вы должны обратить внимание, что вы, вероятно, 
  захотите поместить каждый компонент (Bean) в свой собственный директорий, так 
  как когда вы создадите JAR файл, вы передадите утилите <b>jar</b> имя поддиректории, 
  а она поместит все в этой директории в JAR файл. Вы можете видеть, что <b>Frog</b> 
  и <b>BangBean</b> находятся в своих собственных директориях.</font></p>
<p><font face="Georgia">Как только вы получите ваш компонент правильно расположенным 
  в JAR файле, вы можете ввести его в среду построителя программ, поддерживающую 
  компоненты. Способ, которым вы можете сделать это, разнится для разных инструментов, 
  но Sun распространяет бесплатную тестовую основу для JavaBeans в своем “Beans 
  Development Kit” (BDK), называемом <a name="Index1865"></a><a name="Index1866"></a>beanbox”. 
  (BDK доступен на <i>java.sun.com/beans</i>.). Для помещения вашего компонента 
  в beanbox, скопируйте JAR файл в поддиректорий “jars” из BDK прежде, 
  чем вы запустите </font><font face="Georgia"> beanbox.</font><a name="_Toc481064841"></a></p>
<div align="left"></div>
<a name="Heading476"></a><font face="Verdana">
<h3 align="left"> Более сложная поддержка компонент (Bean)</h3>
</font> 
<p><font face="Georgia">Вы можете видеть, как удивительно просто создать компонент 
  (Bean). Но вы не ограничены тем, что вы видели здесь. Архитектура JavaBeans 
  обеспечивает простой способ входа, но вы можете также распространить ее на более 
  сложные ситуации. Эти ситуации выходят за пределы тем, рассматриваемых этой 
  книгой, но они будут коротко обозначены здесь. Вы можете найти более подробный 
  материал на </font><font face="Georgia"> <i>java.sun.com/beans</i>.</font></p>
<p><font face="Georgia">Одно из мест, где вы можете добавить изощренность - это 
  свойства (properties). Приведенный выше пример показывает только единичные свойства, 
  но также возможно представить различные свойства в массиве. Это называется <a name="Index1867"></a><a name="Index1868"></a><a name="Index1869"></a><i>индексированным 
  свойством </i>(indexed property). Вы просто обеспечиваете соответствующие методы 
  (опять таки, следую соглашению об именах методов), а <b>Introspector</b> определяет 
  их как индексированные свойства, так что ваш построитель приложения может отобразить 
  их соответственно.</font></p>
<p><font face="Georgia">Свойства могут быть <a name="Index1870"></a><a name="Index1871"></a><a name="Index1872"></a><i>граничными</i>, 
  что означает, что они будут уведомлять другие объекты через <b>PropertyChangeEvent</b>. 
  Другие объекты могут затем выбрать изменения себя, основываясь на изменении 
  компонента (Bean).</font></p>
<p><font face="Georgia">Свойства могут быть <a name="Index1873"></a><a name="Index1874"></a><a name="Index1875"></a><i>ограничены</i>, 
  это значит, что другие объекты могут запрещать изменения этого свойства, если 
  это недопустимо. Другие объекты уведомляются при помощи <a name="Index1876"></a><a name="Index1877"></a><b>PropertyChangeEvent</b>, 
  и они могут выбросить исключение <a name="Index1878"></a><a name="Index1879"></a><b>PropertyVetoException</b> 
  для предотвращения изменений и для восстановления старого значения.</font></p>
<p><a name="Index1880"></a><a name="Index1881"></a><a name="Index1882"></a><a name="Index1883"></a><a name="Index1884"></a><a name="Index1885"></a><a name="Index1886"></a><a name="Index1887"></a><font face="Georgia">Вы 
  также можете изменить способ представления вашего компонента (Bean) в режиме 
  дизайна:</font></p>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Вы можете обеспечить специальную 
    страницу свойств для вашего определенного компонента (Bean). Обычная страница 
    свойств будет использоваться для всех остальных компонентов (Bean), а ваша 
    будет вызываться автоматически, когда будет выбран ваш компонент (</font><font face="Georgia">Bean).</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Вы можете создать специальный 
    редактор для определенного свойства, так что будет использоваться обычная 
    страница свойств, но когда вы начнете редактировать особое свойство, ваш редактор 
    вызовется автоматически.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Вы можете обеспечить специальный 
    класс <b>BeanInfo</b> для вашего компонента (Bean), который будет производить 
    информацию, отличную от информации по умолчанию, создаваемой <b>Introspector</b>.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Также возможно включать 
    и выключать режим “эксперта” во всех <b>FeatureDescriptor</b> 
    для различия между основными особенностями и более сложными особенностями.</font><a name="_Toc481064842"></a> 
</li></ol>
<a name="Heading477"></a><font face="Verdana">
<h3 align="left"> Больше о компонентах (Beans)</h3>
</font> 
<p><font face="Georgia">Есть другой подход, который не будет указан здесь. Где 
  бы вы не создавали компонент (</font><font face="Georgia">Bean), вы должны ожидать, 
  что он будет работать в многопоточной среде. Это означает, что вы должны понимать 
  способности потоков, которые будут введены в <a href=" Chapter14.html">Главе 
  14</a>. Вы найдете раздел, называемый “возврат к JavaBeans”, в которой 
  мы рассмотрим проблему и ее решение.</font></p>
<p><font face="Georgia">Есть несколько книг, посвященных JavaBeans; например, 
  <i>JavaBeans</i> by Elliotte Rusty Harold (IDG, 1998).</font><a name="_Toc481064843"></a></p>
<a name="Heading478"></a> <font face="Verdana">
<h3 align="left">Резюме</h3>
</font><font face="Verdana"></font> 
<p><font face="Georgia">Все библиотеки Java, а GUI библиотеки особенно, претерпели 
  значительные изменения при переходе от Java 1.0 к Java 2. Java 1.0 AWT сильно 
  критиковалась, как имеющих один из худших дизайнов, в то время как она позволяла 
  вам создавать портативные программы, а результирующий GUI </font><font face="Georgia"> 
  “эквивалентно выглядел на всех платформах”. Она была также ограничена, 
  неуклюжа и неприятна в использовании по сравнению с родными инструментами разработки 
  приложений, имеющихся для определенной платформы.</font></p>
<p><font face="Georgia">Когда Java 1.1 ввела новую модель событий и JavaBeans, 
  на которые был сделан упор, стало возможным создавать GUI компоненты, которые 
  легко могут быть перетащены и брошены в визуальном построителе приложений. Кроме 
  того, дизайн модели событий и компонентов (Bean) ясно показывает, что большое 
  внимание было уделено облегчению программирования и поддержки кода (то, что 
  не было очевидно в 1.0 AWT). Но это было не так, пока не появились классы JFS/Swing, 
  в которых эта работа была завершена. Со Swing компонентами кросс-платформенное 
  программирование стало носить цивилизованный вид.</font></p>
<p><font face="Georgia">На самом деле, не хватало только одного - построителя 
  приложений, и это было настоящей революцией. <a name="Index1888"></a>Microsoft 
  Visual Basic и Visual C++ требуют построителя приложений от фирмы Microsoft, 
  точно так же как и <a name="Index1889"></a>Borland Delphi и C++ Builder. Если 
  вы хотите получить лучший построитель приложений, вы можете скрестить пальцы 
  и надеяться, что продавец даст вам то, что вы хотите. Но Java - это открытая 
  система, что позволяет не только состязаться средам разработки, но одобряет 
  такое состязание. И для таких инструментов важна поддержка JavaBeans. Это означает 
  уровневое поле игры: если вы находите лучший инструмент построителя приложений, 
  вы не привязаны к тому, который вы используете — вы можете взять и перейти 
  на другой, который повысит вашу производительность. Соперничество такого рода 
  между средами построения GUI приложений ранее не встречалось, а в результате 
  из-за продаж может быть получен позитивный рост производительности программистов.</font></p>
<p><font face="Georgia">Эта глава создавалась с целью дать вам начальное представление 
  о силе Swing и показать вам, насколько относительно просто почувствовать вкус 
  библиотеки. То, что вы видели, вероятно, достаточно для удовлетворения большей 
  части вашего пользовательского интерфейса. Однако Swing может много больше — 
  он предназначен, чтобы быть мощным инструментом разработки пользовательского 
  интерфейса. Вероятно, есть способ совершить все, что вы можете придумать.</font></p>
<p><font face="Georgia">Если вы не увидели здесь то, что вам нужно, покопайтесь 
  в онлайн документации от Sun и поищите в Web, и если этого не достаточно, то 
  найдите книгу, посвященную Swing — неплохо начать с <i>The JFC Swing Tutorial</i>, 
  by Walrath &amp; Campione (Addison Wesley, 1999). </font><a name="_Toc375545470"></a><a name="_Toc481064844"></a></p>
<div align="left"></div>
<a name="Heading479"></a> <font face="Verdana">
<h2 align="left">Упражнения</h2>
</font>
<div align="left"> 
  <p><font face="Georgia" size="2">Решения для выбранных упражнений могут быть найдены 
    в электронной документации <i>The Thinking in Java Annotated Solution Guide</i>, 
    доступной за малую плату на <i>www.BruceEckel.com</i>.</font></p>
</div>
<ol>
  <li><font face="Verdana"> </font><font face="Georgia">Создайте апплет/приложение, 
    используя класс <b>Console</b>, как показано в этой главе. Включите текстовое 
    поле и три кнопки. Когда вы нажимаете каждую кнопку, сделайте, чтобы разный 
    текст появлялся в текстовом поле.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Добавьте checkBox-элемент 
    в апплет, созданный в Упражнении 1, перехватите событие, и вставляйте разный 
    текст в текстовое поле.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте апплет/приложение, 
    используя <b>Console</b>. В HTML документации с <i>java.sun.com</i>, найдите 
    <b>JPasswordField</b> и добавьте его в программу. Если пользователь печатает 
    правильный пароль, используйте <b>Joptionpane</b> для выдачи пользователю 
    информации об успехе.</font>
  </li><li> <font face="Verdana"> </font><font face="Georgia">Создайте апплет/приложение, 
    используя <b>Console</b>, и добавьте все компоненты, имеющие метод <b>addActionListener(&nbsp;)</b>. 
    (Найдите их в HTML документации с <i>java.sun.com</i>. Совет: используйте 
    индекс.) Захватите события и отобразите соответствующее сообщение для каждого 
    из них в текстовом поле.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте апплет/приложение, 
    используя <b>Console</b>, с элементами <b>JButton</b> и<b> JTextField</b>. 
    Напишите и присоедините соответствующие слушатели, чтобы если кнопка имела 
    фокус, символы, напечатанные на ней, появлялись в <b> JTextField</b>.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте апплет/приложение, 
    используя <b>Console</b>. Добавьте в главный фрейм все компоненты, описанные 
    в этой главе, включая меню и диалоги.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените <b>TextFields.java</b> 
    так, чтобы символы в <b>t2</b> сохраняли свой регистр, в котором они были 
    набраны, вместо принудительного автоматического перевода в верхний регистр.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Найдите и загрузите один 
    или несколько бесплатных сред разработки GUI, доступных в Internet, или купите 
    коммерческие продукты. Исследуйте, что необходимо для добавления <b>BangBean</b> 
    в эту среду и сделайте это.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Добавьте <b>Frog.class</b> 
    в файл манифеста, как показано в этой главе, и запустите <b>jar</b> для создания 
    JAR файла, содержащего и <b>Frog</b> и <b>BangBean</b>. Теперь либо загрузите 
    и установите BDK от Sun, или используйте свой собственный компонент-ориентированный 
    построитель программ, и добавьте JAR файл в свою среду, так, чтобы вы могли 
    проверить оба компонента (Beans).</font>
  </li><li><font face="Georgia">Создайте свой собственный JavaBean, называемый <b>Valve</b>, 
    который содержит два свойства: <b>boolean</b>, называемый “on”, 
    и <b>int</b>, называемый “level”. Создайте файл манифеста, используйте 
    <b>jar</b> для упаковки вашего компонента, затем загрузите его в beanbox или 
    в компонент-ориентированную среду разработки, чтобы вы могли проверить его.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените <b>MessageBoxes.java</b> 
    так, чтобы он имел индивидуальный <b>ActionListener</b> для каждой кнопки 
    (вместо проверки текста кнопок).</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Отследите новый тип события 
    в <b>TrackEvent.java</b>, добавив новый код обработчика события. Вам нужно 
    будет исследовать ваш собственный тип события, который вы хотите отслеживать.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Наследуйте новый тип кнопки 
    от <b>JButton</b>. Каждый раз при нажатии этой кнопки она должна менять свой 
    цвет в случайном порядке. Смотрите <b>ColorBoxes.java</b> в <a href=" Chapter14.html">Главе 
    14</a> о том, как генерировать случайное значение цвета.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените <b>TextPane.java</b>, 
    чтобы она использовала <b>JTextArea</b> вместо <b>JTextPane</b>.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените <b>Menus.java</b>, 
    чтобы она использовала радио кнопки вместо checkBox-элементов в меню.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Упростите <b>List.java</b>, 
    передав массив в конструктор и подавите динамическое добавление элементов 
    в список.</font>
  </li><li><font face="Georgia">Измените <b>SineWave.java</b>, включив <b>SineDraw</b> 
    в JavaBean, добавив методы “получения” и “установки”.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Помните игрушку “рисующий 
    ящик ” с двумя кнопками, одна из которых управляла вертикальным перемещением 
    точки рисования, а другая управляла горизонтальным перемещением? Создайте 
    такую, используя <b>SineWave.java </b>для начала. Вместо кнопок используйте 
    слайдеры. Добавьте кнопку, которая будет стирать весь рисунок.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте “асимптотический 
    индикатор прогресса”, который становится все медленнее и медленнее при 
    приближении к финальной точке. Добавьте случайное странное поведение, чтобы 
    это выглядело как начало ускорения.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Измените <b>Progress.java</b> 
    так, чтобы она не использовала распределенные модели, а вместо этого использовала 
    слушатели для соединения слайдера и полосы прогресса.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Следуйте инструкциям из 
    раздела “Упаковка апплетов в JAR файл” для помещения <b>TicTacToe.java</b> 
    в JAR файл. Создайте HTML страницу для (грязной, сложной) версии ярлыка апплета, 
    и измените его для использования ярлыка архива, чтобы он использовал JAR файл. 
    (Совет: начните с HTML страницы для <b>TicTacToe.java </b>которая идет вместе 
    с исходным кодом этой книги.)</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Создайте апплет/приложение, 
    используя <b>Console</b>. Оно должно иметь три слайдера, каждый из которых 
    имеет красное, зеленое и синее значение для <b>java.awt.Color</b>. Оставшаяся 
    часть формы должна быть использована для <b>JPanel</b>, которая отображает 
    цвет, определяемый этими тремя слайдерами. Также включите не редактируемое 
    текстовое поле, которое показывает текущие RGB значения.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">В HTML документации для 
    <b>javax.swing</b> найдите <b>JColorChooser</b>. Напишите программу с кнопкой, 
    которая показывает диалог выбора цвета.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Почти все компоненты Swing 
    наследованы от <b>Component</b>, который имеет метод <b>setCursor(&nbsp;)</b>. 
    Найдите это в HTML документации для Java. Создайте апплет и измените курсор 
    на один из списка курсоров, имеющихся в классе <b>Cursor</b>.</font>
  </li><li><font face="Verdana"> </font><font face="Georgia">Начав с <b>ShowAddListeners.java</b>, 
    создайте программу с полной функциональностью <b>ShowMethodsClean.java</b> 
    из <a href=" Chapter12.html">Главы 12</a>.</font>
</li></ol>
<hr>
<p><a href="#fnB61">[61]</a><font face="Georgia" size="2"> Вариации этого называются 
  “принципом наименьшего удивления”, который особенно подчеркивает: 
  “не удивляйте пользователя”.</font></p>
<p><a href="#fnB62">[62]</a><font face="Georgia" size="2"> Это пример шаблона разработки, 
  называемый <i>метод шаблонов</i>.</font></p>
<p><a href="#fnB63">[63]</a><font face="Georgia" size="2"> Здесь принимается во 
  внимание то, что читатель хорошо знаком с основами HTML. Это не трудно понять 
  и есть много книг и ресурсов на эту тему.</font></p>
<p><a href="#fnB64">[64]</a><font face="Georgia" size="2"> Эта страница —обычно, 
  раздел ‘clsid’ — выглядит хорошо работающей и с JDK1.2.2, 
  и с JDK1.3 rc-1. Однако вы можете обнаружить изменение ярлыка когда-нибудь в 
  будущем. Более детально смотрите <i>java.sun.com</i>.</font></p>
<p><a href="#fnB65">[65]</a><font face="Georgia" size="2"> По моему мнению. И после 
  того, как вы выучите Swing, вы не захотите тратить ваше время на подготовительный 
  материал.</font></p>
<p><a href="#fnB66">[66]</a><font face="Georgia" size="2"> Как описано ранее, “Frame” 
  был уже введен в AWT, так что Swing использует JFrame.</font></p>
<p><a href="#fnB67">[67]</a><font face="Georgia" size="2"> Это будет иметь смысл 
  после того, как вы прочтете продолжение этой главы. Прежде всего, сделайте ссылку 
  на <b>JApplet</b> статическим членом класса member (вместо локальной переменной 
  в <b>main(&nbsp;)</b>), а затем вызовите <b>applet.stop(&nbsp;)</b> и <b>applet.destroy(&nbsp;)</b> 
  внутри <b>WindowAdapter.windowClosing(&nbsp;)</b>, прежде, чем вы вызовите <b>System.exit(&nbsp;)</b>.</font> 
</p>
<p><a href="#fnB68">[68]</a><font face="Georgia" size="2"> Не существует <b>MouseMotionEvent</b>, 
  несмотря на то, что кажется, что оно должно быть. Щелчки и движение комбинируются 
  в <b>MouseEvent</b>, так что это второе появление <b>MouseEvent</b> в таблице 
  не является ошибкой.</font></p>
<p><a href="#fnB69">[69]</a><font face="Georgia" size="2"> В Java 1.0/1.1 вы не 
  могли выполнять полезное наследование от объекта кнопки. Это был один из многочисленных 
  фундаментальных недостатков проекта</font>.</p>
<hr width="100%">
<p align="center"><font face="Verdana" size="-1">[ <a href=" Chapter12.html">Предыдущая 
  глава</a> ] [ <a href=" SimpleContents.html">Содержание</a> ] [ <a href=" Contents.html">Оглавление</a> 
  ] [ <a href=" DocIndex.html">Индекс</a> ] [ <a href=" Chapter14.html">Следующая 
  глава </a> ]</font></p>
</body></html>